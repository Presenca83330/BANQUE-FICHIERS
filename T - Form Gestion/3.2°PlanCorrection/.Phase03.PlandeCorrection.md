# üîß CORRECTION DES FICHIERS PREVUS LORS DE L ANALYSE DE Phase02-AnalyseduBug.md

## üìã Diagnostic

**Probl√®me identifi√©** : Les Edge Functions de gestion (`gestion-reseau-admin`, `gestion-reseau-admin-donnees`, `gestion-reseau-admin-update`, `gestion-reseau-admin-fichiers`) exigent que le client envoie `SERVICE_ROLE_KEY` via `assertServiceRoleAuth()`, alors que le frontend envoie `ANON_KEY`.

**Solution** : Supprimer `assertServiceRoleAuth()` et `assertAdminIfProvided()` pour aligner l'architecture sur `create-reseau-admin` qui fonctionne.

---

## ‚úÖ Fichier 1/4 : `supabase/functions/gestion-reseau-admin/index.ts`

### Code Corrig√© Complet

```typescript
// supabase/functions/gestion-reseau-admin/index.ts
// Liste les r√©seaux pour l'espace de gestion.
// Strat√©gie : SERVICE_ROLE_KEY interne (verify_jwt=false) sans contr√¥le applicatif.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const t0 = performance.now();

    // Projection MINIMALE pour le s√©lecteur : reseau_nom (1er), reseau_id
    const { data, error } = await supabase
      .from("reseau")
      .select("reseau_nom, reseau_id")
      .order("reseau_nom", { ascending: true });

    const durationMs = Math.round(performance.now() - t0);

    if (error) {
      logStructured("reseau_list_error", { requestId, error: error.message, duration_ms: durationMs });
      return jsonResponse(
        { ok: false, error: "db_error_reseau_list", details: error.message, requestId },
        500,
      );
    }

    // Forcer l'ordre des propri√©t√©s (reseau_nom en 1er) dans la r√©ponse
    const dataMinimal = (data ?? []).map((r: any) => ({
      reseau_nom: r.reseau_nom,
      reseau_id: r.reseau_id,
    }));

    logStructured("reseau_list_ok", {
      requestId,
      result_count: dataMinimal.length,
      duration_ms: durationMs,
    });

    return jsonResponse(
      { ok: true, requestId, count: dataMinimal.length, data: dataMinimal },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});
```

### Modifications appliqu√©es :
- ‚ùå **SUPPRIM√â** : `assertServiceRoleAuth()` (lignes 47-60)
- ‚ùå **SUPPRIM√â** : `assertAdminIfProvided()` (lignes 65-96)
- ‚ùå **SUPPRIM√â** : Appel √† `assertServiceRoleAuth()` (ligne 108)
- ‚ùå **SUPPRIM√â** : Appel √† `assertAdminIfProvided()` (lignes 132-138)
- ‚úÖ **CONSERV√â** : Client `supabase` avec `SERVICE_ROLE_KEY` interne

---

## ‚úÖ Fichier 2/4 : `supabase/functions/gestion-reseau-admin-donnees/index.ts`

### Code Corrig√© Complet

```typescript
// supabase/functions/gestion-reseau-admin-donnees/index.ts
// R√©cup√®re les donn√©es d√©taill√©es d'un r√©seau et ses int√©grations.
// Strat√©gie : SERVICE_ROLE_KEY interne (verify_jwt=false) sans contr√¥le applicatif.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Projections ------------------------------------------------------------
const RESEAU_PROJECTION = `
  reseau_id, reseau_nom, reseau_adresse, reseau_code_postal, reseau_ville,
  reseau_siret, reseau_email, reseau_telephone, reseau_statut, reseau_logo,
  reseau_ressources, brevo_connexion_id, zoho_connexion_id, openai_connexion_id,
  reseau_created_at, reseau_updated_at
`.replace(/\s+/g, " ").trim();

const INTEGRATION_PROJECTION = "*";

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    // R√©cup√©rer reseau_id depuis query params ou body
    let reseauId: string | null = null;
    const url = new URL(req.url);
    reseauId = url.searchParams.get("reseau_id");

    if (!reseauId && req.method === "POST") {
      try {
        const body = await req.json().catch(() => ({}));
        if (body && typeof body.reseau_id === "string") reseauId = body.reseau_id;
      } catch {
        // ignore
      }
    }

    if (!reseauId) {
      return jsonResponse(
        { ok: false, error: "missing_reseau_id", requestId },
        400,
      );
    }

    const t0 = performance.now();

    // 1. R√©cup√©rer les donn√©es r√©seau
    const { data: reseauData, error: reseauError } = await supabase
      .from("reseau")
      .select(RESEAU_PROJECTION)
      .eq("reseau_id", reseauId)
      .maybeSingle();

    if (reseauError) {
      logStructured("reseau_fetch_error", { requestId, error: reseauError.message });
      return jsonResponse(
        { ok: false, error: "db_error_reseau", details: reseauError.message, requestId },
        500,
      );
    }

    if (!reseauData) {
      return jsonResponse(
        { ok: false, error: "reseau_not_found", requestId },
        404,
      );
    }

    // 2. R√©cup√©rer les int√©grations si pr√©sentes
    const integrations: any = {};

    // Brevo
    if (reseauData.brevo_connexion_id) {
      const { data: brevoData } = await supabase
        .from("brevo_connexion")
        .select(INTEGRATION_PROJECTION)
        .eq("brevo_connexion_id", reseauData.brevo_connexion_id)
        .maybeSingle();
      integrations.brevo = brevoData || null;
    }

    // Zoho
    if (reseauData.zoho_connexion_id) {
      const { data: zohoData } = await supabase
        .from("zoho_connexion")
        .select(INTEGRATION_PROJECTION)
        .eq("zoho_connexion_id", reseauData.zoho_connexion_id)
        .maybeSingle();
      integrations.zoho = zohoData || null;
    }

    // OpenAI
    if (reseauData.openai_connexion_id) {
      const { data: openaiData } = await supabase
        .from("openai_connexion")
        .select(INTEGRATION_PROJECTION)
        .eq("openai_connexion_id", reseauData.openai_connexion_id)
        .maybeSingle();
      integrations.openai = openaiData || null;
    }

    const durationMs = Math.round(performance.now() - t0);

    logStructured("reseau_data_ok", {
      requestId,
      reseauId,
      duration_ms: durationMs,
    });

    return jsonResponse(
      {
        ok: true,
        requestId,
        data: {
          reseau: reseauData,
          integrations,
        },
      },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});
```

### Modifications appliqu√©es :
- ‚ùå **SUPPRIM√â** : `assertServiceRoleAuth()`
- ‚ùå **SUPPRIM√â** : `assertAdminIfProvided()`
- ‚ùå **SUPPRIM√â** : Tous les appels aux fonctions d'authentification
- ‚úÖ **CONSERV√â** : Client `supabase` avec `SERVICE_ROLE_KEY` interne

---

## ‚úÖ Fichier 3/4 : `supabase/functions/gestion-reseau-admin-update/index.ts`

### Code Corrig√© Complet

```typescript
// supabase/functions/gestion-reseau-admin-update/index.ts
// Met √† jour les informations r√©seau et g√®re les int√©grations.
// Strat√©gie : SERVICE_ROLE_KEY interne (verify_jwt=false) sans contr√¥le applicatif.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Configuration int√©grations ---------------------------------------------
const INTEGRATION_TABLES = {
  brevo: {
    table: "brevo_connexion",
    idField: "brevo_connexion_id",
    reseauFk: "brevo_connexion_id",
  },
  zoho: {
    table: "zoho_connexion",
    idField: "zoho_connexion_id",
    reseauFk: "zoho_connexion_id",
  },
  openai: {
    table: "openai_connexion",
    idField: "openai_connexion_id",
    reseauFk: "openai_connexion_id",
  },
} as const;

type IntegrationKind = keyof typeof INTEGRATION_TABLES;

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  if (req.method !== "POST") {
    return jsonResponse(
      { ok: false, error: "method_not_allowed", requestId },
      405,
    );
  }

  try {
    const body = await req.json().catch(() => ({}));
    const { reseauId, generalData, integrationKind, integrationData } = body;

    if (!reseauId) {
      return jsonResponse(
        { ok: false, error: "missing_reseau_id", requestId },
        400,
      );
    }

    const t0 = performance.now();
    const results: any = {};

    // 1. Mise √† jour donn√©es g√©n√©rales r√©seau
    if (generalData) {
      const { data: updatedReseau, error: updateError } = await supabase
        .from("reseau")
        .update(generalData)
        .eq("reseau_id", reseauId)
        .select()
        .single();

      if (updateError) {
        logStructured("reseau_update_error", {
          requestId,
          reseauId,
          error: updateError.message,
        });
        return jsonResponse(
          { ok: false, error: "db_error_reseau_update", details: updateError.message, requestId },
          500,
        );
      }

      results.reseau = updatedReseau;
      logStructured("reseau_update_ok", { requestId, reseauId });
    }

    // 2. Gestion int√©grations
    if (integrationKind && integrationData) {
      const config = INTEGRATION_TABLES[integrationKind as IntegrationKind];
      if (!config) {
        return jsonResponse(
          { ok: false, error: "invalid_integration_kind", requestId },
          400,
        );
      }

      const existingConnectionId = integrationData[config.idField];

      if (existingConnectionId) {
        // Mise √† jour int√©gration existante
        const { data: updatedIntegration, error: updateIntegError } = await supabase
          .from(config.table)
          .update(integrationData)
          .eq(config.idField, existingConnectionId)
          .select()
          .single();

        if (updateIntegError) {
          logStructured("integration_update_error", {
            requestId,
            kind: integrationKind,
            error: updateIntegError.message,
          });
          return jsonResponse(
            {
              ok: false,
              error: "db_error_integration_update",
              details: updateIntegError.message,
              requestId,
            },
            500,
          );
        }

        results[integrationKind] = updatedIntegration;
        logStructured("integration_update_ok", {
          requestId,
          kind: integrationKind,
          connectionId: existingConnectionId,
        });
      } else {
        // Cr√©ation nouvelle int√©gration
        const { data: newIntegration, error: insertIntegError } = await supabase
          .from(config.table)
          .insert(integrationData)
          .select()
          .single();

        if (insertIntegError) {
          logStructured("integration_insert_error", {
            requestId,
            kind: integrationKind,
            error: insertIntegError.message,
          });
          return jsonResponse(
            {
              ok: false,
              error: "db_error_integration_insert",
              details: insertIntegError.message,
              requestId,
            },
            500,
          );
        }

        const newConnectionId = newIntegration[config.idField];

        // Lier l'int√©gration au r√©seau
        const { error: linkError } = await supabase
          .from("reseau")
          .update({ [config.reseauFk]: newConnectionId })
          .eq("reseau_id", reseauId);

        if (linkError) {
          logStructured("integration_link_error", {
            requestId,
            kind: integrationKind,
            error: linkError.message,
          });
          return jsonResponse(
            {
              ok: false,
              error: "db_error_integration_link",
              details: linkError.message,
              requestId,
            },
            500,
          );
        }

        results[integrationKind] = newIntegration;
        logStructured("integration_create_ok", {
          requestId,
          kind: integrationKind,
          connectionId: newConnectionId,
        });
      }
    }

    const durationMs = Math.round(performance.now() - t0);

    logStructured("update_complete", {
      requestId,
      reseauId,
      duration_ms: durationMs,
    });

    return jsonResponse(
      {
        ok: true,
        requestId,
        data: results,
      },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});
```

### Modifications appliqu√©es :
- ‚ùå **SUPPRIM√â** : `assertServiceRoleAuth()`
- ‚ùå **SUPPRIM√â** : `assertAdminIfProvided()`
- ‚ùå **SUPPRIM√â** : Tous les appels aux fonctions d'authentification
- ‚úÖ **CONSERV√â** : Client `supabase` avec `SERVICE_ROLE_KEY` interne

---

## ‚úÖ Fichier 4/4 : `supabase/functions/gestion-reseau-admin-fichiers/index.ts`

### Code Corrig√© Complet

```typescript
// supabase/functions/gestion-reseau-admin-fichiers/index.ts
// Gestion des fichiers (upload/delete) pour un r√©seau.
// Strat√©gie : SERVICE_ROLE_KEY interne (verify_jwt=false) sans contr√¥le applicatif.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const BUCKET_NAME = "bucket-table-reseau";
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- Types ------------------------------------------------------------------
interface ReseauRow {
  reseau_id: string;
  reseau_logo?: string | null;
  reseau_ressources?: string[] | null;
}

type JsonRecord = Record<string, unknown>;

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, DELETE, OPTIONS",
};

function jsonResponse(body: JsonRecord, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
    },
  });
}

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Helpers ----------------------------------------------------------------
function sanitizeFilename(name: string): string {
  return name
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9._-]/gi, "_")
    .toLowerCase();
}

function folderForFileType(fileType: string): string {
  if (fileType === "logo") return "logos";
  if (fileType === "ressource") return "ressources";
  return "autres";
}

function isValidUUID(uuid: string): boolean {
  const regex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return regex.test(uuid);
}

// --- Database helpers -------------------------------------------------------
async function getReseau(reseauId: string): Promise<ReseauRow | null> {
  const { data, error } = await supabase
    .from("reseau")
    .select("reseau_id, reseau_logo, reseau_ressources")
    .eq("reseau_id", reseauId)
    .maybeSingle();

  if (error) {
    logStructured("db_error_get_reseau", { reseauId, error: error.message });
    return null;
  }
  return data;
}

async function setReseauLogo(
  reseauId: string,
  logoPath: string,
): Promise<boolean> {
  const { error } = await supabase
    .from("reseau")
    .update({ reseau_logo: logoPath })
    .eq("reseau_id", reseauId);

  if (error) {
    logStructured("db_error_set_logo", { reseauId, error: error.message });
    return false;
  }
  return true;
}

async function addReseauRessource(
  reseauId: string,
  ressourcePath: string,
): Promise<boolean> {
  const reseau = await getReseau(reseauId);
  if (!reseau) return false;

  const current = reseau.reseau_ressources ?? [];
  const updated = [...current, ressourcePath];

  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);

  if (error) {
    logStructured("db_error_add_ressource", { reseauId, error: error.message });
    return false;
  }
  return true;
}

async function removeReseauRessource(
  reseauId: string,
  ressourcePath: string,
): Promise<boolean> {
  const reseau = await getReseau(reseauId);
  if (!reseau) return false;

  const current = reseau.reseau_ressources ?? [];
  const updated = current.filter((r) => r !== ressourcePath);

  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);

  if (error) {
    logStructured("db_error_remove_ressource", {
      reseauId,
      error: error.message,
    });
    return false;
  }
  return true;
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  if (req.method !== "POST") {
    return jsonResponse({ ok: false, error: "method_not_allowed", requestId }, 405);
  }

  try {
    const contentType = req.headers.get("content-type") || "";

    // --- UPLOAD (multipart/form-data) ---
    if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      const file = formData.get("file") as File | null;
      const reseauId = formData.get("reseau_id") as string | null;
      const fileType = (formData.get("file_type") as string | null) ?? "ressource";

      if (!file || !reseauId) {
        return jsonResponse(
          { ok: false, error: "missing_file_or_reseau_id", requestId },
          400,
        );
      }

      if (!isValidUUID(reseauId)) {
        return jsonResponse(
          { ok: false, error: "invalid_reseau_id", requestId },
          400,
        );
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        return jsonResponse(
          { ok: false, error: "reseau_not_found", requestId },
          404,
        );
      }

      const folder = folderForFileType(fileType);
      const sanitized = sanitizeFilename(file.name);
      const storagePath = `${reseauId}/${folder}/${sanitized}`;

      const fileBuffer = await file.arrayBuffer();
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from(BUCKET_NAME)
        .upload(storagePath, fileBuffer, {
          contentType: file.type,
          upsert: true,
        });

      if (uploadError) {
        logStructured("storage_upload_error", {
          requestId,
          error: uploadError.message,
        });
        return jsonResponse(
          {
            ok: false,
            error: "storage_upload_failed",
            details: uploadError.message,
            requestId,
          },
          500,
        );
      }

      // Mise √† jour DB
      let dbSuccess = false;
      if (fileType === "logo") {
        dbSuccess = await setReseauLogo(reseauId, uploadData.path);
      } else if (fileType === "ressource") {
        dbSuccess = await addReseauRessource(reseauId, uploadData.path);
      }

      if (!dbSuccess) {
        return jsonResponse(
          { ok: false, error: "db_update_failed", requestId },
          500,
        );
      }

      logStructured("file_upload_ok", {
        requestId,
        reseauId,
        fileType,
        path: uploadData.path,
      });

      return jsonResponse(
        {
          ok: true,
          requestId,
          data: { path: uploadData.path, fileType },
        },
        200,
      );
    }

    // --- DELETE (application/json) ---
    if (contentType.includes("application/json")) {
      const body = await req.json().catch(() => ({}));
      const { reseau_id: reseauId, path, file_type: fileType } = body;

      if (!reseauId || !path) {
        return jsonResponse(
          { ok: false, error: "missing_reseau_id_or_path", requestId },
          400,
        );
      }

      if (!isValidUUID(reseauId)) {
        return jsonResponse(
          { ok: false, error: "invalid_reseau_id", requestId },
          400,
        );
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        return jsonResponse(
          { ok: false, error: "reseau_not_found", requestId },
          404,
        );
      }

      // Suppression storage
      const { error: deleteError } = await supabase.storage
        .from(BUCKET_NAME)
        .remove([path]);

      if (deleteError) {
        logStructured("storage_delete_error", {
          requestId,
          error: deleteError.message,
        });
        return jsonResponse(
          {
            ok: false,
            error: "storage_delete_failed",
            details: deleteError.message,
            requestId,
          },
          500,
        );
      }

      // Mise √† jour DB
      let dbSuccess = false;
      if (fileType === "logo") {
        dbSuccess = await setReseauLogo(reseauId, "");
      } else if (fileType === "ressource") {
        dbSuccess = await removeReseauRessource(reseauId, path);
      }

      if (!dbSuccess) {
        return jsonResponse(
          { ok: false, error: "db_update_failed", requestId },
          500,
        );
      }

      logStructured("file_delete_ok", {
        requestId,
        reseauId,
        path,
      });

      return jsonResponse(
        {
          ok: true,
          requestId,
          message: "file_deleted",
        },
        200,
      );
    }

    return jsonResponse(
      { ok: false, error: "unsupported_content_type", requestId },
      415,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});
```

### Modifications appliqu√©es :
- ‚ùå **SUPPRIM√â** : `assertServiceRoleAuth()`
- ‚ùå **SUPPRIM√â** : `assertAdminIfProvided()`
- ‚ùå **SUPPRIM√â** : Tous les appels aux fonctions d'authentification
- ‚úÖ **CONSERV√â** : Client `supabase` avec `SERVICE_ROLE_KEY` interne

---

## üìä R√©sum√© des Fichiers Non-Modifi√©s

### ‚úÖ Pas besoin de correction

Les fichiers suivants **n'ont pas besoin de correction** car ils fonctionnent correctement :

#### 1. `src/integrations/supabase/client.ts`
- Envoie `ANON_KEY` (comportement normal)
- Utilis√© par les hooks frontend

#### 2. `supabase/config.toml`
- Configuration `verify_jwt = false` d√©j√† en place
- Identique pour cr√©ation et gestion

#### 3. `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData.ts`
- Appelle correctement les Edge Functions
- Aucun changement requis c√¥t√© frontend

#### 4. `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations.ts`
- Appelle correctement les Edge Functions
- Aucun changement requis c√¥t√© frontend

---

## üéØ Architecture Finale Align√©e

### Avant Correction (‚ùå Rejet)
```
Frontend (ANON_KEY) 
  ‚Üí Edge Function: assertServiceRoleAuth() ‚ùå REJETTE
  ‚Üí Erreur 401
```

### Apr√®s Correction (‚úÖ Fonctionnel)
```
Frontend (ANON_KEY) 
  ‚Üí Edge Function: utilise SERVICE_ROLE_KEY interne ‚úÖ
  ‚Üí Client Supabase Admin (bypass RLS)
  ‚Üí Succ√®s
```

---

## üìù Notes de Mise en ≈íuvre

1. **Appliquer les 4 corrections** sur les Edge Functions de gestion
2. **Aucune modification** des hooks frontend n√©cessaire
3. **Aucune modification** de `config.toml` n√©cessaire
4. **Architecture identique** √† `create-reseau-admin` qui fonctionne

---

**‚úÖ FIN DU DOCUMENT DE CORRECTION**
