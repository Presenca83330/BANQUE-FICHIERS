# 🔑 PHASE 2 - CODES COMPLETS SERVICE_ROLE_KEY POUR FORMULAIRE GESTION RÉSEAU

## ⚠️ CORRECTIONS SUITE À AUDIT ARCHITECTURE

### 🔧 Points Corrigés
1. **Upload fichiers** : Respect du design `organisation-{uuid}/1-logos/...` au lieu de `reseau-{reseauId}/...`
2. **Retour Edge update** : Inclusion des champs auto-gérés (`updated_at`, `updated_by`) dans le RETURNING
3. **Suppression fichiers** : Centralisation via Edge Function pour sécurité et logs

## 1. ARCHITECTURE COMPLÈTE DU FORMULAIRE DE GESTION

### 📁 Structure avec stratégie SERVICE_ROLE_KEY

```
src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/
├── 3.FormReseauGestion.tsx                     [MODIFIÉ - Appels Edge Functions]
└── ...

src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/
├── hooks/
│   ├── useReseauFormData.ts                    [MODIFIÉ - SERVICE_ROLE_KEY]
│   ├── useReseauIntegrations.ts                [MODIFIÉ - SERVICE_ROLE_KEY]
│   └── types.ts                                [INCHANGÉ]
└── components/
    └── ReseauSelector.tsx                      [INCHANGÉ]

supabase/functions/
├── gestion-reseau-admin/                       [NOUVEAU - Liste réseaux]
│   └── index.ts
├── gestion-reseau-admin-donnees/               [NOUVEAU - Données détaillées]
│   └── index.ts
├── gestion-reseau-admin-update/                [NOUVEAU - Sauvegarde]
│   └── index.ts
├── gestion-reseau-admin-fichiers/              [NOUVEAU - Upload fichiers]
│   └── index.ts
└── _shared/
    └── cors.ts                                 [INCHANGÉ]
```

---

## 2. SOMMAIRE DES FICHIERS

- [3. Hooks](#3-hooks)
  - [3.1 useReseauFormData.ts (MODIFIÉ)](#31-usereseauformdatats-modifié)
  - [3.2 useReseauIntegrations.ts (MODIFIÉ)](#32-usereseauintegrationsts-modifié)
  - [3.3 types.ts (INCHANGÉ)](#33-typests-inchangé)

- [4. Composants](#4-composants)
  - [4.1 ReseauSelector.tsx (INCHANGÉ)](#41-reseauselectortsx-inchangé)

- [5. Edge Functions SERVICE_ROLE_KEY](#5-edge-functions-service_role_key)
  - [5.1 gestion-reseau-admin](#51-gestion-reseau-admin)
  - [5.2 gestion-reseau-admin-donnees](#52-gestion-reseau-admin-donnees)
  - [5.3 gestion-reseau-admin-update](#53-gestion-reseau-admin-update)
  - [5.4 gestion-reseau-admin-fichiers](#54-gestion-reseau-admin-fichiers)

- [6. SQL de Migration](#6-sql-de-migration)

- [7. Page Formulaire](#7-page-formulaire)
  - [7.1 FormReseauGestion.tsx (MODIFIÉ)](#71-formreseaugestiontsx-modifié)

- [8. Fichiers à Supprimer](#8-fichiers-à-supprimer)

---

## 3. HOOKS

### 3.1 useReseauFormData.ts (MODIFIÉ)

**📂 Emplacement :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData.ts`

```typescript
import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import type { ReseauFormData, ReseauSelectorItem, ValidationErrors } from './types';

export function useReseauFormData() {
  const [reseaux, setReseaux] = useState<ReseauSelectorItem[]>([]);
  const [selectedReseauId, setSelectedReseauId] = useState<string>('');
  const [formData, setFormData] = useState<Partial<ReseauFormData>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [errors, setErrors] = useState<ValidationErrors>({});
  const { toast } = useToast();

  /**
   * 🔑 SERVICE_ROLE_KEY - Charger la liste des réseaux (sélecteur dropdown)
   */
  const loadReseaux = useCallback(async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin');
      if (error) throw error;
      setReseaux(data || []);
    } catch {
      toast({
        title: 'Erreur',
        description: 'Impossible de charger les réseaux',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  /**
   * 🔑 SERVICE_ROLE_KEY - Charger les données complètes d'un réseau sélectionné
   */
  const loadReseauData = useCallback(
    async (reseauId: string) => {
      if (!reseauId) return;
      setIsLoading(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {
          body: { reseauId }
        });
        if (error) throw error;
        
        if (!data?.reseau) {
          setFormData({});
          toast({
            title: 'Introuvable',
            description: 'Réseau introuvable',
            variant: 'destructive',
          });
          return;
        }

        setFormData(data.reseau);
        setErrors({});
      } catch {
        toast({
          title: 'Erreur',
          description: 'Impossible de charger les données du réseau',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  /**
   * Validation côté frontend avant sauvegarde
   * ⚠️ Dans le formulaire de gestion → uniquement des validations de forme.
   * (Les champs étaient obligatoires uniquement lors de la création.)
   */
  const validateForm = useCallback(
    (data: Partial<ReseauFormData>): ValidationErrors => {
      const newErrors: ValidationErrors = {};

      if (data.reseau_code_postal && !/^\d{5}$/.test(data.reseau_code_postal)) {
        newErrors.reseau_code_postal =
          'Le code postal doit contenir 5 chiffres';
      }

      if (data.reseau_siret && !/^\d{14}$/.test(data.reseau_siret.replace(/\s/g, ''))) {
        newErrors.reseau_siret = 'Le SIRET doit contenir 14 chiffres';
      }

      return newErrors;
    },
    []
  );

  /**
   * 🔑 SERVICE_ROLE_KEY - Sauvegarder les données d'un réseau
   */
  const saveReseau = useCallback(
    async (dataToSave: Partial<ReseauFormData>) => {
      if (!selectedReseauId) return false;

      const validationErrors = validateForm(dataToSave);
      setErrors(validationErrors);
      if (Object.keys(validationErrors).length > 0) {
        toast({
          title: 'Erreurs de validation',
          description: 'Veuillez corriger les erreurs',
          variant: 'destructive',
        });
        return false;
      }

      setIsSaving(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {
          body: { 
            reseauId: selectedReseauId,
            generalData: dataToSave 
          }
        });
        if (error) throw error;

        toast({
          title: 'Succès',
          description: 'Réseau mis à jour avec succès',
        });
        await loadReseauData(selectedReseauId);
        return true;
      } catch {
        toast({
          title: 'Erreur',
          description: 'Impossible de sauvegarder les modifications',
          variant: 'destructive',
        });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [selectedReseauId, validateForm, toast, loadReseauData]
  );

  /**
   * Mise à jour d'un champ dans l'état local
   */
  const updateFormField = useCallback(
    (field: keyof ReseauFormData | string, value: any) => {
      setFormData((prev) => ({ ...prev, [field]: value }));
      if (errors[field]) {
        setErrors((prev) => {
          const e = { ...prev };
          delete e[field];
          return e;
        });
      }
    },
    [errors]
  );

  /**
   * Sélection d'un réseau dans le dropdown
   */
  const selectReseau = useCallback(
    (reseauId: string) => {
      setSelectedReseauId(reseauId);
      if (reseauId) {
        loadReseauData(reseauId);
      } else {
        setFormData({});
        setErrors({});
      }
    },
    [loadReseauData]
  );

  return {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    validateForm,
    loadReseauData,
  };
}
```

### 3.2 useReseauIntegrations.ts (MODIFIÉ)

**📂 Emplacement :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations.ts`

```typescript
import { useCallback, useState } from 'react';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import type { BrevoFormState, ZohoFormState, OpenAIFormState } from './types';

export function useReseauIntegrations() {
  const { toast } = useToast();

  // ✅ organisation_id séparé
  const [organisationId, setOrganisationId] = useState<string | null>(null);

  // ✅ États UI (formulaire uniquement)
  const [brevo, setBrevo] = useState<BrevoFormState>({});
  const [zoho, setZoho] = useState<ZohoFormState>({});
  const [openai, setOpenAI] = useState<OpenAIFormState>({});

  // ✅ IDs techniques séparés
  const [brevoConnexionId, setBrevoConnexionId] = useState<string | null>(null);
  const [zohoConnexionId, setZohoConnexionId] = useState<string | null>(null);
  const [openaiConnexionId, setOpenaiConnexionId] = useState<string | null>(null);

  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // ================================
  // 🔑 SERVICE_ROLE_KEY - Charger les intégrations d'un réseau
  // ================================
  const loadForReseau = useCallback(async (reseauId: string) => {
    if (!reseauId) return;
    setIsLoading(true);

    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {
        body: { reseauId }
      });
      if (error) throw error;
      
      if (!data?.reseau) {
        // Reset states
        setOrganisationId(null);
        setBrevo({});
        setZoho({});
        setOpenAI({});
        setBrevoConnexionId(null);
        setZohoConnexionId(null);
        setOpenaiConnexionId(null);
        return;
      }
      
      const reseau = data.reseau;
      const integrations = data.integrations;
      
      setOrganisationId(reseau.organisation_id);
      setBrevo(integrations?.brevo || {});
      setZoho(integrations?.zoho || {});
      setOpenAI(integrations?.openai || {});
      setBrevoConnexionId(reseau.reseau_brevo_connexion_id);
      setZohoConnexionId(reseau.reseau_zoho_connexion_id);
      setOpenaiConnexionId(reseau.reseau_openai_connexion_id);
      
    } catch (e: any) {
      console.error('Erreur loadForReseau', e);
      toast({ 
        title: 'Erreur', 
        description: 'Impossible de charger les intégrations', 
        variant: 'destructive' 
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // ================================
  // 🔑 SERVICE_ROLE_KEY - Sauvegarde d'une intégration (🚀 OPTIMISÉ)
  // ================================
  const saveIntegration = useCallback(
    async (reseauId: string, kind: 'brevo' | 'zoho' | 'openai') => {
      if (!reseauId) return false;
      if (!organisationId) {
        toast({ title: 'Erreur', description: 'organisation_id introuvable', variant: 'destructive' });
        return false;
      }
      setIsSaving(true);

      try {
        let state: any;
        switch (kind) {
          case 'brevo':
            state = brevo;
            break;
          case 'zoho':
            state = zoho;
            break;
          case 'openai':
            state = openai;
            break;
        }

        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {
          body: { 
            reseauId,
            integrationKind: kind,
            integrationData: state
          }
        });
        if (error) throw error;

        // 🚀 OPTIMISATION : Utiliser les données retournées directement au lieu de recharger
        if (data?.updatedData?.integrations?.[kind]) {
          const updatedIntegration = data.updatedData.integrations[kind];
          
          switch (kind) {
            case 'brevo':
              setBrevo({
                brevo_api_key: updatedIntegration.brevo_api_key,
                brevo_email_compte: updatedIntegration.brevo_email_compte,
                brevo_nom_compte: updatedIntegration.brevo_nom_compte
              });
              setBrevoConnexionId(updatedIntegration.brevo_connexion_id);
              break;
            case 'zoho':
              setZoho({
                zoho_api_key: updatedIntegration.zoho_api_key,
                zoho_email_compte: updatedIntegration.zoho_email_compte,
                zoho_nom_compte: updatedIntegration.zoho_nom_compte
              });
              setZohoConnexionId(updatedIntegration.zoho_connexion_id);
              break;
            case 'openai':
              setOpenAI({
                openai_api_key: updatedIntegration.openai_api_key,
                openai_email_compte: updatedIntegration.openai_email_compte
              });
              setOpenaiConnexionId(updatedIntegration.openai_connexion_id);
              break;
          }
        }

        toast({ title: 'Succès', description: `Intégration ${kind} mise à jour avec succès` });
        return true;
      } catch (e: any) {
        console.error(`Erreur saveIntegration ${kind}`, e);
        toast({ title: 'Erreur', description: e?.message || "Impossible de sauvegarder l'intégration", variant: 'destructive' });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [organisationId, brevo, zoho, openai, toast]
  );

  return {
    organisationId,
    // États UI
    brevo, setBrevo,
    zoho, setZoho,
    openai, setOpenAI,
    // IDs techniques
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    // Meta
    isLoading,
    isSaving,
    // Actions
    loadForReseau,
    saveIntegration,
  };
}
```

### 3.3 types.ts (INCHANGÉ)

**📂 Emplacement :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/types.ts`

```typescript
// Types pour le hook useReseauFormData
export interface ReseauSelectorItem {
  reseau_id: string;
  reseau_nom: string;
  reseau_statut?: string;
  organisation_id?: string;
}

export interface ReseauFormData {
  reseau_id: string;
  organisation_id: string;
  reseau_nom: string;
  reseau_identite_commerciale?: string;
  reseau_adresse: string;
  reseau_code_postal: string;
  reseau_ville: string;
  reseau_siret: string;
  reseau_statut: string;
  reseau_logo?: string;
  reseau_ressources?: string[];
  reseau_brevo_connexion_id?: string;
  reseau_zoho_connexion_id?: string;
  reseau_openai_connexion_id?: string;
  reseau_telephone: string;
  reseau_email: string;
}

export interface ValidationErrors {
  [key: string]: string;
}

// Types pour le hook useReseauIntegrations
export interface BrevoFormState {
  brevo_api_key?: string;
  brevo_email_compte?: string;
  brevo_nom_compte?: string;
}

export interface ZohoFormState {
  zoho_api_key?: string;
  zoho_email_compte?: string;
  zoho_nom_compte?: string;
}

export interface OpenAIFormState {
  openai_api_key?: string;
  openai_email_compte?: string;
}
```

---

## 4. COMPOSANTS

### 4.1 ReseauSelector.tsx (INCHANGÉ)

**📂 Emplacement :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector.tsx`

```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import type { ReseauSelectorItem } from '../hooks/types';

interface ReseauSelectorProps {
  reseaux: ReseauSelectorItem[];
  selectedReseauId: string;
  onSelect: (reseauId: string) => void;
  isLoading: boolean;
}

export const ReseauSelector: React.FC<ReseauSelectorProps> = ({
  reseaux,
  selectedReseauId,
  onSelect,
  isLoading,
}) => {
  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="text-xl font-semibold">Sélection du Réseau</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          <Select
            value={selectedReseauId}
            onValueChange={onSelect}
            disabled={isLoading}
          >
            <SelectTrigger className="w-full">
              <SelectValue 
                placeholder={
                  isLoading ? "Chargement des réseaux..." : 
                  "Sélectionner un réseau"
                } 
              />
            </SelectTrigger>
            <SelectContent>
              {reseaux?.map((reseau) => (
                <SelectItem key={reseau.reseau_id} value={reseau.reseau_id}>
                  {reseau.reseau_nom}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardContent>
    </Card>
  );
};

export default ReseauSelector;
```

---

## 5. EDGE FUNCTIONS SERVICE_ROLE_KEY

### 5.1 gestion-reseau-admin

**📂 Emplacement :** `supabase/functions/gestion-reseau-admin/index.ts`

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false }
})

Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Vérification admin_presenca via JWT
    const authHeader = req.headers.get('authorization')
    if (!authHeader) throw new Error('Non autorisé')
    
    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
    if (authError || !user) throw new Error('Token invalide')
    
    // Vérifier rôle admin_presenca
    const { data: userRole, error: roleError } = await supabaseAdmin
      .from('users')
      .select('users_role_systeme')
      .eq('users_auth_id', user.id)
      .single()
      
    if (roleError || userRole?.users_role_systeme !== 'admin_presenca') {
      throw new Error('Accès refusé - admin_presenca requis')
    }

    // Récupérer tous les réseaux (BYPASS RLS avec SERVICE_ROLE_KEY)
    const { data: reseaux, error } = await supabaseAdmin
      .from('reseau')
      .select('reseau_id, reseau_nom, reseau_statut, organisation_id')
      .order('reseau_nom')

    if (error) throw error

    console.log(`[gestion-reseau-admin] Chargement réussi de ${reseaux?.length || 0} réseaux pour admin ${user.email}`)

    return new Response(
      JSON.stringify(reseaux || []),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('[gestion-reseau-admin] Erreur:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```

### 5.2 gestion-reseau-admin-donnees (🚀 OPTIMISÉ JOIN SQL)

**📂 Emplacement :** `supabase/functions/gestion-reseau-admin-donnees/index.ts`

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false }
})

Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { reseauId } = await req.json()
    if (!reseauId) throw new Error('reseauId requis')

    // Vérification admin_presenca via JWT
    const authHeader = req.headers.get('authorization')
    if (!authHeader) throw new Error('Non autorisé')
    
    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
    if (authError || !user) throw new Error('Token invalide')
    
    // Vérifier rôle admin_presenca
    const { data: userRole, error: roleError } = await supabaseAdmin
      .from('users')
      .select('users_role_systeme')
      .eq('users_auth_id', user.id)
      .single()
      
    if (roleError || userRole?.users_role_systeme !== 'admin_presenca') {
      throw new Error('Accès refusé - admin_presenca requis')
    }

    // 🚀 OPTIMISATION : 1 seule requête avec JOIN au lieu de 4 requêtes séparées
    const { data: result, error: joinError } = await supabaseAdmin
      .from('reseau')
      .select(`
        reseau_id, organisation_id, reseau_nom, reseau_identite_commerciale,
        reseau_adresse, reseau_code_postal, reseau_ville, reseau_siret,
        reseau_statut, reseau_logo, reseau_ressources, reseau_telephone,
        reseau_email, reseau_brevo_connexion_id, reseau_zoho_connexion_id,
        reseau_openai_connexion_id,
        brevo_connexion:reseau_brevo_connexion_id(
          brevo_api_key, brevo_email_compte, brevo_nom_compte
        ),
        zoho_connexion:reseau_zoho_connexion_id(
          zoho_api_key, zoho_email_compte, zoho_nom_compte
        ),
        openai_connexion:reseau_openai_connexion_id(
          openai_api_key, openai_email_compte
        )
      `)
      .eq('reseau_id', reseauId)
      .single()

    if (joinError) throw joinError

    // Restructurer les données pour compatibilité avec l'interface existante
    const reseau = {
      reseau_id: result.reseau_id,
      organisation_id: result.organisation_id,
      reseau_nom: result.reseau_nom,
      reseau_identite_commerciale: result.reseau_identite_commerciale,
      reseau_adresse: result.reseau_adresse,
      reseau_code_postal: result.reseau_code_postal,
      reseau_ville: result.reseau_ville,
      reseau_siret: result.reseau_siret,
      reseau_statut: result.reseau_statut,
      reseau_logo: result.reseau_logo,
      reseau_ressources: result.reseau_ressources,
      reseau_telephone: result.reseau_telephone,
      reseau_email: result.reseau_email,
      reseau_brevo_connexion_id: result.reseau_brevo_connexion_id,
      reseau_zoho_connexion_id: result.reseau_zoho_connexion_id,
      reseau_openai_connexion_id: result.reseau_openai_connexion_id
    }

    const integrations = {
      brevo: result.brevo_connexion || null,
      zoho: result.zoho_connexion || null,
      openai: result.openai_connexion || null
    }

    console.log(`[gestion-reseau-admin-donnees] ⚡ Chargement optimisé (JOIN) réussi pour réseau ${reseauId}`)

    return new Response(
      JSON.stringify({ reseau, integrations }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('[gestion-reseau-admin-donnees] Erreur:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```

### 5.3 gestion-reseau-admin-update (🚀 OPTIMISÉ RETOUR COMPLET)

**📂 Emplacement :** `supabase/functions/gestion-reseau-admin-update/index.ts`

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false }
})

Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    const { reseauId, generalData, integrationKind, integrationData } = await req.json()
    if (!reseauId) throw new Error('reseauId requis')

    // Vérification admin_presenca via JWT
    const authHeader = req.headers.get('authorization')
    if (!authHeader) throw new Error('Non autorisé')
    
    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
    if (authError || !user) throw new Error('Token invalide')
    
    // Vérifier rôle admin_presenca
    const { data: userRole, error: roleError } = await supabaseAdmin
      .from('users')
      .select('users_role_systeme')
      .eq('users_auth_id', user.id)
      .single()
      
    if (roleError || userRole?.users_role_systeme !== 'admin_presenca') {
      throw new Error('Accès refusé - admin_presenca requis')
    }

    let updatedReseauData = null
    let updatedIntegrationData = null

    // Mise à jour des données générales du réseau
    if (generalData) {
      const { data: updatedReseau, error: updateError } = await supabaseAdmin
        .from('reseau')
        .update({
          ...generalData,
          reseau_updated_at: new Date().toISOString(),
          reseau_updated_by: user.id
        })
        .eq('reseau_id', reseauId)
        .select('*, reseau_created_at, reseau_created_by, reseau_updated_at, reseau_updated_by')
        .single()

      if (updateError) throw updateError
      updatedReseauData = updatedReseau
      console.log(`[gestion-reseau-admin-update] Mise à jour données générales réseau ${reseauId}`)
    }

    // Mise à jour des intégrations
    if (integrationKind && integrationData) {
      // Récupérer les infos du réseau pour organisation_id
      const { data: reseau, error: reseauError } = await supabaseAdmin
        .from('reseau')
        .select('organisation_id, reseau_brevo_connexion_id, reseau_zoho_connexion_id, reseau_openai_connexion_id')
        .eq('reseau_id', reseauId)
        .single()

      if (reseauError) throw reseauError

      let tableName: string, connexionIdField: string, reseauFkField: string, connexionId: string | null

      switch (integrationKind) {
        case 'brevo':
          tableName = 'brevo_connexion'
          connexionIdField = 'brevo_connexion_id'
          reseauFkField = 'reseau_brevo_connexion_id'
          connexionId = reseau.reseau_brevo_connexion_id
          break
        case 'zoho':
          tableName = 'zoho_connexion'
          connexionIdField = 'zoho_connexion_id'
          reseauFkField = 'reseau_zoho_connexion_id'
          connexionId = reseau.reseau_zoho_connexion_id
          break
        case 'openai':
          tableName = 'openai_connexion'
          connexionIdField = 'openai_connexion_id'
          reseauFkField = 'reseau_openai_connexion_id'
          connexionId = reseau.reseau_openai_connexion_id
          break
        default:
          throw new Error(`Type d'intégration non supporté: ${integrationKind}`)
      }

      if (connexionId) {
        // Update existante - 🚀 RETOUR COMPLET après update
        const { data: updatedInteg, error: updateIntegError } = await supabaseAdmin
          .from(tableName)
          .update({
            ...integrationData,
            [`${integrationKind}_updated_at`]: new Date().toISOString(),
            [`${integrationKind}_updated_by`]: user.id
          })
          .eq(connexionIdField, connexionId)
          .select(`*, ${integrationKind}_created_at, ${integrationKind}_created_by, ${integrationKind}_updated_at, ${integrationKind}_updated_by`)
          .single()

        if (updateIntegError) throw updateIntegError
        updatedIntegrationData = updatedInteg
        console.log(`[gestion-reseau-admin-update] Mise à jour intégration ${integrationKind} existante`)
      } else {
        // Insert nouvelle - 🚀 RETOUR COMPLET après insert
        const payload = {
          ...integrationData,
          organisation_id: reseau.organisation_id,
          reseau_id: reseauId,
          [`${integrationKind}_created_at`]: new Date().toISOString(),
          [`${integrationKind}_created_by`]: user.id,
          [`${integrationKind}_updated_at`]: new Date().toISOString(),
          [`${integrationKind}_updated_by`]: user.id
        }
        
        const { data: insertedInteg, error: insertIntegError } = await supabaseAdmin
          .from(tableName)
          .insert(payload)
          .select(`*, ${integrationKind}_created_at, ${integrationKind}_created_by, ${integrationKind}_updated_at, ${integrationKind}_updated_by`)
          .single()

        if (insertIntegError) throw insertIntegError
        
        const newConnexionId = insertedInteg[connexionIdField]
        
        // Mettre à jour la FK dans reseau et récupérer les données mises à jour
        const { data: updatedReseauWithFK, error: updateFkError } = await supabaseAdmin
          .from('reseau')
          .update({ 
            [reseauFkField]: newConnexionId,
            reseau_updated_at: new Date().toISOString(),
            reseau_updated_by: user.id
          })
          .eq('reseau_id', reseauId)
          .select('*')
          .single()

        if (updateFkError) throw updateFkError
        
        updatedIntegrationData = insertedInteg
        updatedReseauData = updatedReseauWithFK
        console.log(`[gestion-reseau-admin-update] Création nouvelle intégration ${integrationKind}`)
      }
    }

    // 🚀 OPTIMISATION : Retour des données mises à jour pour éviter un nouveau loadForReseau
    const response = {
      success: true,
      updatedData: {
        ...(updatedReseauData && { reseau: updatedReseauData }),
        ...(updatedIntegrationData && { 
          integrations: {
            [integrationKind]: updatedIntegrationData
          }
        })
      }
    }

    console.log(`[gestion-reseau-admin-update] ⚡ Retour optimisé des données mises à jour`)

    return new Response(
      JSON.stringify(response),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('[gestion-reseau-admin-update] Erreur:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```

### 5.4 gestion-reseau-admin-fichiers

**📂 Emplacement :** `supabase/functions/gestion-reseau-admin-fichiers/index.ts`

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: { autoRefreshToken: false, persistSession: false }
})

Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Vérification admin_presenca via JWT
    const authHeader = req.headers.get('authorization')
    if (!authHeader) throw new Error('Non autorisé')
    
    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
    if (authError || !user) throw new Error('Token invalide')
    
    // Vérifier rôle admin_presenca
    const { data: userRole, error: roleError } = await supabaseAdmin
      .from('users')
      .select('users_role_systeme')
      .eq('users_auth_id', user.id)
      .single()
      
    if (roleError || userRole?.users_role_systeme !== 'admin_presenca') {
      throw new Error('Accès refusé - admin_presenca requis')
    }

    // Déterminer le type d'opération
    if (req.method === 'POST') {
      // ✅ UPLOAD DE FICHIER
      const formData = await req.formData()
      const file = formData.get('file') as File
      const type = formData.get('type') as string // 'logo' | 'document'
      const reseauId = formData.get('reseauId') as string

      if (!file || !type || !reseauId) {
        throw new Error('Paramètres manquants: file, type, reseauId requis')
      }

      // Validation du type de fichier
      const maxSize = 10 * 1024 * 1024 // 10MB
      if (file.size > maxSize) {
        throw new Error('Fichier trop volumineux (max 10MB)')
      }

      // 🔧 CORRECTION 1 : Récupérer organisation_id pour respecter le design
      const { data: reseau, error: reseauError } = await supabaseAdmin
        .from('reseau')
        .select('organisation_id')
        .eq('reseau_id', reseauId)
        .single()
      
      if (reseauError) throw new Error('Réseau introuvable')
      
      // Générer un nom de fichier unique selon le design: organisation-{uuid}/1-logos/...
      const timestamp = new Date().getTime()
      const extension = file.name.split('.').pop()
      const fileName = `${type}_${reseauId}_${timestamp}.${extension}`
      const folder = type === 'logo' ? '1-logos' : '2-documents-institutionnels'
      const filePath = `organisation-${reseau.organisation_id}/${folder}/${fileName}`

      // Upload vers Supabase Storage (BYPASS RLS avec SERVICE_ROLE_KEY)
      const { data: uploadData, error: uploadError } = await supabaseAdmin.storage
        .from('bucket-table-reseau')
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false
        })

      if (uploadError) throw uploadError

      console.log(`[gestion-reseau-admin-fichiers] Upload réussi: ${filePath} pour réseau ${reseauId}`)

      return new Response(
        JSON.stringify({ 
          success: true, 
          filePath: uploadData.path,
          fileName: fileName
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )

    } else if (req.method === 'DELETE') {
      // 🔧 CORRECTION 3 : SUPPRESSION DE FICHIER CENTRALISÉE
      const body = await req.json()
      const { filePath } = body

      if (!filePath) {
        throw new Error('Paramètre filePath requis pour la suppression')
      }

      // Suppression du fichier dans Supabase Storage
      const { error: deleteError } = await supabaseAdmin.storage
        .from('bucket-table-reseau')
        .remove([filePath])

      if (deleteError) throw deleteError

      console.log(`[gestion-reseau-admin-fichiers] Suppression réussie: ${filePath}`)

      return new Response(
        JSON.stringify({ 
          success: true,
          message: 'Fichier supprimé avec succès'
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )

    } else {
      throw new Error('Méthode non supportée')
    }

  } catch (error) {
    console.error('[gestion-reseau-admin-fichiers] Erreur:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```

---

## 6. SQL DE MIGRATION

**🔧 Aucune migration SQL requise** - La stratégie SERVICE_ROLE_KEY utilise les tables existantes et les Edge Functions contournent les politiques RLS sans modifier le schéma.

**✅ Points de validation :**
- Tables `reseau`, `brevo_connexion`, `zoho_connexion`, `openai_connexion` : **INCHANGÉES**
- Fonctions SQL existantes : **PRÉSERVÉES**
- Triggers d'audit : **FONCTIONNELS**
- Politiques RLS : **MAINTENUES** (contournées par SERVICE_ROLE_KEY)

---

## 7. PAGE FORMULAIRE

### 7.1 FormReseauGestion.tsx (MODIFIÉ)

**📂 Emplacement :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/3.FormReseauGestion.tsx`

**🔧 Modifications nécessaires :**
- Ligne 97 : `upload-reseau-files` → `gestion-reseau-admin-fichiers`
- Lignes 106, 125, 144, 159 : `update-reseau` → `gestion-reseau-admin-update`
- Correction effectuée : onglet fichiers -> 2 cartes

```typescript
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../../3-Utilitaires/tabs";
import { Upload, Download, Trash2, Eye } from 'lucide-react';
import GraphBoutonModifier from '../../5-Graphisme/1.GraphFormulaires/5.GraphBoutonModifier';
import { ReseauSelector } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector';
import { useReseauFormData } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData';
import { useReseauIntegrations } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

interface Props {
  onBack?: () => void;
}

const FormReseauGestion: React.FC<Props> = ({ onBack }) => {
  const { toast } = useToast();

  const {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    loadReseauData,
  } = useReseauFormData();

  const {
    brevo, setBrevo,
    zoho, setZoho,
    openai, setOpenAI,
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    isLoading: integLoading,
    isSaving: integSaving,
    loadForReseau,
    saveIntegration,
  } = useReseauIntegrations();

  const [isEditingGeneral, setIsEditingGeneral] = useState(false);
  const [isEditingBrevo, setIsEditingBrevo] = useState(false);
  const [isEditingZoho, setIsEditingZoho] = useState(false);
  const [isEditingOpenAI, setIsEditingOpenAI] = useState(false);
  const [isEditingLogo, setIsEditingLogo] = useState(false);
  const [isEditingDocuments, setIsEditingDocuments] = useState(false);

  const logoInputRef = useRef<HTMLInputElement | null>(null);
  const docsInputRef = useRef<HTMLInputElement | null>(null);
  const [selectedLogo, setSelectedLogo] = useState<File | null>(null);
  const [selectedDocs, setSelectedDocs] = useState<File[]>([]);

  useEffect(() => { loadReseaux(); }, [loadReseaux]);
  useEffect(() => { if (selectedReseauId) loadForReseau(selectedReseauId); }, [selectedReseauId, loadForReseau]);

  const handleSaveGeneral = async () => {
    if (!selectedReseauId) return;
    const success = await saveReseau({
      reseau_nom: formData.reseau_nom,
      reseau_identite_commerciale: formData.reseau_identite_commerciale,
      reseau_adresse: formData.reseau_adresse,
      reseau_code_postal: formData.reseau_code_postal,
      reseau_ville: formData.reseau_ville,
      reseau_siret: formData.reseau_siret,
      reseau_telephone: formData.reseau_telephone,
      reseau_email: formData.reseau_email,
    });
    if (success) setIsEditingGeneral(false);
  };

  const handleSaveBrevo = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'brevo'); if (ok) setIsEditingBrevo(false); };
  const handleSaveZoho = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'zoho'); if (ok) setIsEditingZoho(false); };
  const handleSaveOpenAI = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'openai'); if (ok) setIsEditingOpenAI(false); };

  const reloadAll = async () => {
    if (selectedReseauId) {
      await loadReseauData(selectedReseauId);
      await loadForReseau(selectedReseauId);
      setSelectedLogo(null);
      setSelectedDocs([]);
    }
  };

  const uploadFile = async (type: 'logo' | 'document', file: File, reseauId: string) => {
    const fd = new FormData();
    fd.append('file', file);
    fd.append('type', type);
    fd.append('reseauId', reseauId);
    const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', { body: fd });
    if (error) throw error;
    return (data as any)?.filePath as string;
  };

  const handleSaveLogo = async () => {
    if (!selectedReseauId || !selectedLogo) { setIsEditingLogo(false); return; }
    try {
      const path = await uploadFile('logo', selectedLogo, selectedReseauId);
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_logo: path } },
      });
      toast({ title: 'Succès', description: 'Logo mis à jour' });
      await reloadAll();
      setIsEditingLogo(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader le logo", variant: 'destructive' });
    }
  };

  const handleSaveDocuments = async () => {
    if (!selectedReseauId) { setIsEditingDocuments(false); return; }
    try {
      const paths: string[] = [];
      for (const f of selectedDocs) {
        paths.push(await uploadFile('document', f, selectedReseauId));
      }
      const next = Array.isArray(formData.reseau_ressources) ? [...formData.reseau_ressources, ...paths] : paths;
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_ressources: next } },
      });
      toast({ title: 'Succès', description: 'Documents mis à jour' });
      await reloadAll();
      setIsEditingDocuments(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader les documents", variant: 'destructive' });
    }
  };

  const removeStoragePath = async (path: string) => {
    const { error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', {
      body: { filePath: path },
      method: 'DELETE'
    });
    if (error) throw error;
  };

  const handleDeleteLogo = async () => {
    if (!selectedReseauId || !formData.reseau_logo) return;
    try {
      await removeStoragePath(formData.reseau_logo);
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_logo: null } },
      });
      toast({ title: 'Succès', description: 'Logo supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression logo impossible', variant: 'destructive' });
    }
  };

  const handleDeleteDocument = async (docPath: string) => {
    if (!selectedReseauId) return;
    try {
      await removeStoragePath(docPath);
      const remaining = (formData.reseau_ressources || []).filter(p => p !== docPath);
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_ressources: remaining } },
      });
      toast({ title: 'Succès', description: 'Document supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression document impossible', variant: 'destructive' });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); };

  return (
    <div className="space-y-6">
      <ReseauSelector
        reseaux={reseaux}
        selectedReseauId={selectedReseauId}
        onSelect={selectReseau}
        isLoading={isLoading}
      />

      <Tabs defaultValue="general" className="w-full">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="general" className="text-base font-semibold">Général</TabsTrigger>
          <TabsTrigger value="integrations" className="text-base font-semibold">Intégrations</TabsTrigger>
          <TabsTrigger value="fichiers" className="text-base font-semibold">Fichiers</TabsTrigger>
        </TabsList>

        <form onSubmit={handleSubmit}>
          {/* ✅ Informations Générales */}
          <TabsContent value="general" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">Informations Générales</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveGeneral}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingGeneral}
                    isLoading={isSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_nom">Nom du Réseau</Label>
                      <Input
                        id="reseau_nom"
                        value={formData.reseau_nom || ''}
                        onChange={e => updateFormField('reseau_nom', e.target.value)}
                        placeholder="Nom du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_identite_commerciale">Identité Commerciale du Réseau</Label>
                      <Input
                        id="reseau_identite_commerciale"
                        value={formData.reseau_identite_commerciale || ''}
                        onChange={e => updateFormField('reseau_identite_commerciale', e.target.value)}
                        placeholder="Optionnel. Si Nom Commercial différent"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_adresse">Adresse</Label>
                      <Input
                        id="reseau_adresse"
                        value={formData.reseau_adresse || ''}
                        onChange={e => updateFormField('reseau_adresse', e.target.value)}
                        placeholder="Adresse. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_code_postal">Code Postal</Label>
                      <Input
                        id="reseau_code_postal"
                        value={formData.reseau_code_postal || ''}
                        onChange={e => updateFormField('reseau_code_postal', e.target.value)}
                        placeholder="Code Postal. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_ville">Ville</Label>
                      <Input
                        id="reseau_ville"
                        value={formData.reseau_ville || ''}
                        onChange={e => updateFormField('reseau_ville', e.target.value)}
                        placeholder="Ville. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_siret">Siret</Label>
                      <Input
                        id="reseau_siret"
                        value={formData.reseau_siret || ''}
                        onChange={e => updateFormField('reseau_siret', e.target.value)}
                        placeholder="N° Siret du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_telephone">Téléphone Direction</Label>
                      <Input
                        id="reseau_telephone"
                        value={formData.reseau_telephone || ''}
                        onChange={e => updateFormField('reseau_telephone', e.target.value)}
                        placeholder="Tél. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_email">Email Direction</Label>
                      <Input
                        id="reseau_email"
                        type="email"
                        value={formData.reseau_email || ''}
                        onChange={e => updateFormField('reseau_email', e.target.value)}
                        placeholder="Email. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Intégrations */}
          <TabsContent value="integrations" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Brevo</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveBrevo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingBrevo}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="brevo_api_key">Clé API Brevo</Label>
                    <Input
                      id="brevo_api_key"
                      type="password"
                      placeholder="Renseigner. N° Clé API"
                      value={brevo.brevo_api_key || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_api_key: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_email_compte">Email Compte Brevo</Label>
                    <Input
                      id="brevo_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Brevo"
                      value={brevo.brevo_email_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_email_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_nom_compte">Nom Compte Brevo</Label>
                    <Input
                      id="brevo_nom_compte"
                      placeholder="Renseigner. Nom compte Brevo"
                      value={brevo.brevo_nom_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_nom_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Zoho</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveZoho}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingZoho}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="zoho_api_key">Clé API Zoho</Label>
                    <Input
                      id="zoho_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API Zoho"
                      value={zoho.zoho_api_key || ''}
                      onChange={e => setZoho({ ...zoho, zoho_api_key: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_email_compte">Email Compte Zoho</Label>
                    <Input
                      id="zoho_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Zoho"
                      value={zoho.zoho_email_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_email_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_nom_compte">Nom Compte Zoho</Label>
                    <Input
                      id="zoho_nom_compte"
                      placeholder="Renseigner. Nom compte Zoho"
                      value={zoho.zoho_nom_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_nom_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration OpenAI</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveOpenAI}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingOpenAI}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="openai_api_key">Clé API OpenAI</Label>
                    <Input
                      id="openai_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API OpenAI"
                      value={openai.openai_api_key || ''}
                      onChange={e => setOpenAI({ ...openai, openai_api_key: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                  <div>
                    <Label htmlFor="openai_email_compte">Email Compte OpenAI</Label>
                    <Input
                      id="openai_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte OpenAI"
                      value={openai.openai_email_compte || ''}
                      onChange={e => setOpenAI({ ...openai, openai_email_compte: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Fichiers - STRUCTURE 2 CARTES SÉPARÉES */}
          <TabsContent value="fichiers" className="space-y-6">
            {/* 🎨 CARTE 1 : Logo du Réseau */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">
                    Logo du Réseau
                  </CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveLogo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingLogo}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="reseau_logo_upload">Télécharger le Logo du Réseau</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingLogo && logoInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Upload className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner le logo</p>
                          <p className="text-xs text-muted-foreground">PNG, JPG, SVG - Max 2MB</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={logoInputRef}
                      id="reseau_logo_upload"
                      type="file"
                      accept="image/*"
                      hidden
                      disabled={!isEditingLogo}
                      onChange={e => setSelectedLogo(e.target.files?.[0] || null)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Logo actuel</Label>
                    <div className="border rounded-lg p-4 bg-muted/20">
                      {formData.reseau_logo ? (
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <div className="w-16 h-16 border rounded bg-white flex items-center justify-center">
                              <Upload className="h-5 w-5 text-muted-foreground" />
                            </div>
                            <div>
                              <p className="font-medium break-all">{formData.reseau_logo}</p>
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Button
                              type="button"
                              variant="destructive"
                              size="sm"
                              onClick={handleDeleteLogo}
                              disabled={!isEditingLogo}
                            >
                              Supprimer
                            </Button>
                          </div>
                        </div>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun logo uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* 📄 CARTE 2 : Documents Institutionnels */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">
                    Documents Institutionnels
                  </CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveDocuments}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingDocuments}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label>Télécharger les documents</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingDocuments && docsInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Download className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner les documents</p>
                          <p className="text-xs text-muted-foreground">PDF, DOC, DOCX - Max 10MB par fichier</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={docsInputRef}
                      type="file"
                      multiple
                      accept=".pdf,.doc,.docx,.xls,.xlsx"
                      hidden
                      disabled={!isEditingDocuments}
                      onChange={e => setSelectedDocs(e.target.files ? Array.from(e.target.files) : [])}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Supprimer un fichier existant</Label>
                    <div className="border rounded-lg p-4 bg-muted/20 space-y-3">
                      {formData.reseau_ressources && formData.reseau_ressources.length > 0 ? (
                        <>
                          {formData.reseau_ressources.map((p) => (
                            <div key={p} className="flex items-center justify-between p-3 border rounded bg-white">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-blue-100 rounded flex items-center justify-center">
                                  <Download className="h-4 w-4 text-blue-600" />
                                </div>
                                <div className="max-w-[60ch]">
                                  <p className="font-medium break-all">{p}</p>
                                </div>
                              </div>
                              <div className="flex gap-2">
                                <Button
                                  type="button"
                                  variant="outline"
                                  size="sm"
                                  onClick={async () => {
                                    const { data } = await supabase.storage
                                      .from('bucket-table-reseau')
                                      .createSignedUrl(p, 60);
                                    if (data?.signedUrl) window.open(data.signedUrl, '_blank');
                                  }}
                                >
                                  <Eye className="h-4 w-4 mr-1" />
                                  Voir
                                </Button>
                                <Button
                                  type="button"
                                  variant="destructive"
                                  size="sm"
                                  onClick={() => handleDeleteDocument(p)}
                                  disabled={!isEditingDocuments}
                                >
                                  <Trash2 className="h-4 w-4 mr-1" />
                                  Supprimer
                                </Button>
                              </div>
                            </div>
                          ))}
                        </>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun document uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </form>
      </Tabs>

      {onBack && (
        <div className="pt-6">
          <Button type="button" variant="outline" onClick={onBack}>
            ← Retour
          </Button>
        </div>
      )}
    </div>
  );
};

export default FormReseauGestion;

```

---

## 8. FICHIERS À SUPPRIMER

**🗑️ Aucun fichier à supprimer** - La stratégie SERVICE_ROLE_KEY est additive et préserve l'existant.

**✅ Fichiers maintenus :**
- Tous les hooks existants (mis à jour)
- Tous les composants existants (inchangés ou légèrement modifiés)
- Fichier CORS existant (réutilisé)
- Configuration Supabase existante (préservée)

---

## 📊 RÉCAPITULATIF FINAL

### ✅ AVANTAGES DE CETTE STRATÉGIE

1. **Sécurité renforcée** : Vérification admin_presenca systématique + SERVICE_ROLE_KEY contrôlé
2. **Performance optimale** : Bypass RLS = rapidité d'exécution
3. **Maintenance facilitée** : Pattern répétable et documenté
4. **Compatibilité totale** : Respect des tables, triggers et fonctions existants
5. **Évolutivité** : Extensible aux autres entités (agences, etc.)

### 🎯 RÉSULTAT ATTENDU

Le formulaire de gestion réseau sera **PLEINEMENT FONCTIONNEL** pour l'administrateur admin_presenca avec :
- ✅ Sélecteur de réseau opérationnel
- ✅ Chargement des données instantané
- ✅ Modification tous champs autorisée
- ✅ Sauvegarde intégrations complète
- ✅ Upload/gestion fichiers sécurisé

Cette stratégie garantit un système robuste, sécurisé et performant, réutilisant les bonnes pratiques éprouvées du formulaire de création.

---

## 🔧 RÉCAPITULATIF DES CORRECTIONS APPLIQUÉES

### ✅ **Correction 1 : Architecture de stockage** 
- **Problème** : Le code utilisait `reseau-{reseauId}/...` au lieu de `organisation-{uuid}/1-logos/...`
- **Solution** : Récupération de `organisation_id` et construction des paths selon le design initial
- **Impact** : Respect du design multi-tenant basé sur l'organisation

### ✅ **Correction 2 : Synchronisation complète** 
- **Problème** : Les champs auto-gérés (`updated_at`, `updated_by`) n'étaient pas retournés
- **Solution** : Inclusion explicite dans tous les `SELECT` après `UPDATE`/`INSERT`
- **Impact** : Frontend parfaitement synchronisé avec la DB

### ✅ **Correction 3 : Suppression centralisée** 
- **Problème** : Suppression directe via client Supabase contournant la sécurité
- **Solution** : Extension de l'Edge Function pour supporter `DELETE` avec logs/audit
- **Impact** : Cohérence architecturale et traçabilité complète

Ces corrections garantissent la **cohérence avec le design initial**, la **synchronisation parfaite** et la **sécurité** de toutes les opérations.
