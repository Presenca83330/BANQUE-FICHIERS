# PROPOSITIONS DE CORRECTIONS - FORMULAIRE GESTION R√âSEAU
**Date** : 2025-10-02  
**Corrections** : 3 bugs critiques identifi√©s dans `.Step02-AuditdesBugsStap01.md`

---

## üìã BUGS CORRIG√âS

1. ‚õî **`assertServiceRoleAuth()` supprim√©** - Bloquait tous les appels (401)
2. ‚úÖ **Pattern `data.data` respect√©** - Structure `{success, data, message}`
3. ‚úÖ **`new Response()` standard** - Suppression helper `jsonResponse()` custom

---

## N1. `supabase/functions/gestion-reseau-admin/index.ts`

**Corrections appliqu√©es** :
- ‚ùå Suppression de `assertServiceRoleAuth()` (BUG #1)
- ‚ùå Suppression de `assertAdminIfProvided()` (BUG #1)
- ‚ùå Suppression de `jsonResponse()` helper (BUG #3)
- ‚úÖ Utilisation de `new Response()` standard (BUG #3)
- ‚úÖ Pattern `{success, data, message}` respect√© (BUG #2)

```typescript
// Liste les r√©seaux pour l'espace de gestion.
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const t0 = performance.now();

    // Projection MINIMALE pour le s√©lecteur : reseau_nom (1er), reseau_id
    const { data, error } = await supabase
      .from("reseau")
      .select("reseau_nom, reseau_id")
      .order("reseau_nom", { ascending: true });

    const durationMs = Math.round(performance.now() - t0);

    if (error) {
      logStructured("reseau_list_error", { requestId, error: error.message, duration_ms: durationMs });
      return new Response(
        JSON.stringify({
          success: false,
          error: "db_error_reseau_list",
          details: error.message,
          requestId
        }),
        { 
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    // Forcer l'ordre des propri√©t√©s (reseau_nom en 1er) dans la r√©ponse
    const dataMinimal = (data ?? []).map((r: any) => ({
      reseau_nom: r.reseau_nom,
      reseau_id: r.reseau_id,
    }));

    logStructured("reseau_list_ok", {
      requestId,
      result_count: dataMinimal.length,
      duration_ms: durationMs,
    });

    // ‚úÖ PATTERN DATA.DATA RESPECT√â
    return new Response(
      JSON.stringify({
        success: true,
        data: dataMinimal,  // ‚Üê Donn√©es dans "data"
        message: `${dataMinimal.length} r√©seau(x) r√©cup√©r√©(s)`,
        requestId
      }),
      { 
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );

  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return new Response(
      JSON.stringify({
        success: false,
        error: "internal_error",
        requestId
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});
```

---

## N2. `supabase/functions/gestion-reseau-admin-donnees/index.ts`

**Corrections appliqu√©es** :
- ‚ùå Suppression de `assertServiceRoleAuth()` (BUG #1)
- ‚ùå Suppression de `assertAdminIfProvided()` (BUG #1)
- ‚ùå Suppression de `jsonResponse()` helper (BUG #3)
- ‚úÖ Utilisation de `new Response()` standard (BUG #3)
- ‚úÖ Pattern `{success, data: {reseau, integrations}, message}` respect√© (BUG #2)

```typescript
// D√©tail d'un r√©seau + int√©grations (Brevo, Zoho, OpenAI) pour le formulaire de gestion.
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Projections ------------------------------------------------------------
const RESEAU_PROJECTION = [
  "reseau_id",
  "organisation_id",
  "reseau_nom",
  "reseau_identite_commerciale",
  "reseau_adresse",
  "reseau_code_postal",
  "reseau_ville",
  "reseau_siret",
  "reseau_telephone",
  "reseau_email",
  "reseau_logo",
  "reseau_ressources",
  "reseau_brevo_connexion_id",
  "reseau_zoho_connexion_id",
  "reseau_openai_connexion_id",
].join(",");

const INTEGRATION_PROJECTION = "*";

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    let reseauId: string | null = null;

    // R√©cup√©ration reseau_id depuis query string ou body
    const url = new URL(req.url);
    const qsReseau = url.searchParams.get("reseau_id");
    if (qsReseau) reseauId = qsReseau;

    if (req.method === "POST") {
      try {
        const body = await req.json().catch(() => ({}));
        if (!reseauId && body && typeof body.reseau_id === "string") {
          reseauId = body.reseau_id;
        }
      } catch {
        // ignore malformed JSON
      }
    }

    if (!reseauId) {
      logStructured("missing_reseau_id", { requestId });
      return new Response(
        JSON.stringify({
          success: false,
          error: "bad_request_missing_reseau_id",
          requestId
        }),
        { 
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    const t0 = performance.now();

    // R√©cup√©ration r√©seau
    const { data: reseau, error: reseauErr } = await supabase
      .from("reseau")
      .select(RESEAU_PROJECTION)
      .eq("reseau_id", reseauId)
      .maybeSingle();

    if (reseauErr) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_fetch_error", {
        requestId,
        reseau_id: reseauId,
        error: reseauErr.message,
        duration_ms: durationMs,
      });
      return new Response(
        JSON.stringify({
          success: false,
          error: "db_error_reseau_fetch",
          details: reseauErr.message,
          requestId
        }),
        { 
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    if (!reseau) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_not_found", { requestId, reseau_id: reseauId, duration_ms: durationMs });
      return new Response(
        JSON.stringify({
          success: false,
          error: "not_found_reseau",
          requestId,
          reseau_id: reseauId
        }),
        { 
          status: 404,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    // R√©cup√©ration int√©grations en parall√®le
    const brevoId = reseau.reseau_brevo_connexion_id as string | null;
    const zohoId = reseau.reseau_zoho_connexion_id as string | null;
    const openaiId = reseau.reseau_openai_connexion_id as string | null;

    const promises: Promise<any>[] = [];
    const results: { brevo: any | null; zoho: any | null; openai: any | null } = {
      brevo: null,
      zoho: null,
      openai: null,
    };

    if (brevoId) {
      promises.push(
        supabase
          .from("brevo_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("brevo_connexion_id", brevoId)
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`brevo_fetch_error:${error.message}`);
            results.brevo = data ?? null;
          }),
      );
    }
    if (zohoId) {
      promises.push(
        supabase
          .from("zoho_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("zoho_connexion_id", zohoId)
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`zoho_fetch_error:${error.message}`);
            results.zoho = data ?? null;
          }),
      );
    }
    if (openaiId) {
      promises.push(
        supabase
          .from("openai_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("openai_connexion_id", openaiId)
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`openai_fetch_error:${error.message}`);
            results.openai = data ?? null;
          }),
      );
    }

    let integrationsError: string | null = null;
    try {
      if (promises.length > 0) {
        await Promise.all(promises);
      }
    } catch (e) {
      integrationsError = e instanceof Error ? e.message : String(e);
    }

    const durationMs = Math.round(performance.now() - t0);

    if (integrationsError) {
      logStructured("integrations_fetch_partial_error", {
        requestId,
        reseau_id: reseauId,
        error: integrationsError,
        found: {
          brevo: !!results.brevo,
          zoho: !!results.zoho,
          openai: !!results.openai,
        },
        duration_ms: durationMs,
      });
      // ‚úÖ PATTERN DATA.DATA RESPECT√â
      return new Response(
        JSON.stringify({
          success: true,
          data: {  // ‚Üê Wrapper data obligatoire
            reseau,
            integrations: results,
          },
          message: "Donn√©es r√©seau r√©cup√©r√©es (quelques int√©grations en erreur)",
          warning: "some_integrations_failed",
          requestId
        }),
        { 
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    logStructured("reseau_and_integrations_ok", {
      requestId,
      reseau_id: reseauId,
      found: {
        brevo: !!results.brevo,
        zoho: !!results.zoho,
        openai: !!results.openai,
      },
      duration_ms: durationMs,
    });

    // ‚úÖ PATTERN DATA.DATA RESPECT√â
    return new Response(
      JSON.stringify({
        success: true,
        data: {  // ‚Üê Wrapper data obligatoire
          reseau,
          integrations: results,
        },
        message: "Donn√©es r√©seau r√©cup√©r√©es avec succ√®s",
        requestId
      }),
      { 
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );

  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return new Response(
      JSON.stringify({
        success: false,
        error: "internal_error",
        requestId
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});
```

---

## N3. `supabase/functions/gestion-reseau-admin-update/index.ts`

**Corrections appliqu√©es** :
- ‚ùå Suppression de `assertServiceRoleAuth()` (BUG #1)
- ‚ùå Suppression de `assertAdminIfProvided()` (BUG #1)
- ‚ùå Suppression de `jsonResponse()` helper (BUG #3)
- ‚úÖ Utilisation de `new Response()` standard (BUG #3)
- ‚úÖ Pattern `{success, data: {reseau, integration}, message}` respect√© (BUG #2)

```typescript
// Mise √† jour d'un r√©seau (g√©n√©ral + int√©grations).
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Mapping tables int√©grations --------------------------------------------
const INTEGRATION_TABLES = {
  brevo: {
    table: "brevo_connexion",
    idField: "brevo_connexion_id",
    fkField: "reseau_brevo_connexion_id",
  },
  zoho: {
    table: "zoho_connexion",
    idField: "zoho_connexion_id",
    fkField: "reseau_zoho_connexion_id",
  },
  openai: {
    table: "openai_connexion",
    idField: "openai_connexion_id",
    fkField: "reseau_openai_connexion_id",
  },
};

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const body = await req.json();
    const { reseauId, generalData, integrationKind, integrationData } = body;

    if (!reseauId) {
      logStructured("missing_reseau_id", { requestId });
      return new Response(
        JSON.stringify({
          success: false,
          error: "bad_request_missing_reseau_id",
          requestId
        }),
        { 
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    const t0 = performance.now();
    let updatedReseau: any = null;
    let updatedIntegration: any = null;
    let message = "";

    // --- UPDATE G√âN√âRAL R√âSEAU ---
    if (generalData && typeof generalData === "object") {
      const { error: updateErr, data: updated } = await supabase
        .from("reseau")
        .update({
          ...generalData,
          reseau_updated_at: new Date().toISOString(),
        })
        .eq("reseau_id", reseauId)
        .select("*")
        .single();

      if (updateErr) {
        logStructured("reseau_update_error", {
          requestId,
          reseau_id: reseauId,
          error: updateErr.message,
        });
        return new Response(
          JSON.stringify({
            success: false,
            error: "db_error_reseau_update",
            details: updateErr.message,
            requestId
          }),
          { 
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      updatedReseau = updated;
      message = "R√©seau mis √† jour";
      logStructured("reseau_update_ok", { requestId, reseau_id: reseauId });
    }

    // --- UPDATE INT√âGRATION ---
    if (integrationKind && integrationData && typeof integrationData === "object") {
      const config = INTEGRATION_TABLES[integrationKind as keyof typeof INTEGRATION_TABLES];
      if (!config) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "unknown_integration_kind",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      // R√©cup√©rer l'ID connexion existant
      const { data: reseauRow, error: fetchErr } = await supabase
        .from("reseau")
        .select(config.fkField)
        .eq("reseau_id", reseauId)
        .single();

      if (fetchErr) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "db_error_fetch_reseau_for_integration",
            details: fetchErr.message,
            requestId
          }),
          { 
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const currentConnexionId = reseauRow?.[config.fkField];

      if (currentConnexionId) {
        // UPDATE int√©gration existante
        const { error: updateIntErr, data: updatedInt } = await supabase
          .from(config.table)
          .update(integrationData)
          .eq(config.idField, currentConnexionId)
          .select("*")
          .single();

        if (updateIntErr) {
          logStructured("integration_update_error", {
            requestId,
            kind: integrationKind,
            error: updateIntErr.message,
          });
          return new Response(
            JSON.stringify({
              success: false,
              error: "db_error_integration_update",
              details: updateIntErr.message,
              requestId
            }),
            { 
              status: 500,
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
        }

        updatedIntegration = updatedInt;
        message += (message ? " + " : "") + `Int√©gration ${integrationKind} mise √† jour`;
        logStructured("integration_update_ok", { requestId, kind: integrationKind });

      } else {
        // INSERT nouvelle int√©gration
        const { error: insertErr, data: newInt } = await supabase
          .from(config.table)
          .insert({
            ...integrationData,
            reseau_id: reseauId,
            organisation_id: reseauRow.organisation_id,
          })
          .select("*")
          .single();

        if (insertErr) {
          logStructured("integration_insert_error", {
            requestId,
            kind: integrationKind,
            error: insertErr.message,
          });
          return new Response(
            JSON.stringify({
              success: false,
              error: "db_error_integration_insert",
              details: insertErr.message,
              requestId
            }),
            { 
              status: 500,
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
        }

        // Lier au r√©seau
        const newConnexionId = newInt[config.idField];
        const { error: linkErr } = await supabase
          .from("reseau")
          .update({ [config.fkField]: newConnexionId })
          .eq("reseau_id", reseauId);

        if (linkErr) {
          logStructured("integration_link_error", {
            requestId,
            kind: integrationKind,
            error: linkErr.message,
          });
          return new Response(
            JSON.stringify({
              success: false,
              error: "db_error_integration_link",
              details: linkErr.message,
              requestId
            }),
            { 
              status: 500,
              headers: { ...corsHeaders, "Content-Type": "application/json" }
            }
          );
        }

        updatedIntegration = newInt;
        message += (message ? " + " : "") + `Int√©gration ${integrationKind} cr√©√©e`;
        logStructured("integration_insert_ok", { requestId, kind: integrationKind });
      }
    }

    const durationMs = Math.round(performance.now() - t0);
    logStructured("update_complete", { requestId, reseau_id: reseauId, duration_ms: durationMs });

    // ‚úÖ PATTERN DATA.DATA RESPECT√â
    return new Response(
      JSON.stringify({
        success: true,
        data: {  // ‚Üê Wrapper data obligatoire
          reseau: updatedReseau,
          integration: updatedIntegration,
        },
        message: message || "Aucune modification",
        requestId
      }),
      { 
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );

  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return new Response(
      JSON.stringify({
        success: false,
        error: "internal_error",
        requestId
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});
```

---

## N4. `supabase/functions/gestion-reseau-admin-fichiers/index.ts`

**Corrections appliqu√©es** :
- ‚ùå Suppression de `assertServiceRoleAuth()` (BUG #1)
- ‚ùå Suppression de `assertAdminIfProvided()` (BUG #1)
- ‚ùå Suppression de `jsonResponse()` helper (BUG #3)
- ‚úÖ Utilisation de `new Response()` standard (BUG #3)
- ‚úÖ Pattern `{success, data, message}` respect√© (BUG #2)

```typescript
// Gestion des fichiers (upload/delete) pour la table reseau.
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const BUCKET_NAME = "bucket-table-reseau";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// --- Types ------------------------------------------------------------------
type ReseauRow = {
  reseau_id: string;
  reseau_logo: string | null;
  reseau_ressources: string[] | null;
};

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

// --- Logs structur√©s --------------------------------------------------------
function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Helpers ----------------------------------------------------------------
function sanitizeFilename(filename: string): string {
  return filename.replace(/[^a-zA-Z0-9._-]/g, "_");
}

function folderForFileType(fileType: string): string {
  return fileType === "logo" ? "logos" : "ressources";
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

// --- DB Helpers -------------------------------------------------------------
async function getReseau(reseauId: string): Promise<ReseauRow | null> {
  const { data, error } = await supabase
    .from("reseau")
    .select("reseau_id, reseau_logo, reseau_ressources")
    .eq("reseau_id", reseauId)
    .maybeSingle();

  if (error) throw new Error(`Erreur r√©cup√©ration r√©seau: ${error.message}`);
  return data;
}

async function setReseauLogo(reseauId: string, logoPath: string | null) {
  const { error } = await supabase
    .from("reseau")
    .update({ reseau_logo: logoPath })
    .eq("reseau_id", reseauId);

  if (error) throw new Error(`Erreur mise √† jour logo: ${error.message}`);
}

async function addReseauRessource(reseauId: string, path: string) {
  const reseau = await getReseau(reseauId);
  if (!reseau) throw new Error("R√©seau introuvable");

  const current = reseau.reseau_ressources ?? [];
  const updated = [...current, path];

  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);

  if (error) throw new Error(`Erreur ajout ressource: ${error.message}`);
}

async function removeReseauRessource(reseauId: string, path: string) {
  const reseau = await getReseau(reseauId);
  if (!reseau) throw new Error("R√©seau introuvable");

  const current = reseau.reseau_ressources ?? [];
  const updated = current.filter((r) => r !== path);

  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);

  if (error) throw new Error(`Erreur suppression ressource: ${error.message}`);
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const contentType = req.headers.get("content-type") || "";

    // --- UPLOAD FILE ---
    if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      const reseauId = formData.get("reseau_id") as string | null;
      const fileType = formData.get("fileType") as string | null;
      const file = formData.get("file") as File | null;

      if (!reseauId || !UUID_REGEX.test(reseauId)) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "reseau_id invalide ou manquant",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (!fileType || !["logo", "ressource"].includes(fileType)) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "fileType invalide (logo ou ressource)",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (!file) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Aucun fichier fourni",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "R√©seau introuvable",
            requestId
          }),
          { 
            status: 404,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const folder = folderForFileType(fileType);
      const sanitized = sanitizeFilename(file.name);
      const storagePath = `${folder}/${reseauId}/${Date.now()}_${sanitized}`;

      const fileBuffer = await file.arrayBuffer();
      const { error: uploadErr } = await supabase.storage
        .from(BUCKET_NAME)
        .upload(storagePath, fileBuffer, {
          contentType: file.type,
          upsert: false,
        });

      if (uploadErr) {
        logStructured("upload_error", {
          requestId,
          reseau_id: reseauId,
          error: uploadErr.message,
        });
        return new Response(
          JSON.stringify({
            success: false,
            error: "Erreur upload fichier",
            details: uploadErr.message,
            requestId
          }),
          { 
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (fileType === "logo") {
        await setReseauLogo(reseauId, storagePath);
      } else {
        await addReseauRessource(reseauId, storagePath);
      }

      logStructured("upload_success", {
        requestId,
        reseau_id: reseauId,
        file_type: fileType,
        path: storagePath,
      });

      // ‚úÖ PATTERN DATA.DATA RESPECT√â
      return new Response(
        JSON.stringify({
          success: true,
          data: {  // ‚Üê Wrapper data obligatoire
            path: storagePath,
            fileType
          },
          message: "Fichier upload√© avec succ√®s",
          requestId
        }),
        { 
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    // --- DELETE FILE ---
    if (contentType.includes("application/json")) {
      const body = await req.json();
      const { action, reseau_id, fileType, path } = body;

      if (action !== "delete") {
        return new Response(
          JSON.stringify({
            success: false,
            error: "Action invalide (attendu: delete)",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (!reseau_id || !UUID_REGEX.test(reseau_id)) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "reseau_id invalide ou manquant",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (!fileType || !["logo", "ressource"].includes(fileType)) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "fileType invalide (logo ou ressource)",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (!path || typeof path !== "string") {
        return new Response(
          JSON.stringify({
            success: false,
            error: "path manquant",
            requestId
          }),
          { 
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const reseau = await getReseau(reseau_id);
      if (!reseau) {
        return new Response(
          JSON.stringify({
            success: false,
            error: "R√©seau introuvable",
            requestId
          }),
          { 
            status: 404,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const { error: deleteErr } = await supabase.storage
        .from(BUCKET_NAME)
        .remove([path]);

      if (deleteErr) {
        logStructured("delete_error", {
          requestId,
          reseau_id,
          error: deleteErr.message,
        });
        return new Response(
          JSON.stringify({
            success: false,
            error: "Erreur suppression fichier",
            details: deleteErr.message,
            requestId
          }),
          { 
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      if (fileType === "logo") {
        await setReseauLogo(reseau_id, null);
      } else {
        await removeReseauRessource(reseau_id, path);
      }

      logStructured("delete_success", {
        requestId,
        reseau_id,
        file_type: fileType,
        path,
      });

      // ‚úÖ PATTERN DATA.DATA RESPECT√â
      return new Response(
        JSON.stringify({
          success: true,
          data: {  // ‚Üê Wrapper data obligatoire
            deleted: path,
            fileType
          },
          message: "Fichier supprim√© avec succ√®s",
          requestId
        }),
        { 
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    // Content-Type non support√©
    return new Response(
      JSON.stringify({
        success: false,
        error: "Content-Type non support√©",
        requestId
      }),
      { 
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );

  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return new Response(
      JSON.stringify({
        success: false,
        error: "internal_error",
        details: e instanceof Error ? e.message : String(e),
        requestId
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});
```

---

## N5. Hooks ‚Äì `useReseauFormData.ts`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

Le hook frontend est **d√©j√† conforme** au pattern `data.data`. Il attend correctement :
- `data.data.reseau` pour les donn√©es r√©seau
- `data.data.integrations` pour les int√©grations

**R√©f√©rence fichier actuel** : Voir `.Step01-FichiersActuels.md` section N6

---

## N6. Hooks ‚Äì `useReseauIntegrations.ts`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

Le hook g√®re correctement les int√©grations et attend le pattern `data.data`.

**R√©f√©rence fichier actuel** : Voir `.Step01-FichiersActuels.md` section N7

---

## N7. Composant ‚Äì `ReseauSelector.tsx`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

Le composant attend `data.data` et est conforme.

**R√©f√©rence fichier actuel** : Voir `.Step01-FichiersActuels.md` section N8

---

## N8. Hook  ‚Äì `types.ts`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

Les types sont corrects et conformes.

**R√©f√©rence fichier actuel** : Voir `.Step01-FichiersActuels.md` section N9

---

## 9. Fichier ‚Äì `3.FormReseauGestion.tsx`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

Le composant principal est conforme et g√®re correctement les hooks.

**R√©f√©rence fichier actuel** : Voir `.Step01-FichiersActuels.md` section N10

---

## 10. Fichier ‚Äì `supabase/config.toml`

**‚ö†Ô∏è AUCUNE MODIFICATION N√âCESSAIRE**

La configuration est d√©j√† correcte :

```toml
project_id = "ksymahfrtvhnbeobsspt"

[functions.gestion-reseau-admin]
verify_jwt = false

[functions.gestion-reseau-admin-donnees]
verify_jwt = false

[functions.gestion-reseau-admin-update]
verify_jwt = false

[functions.gestion-reseau-admin-fichiers]
verify_jwt = false
```

‚úÖ `verify_jwt = false` permet d'utiliser SERVICE_ROLE_KEY sans validation JWT

---

## 11. MIGRATIONS SQL

**‚ö†Ô∏è AUCUNE MIGRATION N√âCESSAIRE**

Les corrections concernent uniquement :
- Le code TypeScript des Edge Functions (suppression de fonctions bloquantes)
- La structure des retours JSON (pattern data.data)

**Aucune modification de sch√©ma ou de policy RLS n'est requise.**

---

## üìä R√âSUM√â DES CORRECTIONS

### ‚úÖ **Corrections appliqu√©es**

| Fichier | Bug #1 | Bug #2 | Bug #3 | Statut |
|---------|--------|--------|--------|--------|
| `gestion-reseau-admin/index.ts` | ‚úÖ Supprim√© `assertServiceRoleAuth()` | ‚úÖ Pattern `data.data` | ‚úÖ `new Response()` | Corrig√© |
| `gestion-reseau-admin-donnees/index.ts` | ‚úÖ Supprim√© `assertServiceRoleAuth()` | ‚úÖ Pattern `data.data` | ‚úÖ `new Response()` | Corrig√© |
| `gestion-reseau-admin-update/index.ts` | ‚úÖ Supprim√© `assertServiceRoleAuth()` | ‚úÖ Pattern `data.data` | ‚úÖ `new Response()` | Corrig√© |
| `gestion-reseau-admin-fichiers/index.ts` | ‚úÖ Supprim√© `assertServiceRoleAuth()` | ‚úÖ Pattern `data.data` | ‚úÖ `new Response()` | Corrig√© |
| Hooks Frontend | ‚Äî | ‚úÖ D√©j√† conforme | ‚Äî | Aucune modif |
| Composants | ‚Äî | ‚úÖ D√©j√† conforme | ‚Äî | Aucune modif |
| `config.toml` | ‚úÖ D√©j√† conforme | ‚Äî | ‚Äî | Aucune modif |
| Migrations SQL | ‚Äî | ‚Äî | ‚Äî | Aucune n√©cessaire |

### üéØ **Impact attendu**

Apr√®s application de ces corrections :

1. ‚úÖ **D√©blocage appels Edge Functions** : Plus d'erreur 401 Unauthorized
2. ‚úÖ **Chargement formulaire** : Les donn√©es `data.data.reseau` seront accessibles
3. ‚úÖ **Liste r√©seaux** : Le s√©lecteur recevra `data.data` correctement
4. ‚úÖ **Coh√©rence architecturale** : M√™me structure que formulaire cr√©ation

---

## üîó **R√©f√©rences documentation**

- **Audit complet** : `.Step02-AuditdesBugsStap01.md`
- **Fichiers actuels** : `.Step01-FichiersActuels.md`
- **Guide data.data** : `0.Readme/06.GUIDE-DataData-EdgeFunctions.md`
- **Formulaire cr√©ation (mod√®le)** : `0.Readme/` (r√©f√©rence architecture)

---

**üìå NOTE IMPORTANTE** : Ces propositions corrigent **UNIQUEMENT les 3 bugs identifi√©s** dans l'audit. Aucune autre fonctionnalit√© n'a √©t√© modifi√©e ou ajout√©e.
