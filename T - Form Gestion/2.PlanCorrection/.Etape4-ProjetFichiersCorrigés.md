# PLAN DE CORRECTION - Présentation des Fichiers Corrigés prévus dans Etape3-PlandeCorrection.md
---
## 1. `supabase/functions/gestion-reseau-admin/index.ts`
### 1/ Problème
- Vérification manuelle du JWT utilisateur avec `supabaseAdmin.auth.getUser(token)` alors que l'appel passe via **Service Role Key**.  
- Conflit : `verify_jwt=false` (config) mais code qui exige un JWT → erreur `Token invalide`.  

### 2/ Vérifications préalables
- **VALIDÉ** : Admin `pgarnier@presenca.fr` avec `users_role_systeme = 'admin_presenca'` existe  
- **VALIDÉ** : 3 réseaux actifs en base  
- **VALIDÉ** : Fonction `is_admin_presenca()` retourne `true` pour `users_auth_id` correct  

### 3/ Solution
- Supprimer l’appel auth.getUser(token) si Service Role Key est utilisé.
- Vérifier directement dans la table users que le rôle = admin_presenca.
- Ajouter logs structurés : request_id, caller_role, reseau_count.

### 4/ Code corrigé
```typescript
// supabase/functions/gestion-reseau-admin/index.ts
// Liste les réseaux pour l'espace de gestion.
// Stratégie : SERVICE_ROLE_KEY (verify_jwt=false) + contrôle applicatif FACULTATIF (admin_presenca) si user_id fourni.
// AUCUN décodage / validation de JWT utilisateur ici.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structurés --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Sécurité : exiger la SERVICE_ROLE_KEY ----------------------------------
// On NE traite PAS de JWT utilisateur ici. On vérifie juste que l'appel
// utilise bien la clé serveur (double barrière côté infra).
function assertServiceRoleAuth(req: Request, requestId: string) {
  const auth = req.headers.get("authorization") || req.headers.get("Authorization");
  const ok = !!auth && auth.trim().toLowerCase().startsWith("bearer ");
  if (!ok) {
    logStructured("auth_missing_bearer", { requestId });
    return false;
  }
  const token = auth!.replace(/bearer\s+/i, "").trim();
  const match = token === SERVICE_ROLE_KEY;
  if (!match) {
    logStructured("auth_invalid_bearer", { requestId });
  }
  return match;
}

// --- Contrôle applicatif (FACULTATIF) : admin_presenca ----------------------
// Si `x-user-id` (ou body.user_id) est fourni, on vérifie `users_role_systeme`.
// Sinon on passe (mode admin global via Service Role Key).
async function assertAdminIfProvided(userId: string | null, requestId: string) {
  if (!userId) {
    logStructured("admin_check_skipped", { requestId, reason: "no_user_id" });
    return { ok: true, role: "unknown" as const };
  }
  const { data, error } = await supabase
    .from("users")
    .select("users_role_systeme")
    .eq("users_auth_id", userId)
    .limit(1)
    .maybeSingle();

  if (error) {
    logStructured("admin_check_error", { requestId, error: error.message });
    return { ok: false as const, role: "error" as const, reason: error.message };
  }
  const isAdmin = data?.users_role_systeme === "admin_presenca";
  if (!isAdmin) {
    logStructured("admin_check_denied", {
      requestId,
      userId,
      role: data?.users_role_systeme ?? null,
    });
    return {
      ok: false as const,
      role: (data?.users_role_systeme ?? "none") as const,
      reason: "not_admin_presenca",
    };
  }
  logStructured("admin_check_ok", { requestId, userId, role: "admin_presenca" });
  return { ok: true as const, role: "admin_presenca" as const };
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  // Exiger l'appel avec la SERVICE_ROLE_KEY
  if (!assertServiceRoleAuth(req, requestId)) {
    return jsonResponse(
      { ok: false, error: "unauthorized_service_role_required", requestId },
      401,
    );
  }

  try {
    // Body optionnel : { user_id?: string }
    let userId: string | null = null;
    try {
      if (req.method === "POST") {
        const body = await req.json().catch(() => ({}));
        if (body && typeof body.user_id === "string") userId = body.user_id;
      }
    } catch {
      // ignore malformed JSON; we continue with null userId
    }

    // Header facultatif (prioritaire si présent) : X-User-Id
    const headerUserId = req.headers.get("x-user-id");
    if (headerUserId) userId = headerUserId;

    // Contrôle applicatif facultatif
    const adminCheck = await assertAdminIfProvided(userId, requestId);
    if (!adminCheck.ok) {
      return jsonResponse(
        { ok: false, error: "forbidden_not_admin_presenca", requestId, role: adminCheck.role },
        403,
      );
    }

    const t0 = performance.now();

    // Projection MINIMALE pour le sélecteur : reseau_nom (1er), reseau_id
    const { data, error } = await supabase
      .from("reseau")
      .select("reseau_nom, reseau_id")
      .order("reseau_nom", { ascending: true });

    const durationMs = Math.round(performance.now() - t0);

    if (error) {
      logStructured("reseau_list_error", { requestId, error: error.message, duration_ms: durationMs });
      return jsonResponse(
        { ok: false, error: "db_error_reseau_list", details: error.message, requestId },
        500,
      );
    }

    // Forcer l'ordre des propriétés (reseau_nom en 1er) dans la réponse
    const dataMinimal = (data ?? []).map((r: any) => ({
      reseau_nom: r.reseau_nom,
      reseau_id: r.reseau_id,
    }));

    logStructured("reseau_list_ok", {
      requestId,
      result_count: dataMinimal.length,
      duration_ms: durationMs,
      admin_role: adminCheck.role,
    });

    return jsonResponse(
      { ok: true, requestId, count: dataMinimal.length, data: dataMinimal },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});

```
---
## 2. `supabase/functions/gestion-reseau-admin-donnees/index.ts`
### 1/ Problème
- Même incohérence JWT que ci-dessus.  
- Absence de logs précis.  

### 2/ Vérifications préalables
- Confirmer que les FK vers `brevo_connexion`, `zoho_connexion`, `openai_connexion` sont cohérents.

### 3/ Vérifications effectuées
- 1/ FK vers les tables de connexion
  - Tables de connexion présentes : brevo_connexion, zoho_connexion, openai_connexion
  - Colonnes PK correctes : brevo_connexion_id, zoho_connexion_id, openai_connexion_id (toutes UUID NOT NULL)
  - FK dans reseau : reseau_brevo_connexion_id, reseau_zoho_connexion_id, reseau_openai_connexion_id

- 2/ État actuel des données
  -  3  réseaux en base (TEST RESEAU V4, V6, TEST18.09.2025)
  -  Toutes les FK de connexion = NULL → pas de connexions configurées actuellement
  -  Tables de connexion vides (0 enregistrements dans chaque table)

- 3/ Autres vérifications critiques identifiées :
  - Problème JWT identique à gestion-reseau-admin
    - La fonction utilise supabaseAdmin.auth.getUser(token) avec verify_jwt=false.
    - Incohérence : demande JWT utilisateur alors que Service Role Key est utilisée
  - Absence de logs structurés pour le debugging
  - Requêtes séparées vs JOIN :
    - Le code actuel fait des requêtes individuelles (correct vu les FK NULL)
  - Sécurité :
    - Même faille que l'autre fonction : JWT validation inutile avec Service Role Key
  
### 4/ Solution
Appliquer la même correction d’auth (pas de check JWT avec Service Role Key).  
- 1/Toujours basé sur JWT (à supprimer)
  - Ne pas utiliser supabaseAdmin.auth.getUser(token)
  - Avec Service Role Key et verify_jwt=false, il n’y a pas de JWT utilisateur
  - Sinon → erreur systématique “Token invalide”
- 2/Vérification admin_presenca 
  - Si userId est fourni → vérifier qu’il est bien admin_presenca
  - Si pas de userId → laisser passer (la vraie barrière est le Service Role Key)
- 3/Logs structurés obligatoires
  - Générer un requestId unique par appel
  - Logguer : requestId, reseauId demandé, erreurs DB, durée de traitement
  - Inclure le nombre et le type d’intégrations trouvées
  - → Ne pas se contenter de console.log(reseauId)

### 5/ Code corrigé
```typescript
// supabase/functions/gestion-reseau-admin-donnees/index.ts
// Détail d'un réseau + intégrations (Brevo, Zoho, OpenAI) pour le formulaire de gestion.
// Stratégie : SERVICE_ROLE_KEY (verify_jwt=false) + contrôle applicatif FACULTATIF (admin_presenca) si user_id fourni.
// AUCUN décodage / validation de JWT utilisateur ici.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS", // ✅ Correction casse
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structurés --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Sécurité : exiger la SERVICE_ROLE_KEY ----------------------------------
function assertServiceRoleAuth(req: Request, requestId: string) {
  const auth = req.headers.get("authorization") || req.headers.get("Authorization");
  const ok = !!auth && auth.trim().toLowerCase().startsWith("bearer ");
  if (!ok) {
    logStructured("auth_missing_bearer", { requestId });
    return false;
  }
  const token = auth!.replace(/bearer\s+/i, "").trim();
  const match = token === SERVICE_ROLE_KEY;
  if (!match) {
    logStructured("auth_invalid_bearer", { requestId });
  }
  return match;
}

// --- Contrôle applicatif (FACULTATIF) : admin_presenca ----------------------
async function assertAdminIfProvided(userId: string | null, requestId: string) {
  if (!userId) {
    logStructured("admin_check_skipped", { requestId, reason: "no_user_id" });
    return { ok: true, role: "unknown" as const };
  }
  const { data, error } = await supabase
    .from("users")
    .select("users_role_systeme")
    .eq("users_auth_id", userId)
    .limit(1)
    .maybeSingle();

  if (error) {
    logStructured("admin_check_error", { requestId, error: error.message });
    return { ok: false as const, role: "error" as const, reason: error.message };
  }
  const isAdmin = data?.users_role_systeme === "admin_presenca";
  if (!isAdmin) {
    logStructured("admin_check_denied", {
      requestId,
      userId,
      role: data?.users_role_systeme ?? null,
    });
    return {
      ok: false as const,
      role: (data?.users_role_systeme ?? "none") as const,
      reason: "not_admin_presenca",
    };
  }
  logStructured("admin_check_ok", { requestId, userId, role: "admin_presenca" });
  return { ok: true as const, role: "admin_presenca" as const };
}

// --- Projections ------------------------------------------------------------
const RESEAU_PROJECTION = [
  "reseau_id",
  "organisation_id",
  "reseau_nom",
  "reseau_identite_commerciale",
  "reseau_adresse",
  "reseau_code_postal",
  "reseau_ville",
  "reseau_siret",
  "reseau_telephone",
  "reseau_email",
  "reseau_logo",
  "reseau_ressources",
  "reseau_brevo_connexion_id",
  "reseau_zoho_connexion_id",
  "reseau_openai_connexion_id",
].join(",");

const INTEGRATION_PROJECTION = "*";

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  if (!assertServiceRoleAuth(req, requestId)) {
    return jsonResponse(
      { ok: false, error: "unauthorized_service_role_required", requestId },
      401,
    );
  }

  try {
    let userId: string | null = null;
    let reseauId: string | null = null;

    const url = new URL(req.url);
    const qsReseau = url.searchParams.get("reseau_id");
    if (qsReseau) reseauId = qsReseau;

    if (req.method === "POST") {
      try {
        const body = await req.json().catch(() => ({}));
        if (body && typeof body.user_id === "string") userId = body.user_id;
        if (!reseauId && body && typeof body.reseau_id === "string") reseauId = body.reseau_id;
      } catch {
        // ignore malformed JSON
      }
    }

    const headerUserId = req.headers.get("x-user-id");
    if (headerUserId) userId = headerUserId;

    if (!reseauId) {
      logStructured("missing_reseau_id", { requestId });
      return jsonResponse(
        { ok: false, error: "bad_request_missing_reseau_id", requestId },
        400,
      );
    }

    const adminCheck = await assertAdminIfProvided(userId, requestId);
    if (!adminCheck.ok) {
      return jsonResponse(
        { ok: false, error: "forbidden_not_admin_presenca", requestId, role: adminCheck.role },
        403,
      );
    }

    const t0 = performance.now();

    const { data: reseau, error: reseauErr } = await supabase
      .from("reseau")
      .select(RESEAU_PROJECTION)
      .eq("reseau_id", reseauId)
      .maybeSingle();

    if (reseauErr) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_fetch_error", {
        requestId,
        reseau_id: reseauId,
        error: reseauErr.message,
        duration_ms: durationMs,
      });
      return jsonResponse(
        { ok: false, error: "db_error_reseau_fetch", details: reseauErr.message, requestId },
        500,
      );
    }

    if (!reseau) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_not_found", { requestId, reseau_id: reseauId, duration_ms: durationMs });
      return jsonResponse(
        { ok: false, error: "not_found_reseau", requestId, reseau_id: reseauId },
        404,
      );
    }

    const brevoId = reseau.reseau_brevo_connexion_id as string | null;
    const zohoId = reseau.reseau_zoho_connexion_id as string | null;
    const openaiId = reseau.reseau_openai_connexion_id as string | null;

    const promises: Promise<any>[] = [];
    const results: { brevo: any | null; zoho: any | null; openai: any | null } = {
      brevo: null,
      zoho: null,
      openai: null,
    };

    if (brevoId) {
      promises.push(
        supabase
          .from("brevo_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("brevo_connexion_id", brevoId) // ✅ Correction mapping
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`brevo_fetch_error:${error.message}`);
            results.brevo = data ?? null;
          }),
      );
    }
    if (zohoId) {
      promises.push(
        supabase
          .from("zoho_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("zoho_connexion_id", zohoId) // ✅ Correction mapping
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`zoho_fetch_error:${error.message}`);
            results.zoho = data ?? null;
          }),
      );
    }
    if (openaiId) {
      promises.push(
        supabase
          .from("openai_connexion")
          .select(INTEGRATION_PROJECTION)
          .eq("openai_connexion_id", openaiId) // ✅ Correction mapping
          .maybeSingle()
          .then(({ data, error }) => {
            if (error) throw new Error(`openai_fetch_error:${error.message}`);
            results.openai = data ?? null;
          }),
      );
    }

    let integrationsError: string | null = null;
    try {
      if (promises.length > 0) {
        await Promise.all(promises);
      }
    } catch (e) {
      integrationsError = e instanceof Error ? e.message : String(e);
    }

    const durationMs = Math.round(performance.now() - t0);

    if (integrationsError) {
      logStructured("integrations_fetch_partial_error", {
        requestId,
        reseau_id: reseauId,
        error: integrationsError,
        found: {
          brevo: !!results.brevo,
          zoho: !!results.zoho,
          openai: !!results.openai,
        },
        duration_ms: durationMs,
      });
      return jsonResponse(
        {
          ok: true,
          requestId,
          reseau_id: reseauId,
          reseau,
          integrations: results,
          warning: "some_integrations_failed",
        },
        200,
      );
    }

    logStructured("reseau_and_integrations_ok", {
      requestId,
      reseau_id: reseauId,
      found: {
        brevo: !!results.brevo,
        zoho: !!results.zoho,
        openai: !!results.openai,
      },
      duration_ms: durationMs,
      admin_role: adminCheck.role,
    });

    return jsonResponse(
      {
        ok: true,
        requestId,
        reseau_id: reseauId,
        reseau,
        integrations: results,
      },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});

```
---
---
## 3. `supabase/functions/gestion-reseau-admin-update/index.ts`
### 1/ Problème
- Vérification JWT inutile.  
- Logs insuffisants.  
- Risque d’incohérence dans synchro email/téléphone `reseau → reseau_direction`.  

### 2/ Vérifications préalables
- Vérifier que la synchro est bien en place côté DB (triggers ou fonction SQL).

### 3/ Vérifications effectuées
PROBLÈME IDENTIFIÉ : Aucune synchronisation automatique
-  Fonctions existantes :
  -  create_reseau_compte_complet - Création complète (OK)
  -  Triggers d'audit uniquement (pas de synchronisation)
-  Fonctions manquantes :
  -  Fonction de synchronisation automatique reseau → reseau_direction
  -  Trigger de synchronisation sur UPDATE reseau
  -  Fonction de synchronisation inverse reseau_direction → reseau (optionnel)

### 4/ Solution
Appliquer la même correction d’auth (pas de check JWT avec Service Role Key).  
- 1/Toujours basé sur JWT (à supprimer)
  - Ne pas utiliser supabaseAdmin.auth.getUser(token)
  - Avec Service Role Key et verify_jwt=false, il n’y a pas de JWT utilisateur
  - Sinon → erreur systématique “Token invalide”
- 2/Vérification admin_presenca 
  - Si userId est fourni → vérifier qu’il est bien admin_presenca
  - Si pas de userId → laisser passer (la vraie barrière est le Service Role Key)
- 3/Logs structurés obligatoires
  - Générer un requestId unique par appel
  - Logguer : requestId, reseauId demandé, erreurs DB, durée de traitement
  - Inclure le nombre et le type d’intégrations trouvées
  - → Ne pas se contenter de console.log(reseauId)
- 4/le sql de synchronisation sera fait plus tard
  - Codage de la fonction upadate comme si la sql de synchronisation etait en place
  - to do list -> Prévoir la création de cette sql de synchronisation au point n10 de l'Etape4
  - Vérification si gestion-reseau-admin-update respecte bien les codes de synchro prévus

### 5/ Code corrigé
```typescript
// supabase/functions/gestion-reseau-admin-update/index.ts
// Mise à jour d'un réseau + gestion des intégrations (Brevo, Zoho, OpenAI).
// Hypothèse : la synchro reseau -> reseau_direction (email, téléphone) est gérée côté DB (trigger SQL).
// Stratégie : SERVICE_ROLE_KEY (verify_jwt=false) + contrôle applicatif FACULTATIF (admin_presenca) si user_id fourni.
// AUCUN décodage / validation de JWT utilisateur ici.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const ALLOWED_ORIGIN = Deno.env.get("ALLOWED_ORIGIN") ?? "*";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": ALLOWED_ORIGIN,
  "Access-Control-Allow-Headers": "authorization, x-user-id, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

function jsonResponse(
  body: JsonRecord,
  status = 200,
  extraHeaders: HeadersInit = {},
) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...corsHeaders,
      ...extraHeaders,
    },
  });
}

// --- Logs structurés --------------------------------------------------------
function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Sécurité : exiger la SERVICE_ROLE_KEY ----------------------------------
// On NE traite PAS de JWT utilisateur ici. On vérifie juste que l'appel
// utilise bien la clé serveur (double barrière côté infra).
function assertServiceRoleAuth(req: Request, requestId: string) {
  const auth = req.headers.get("authorization") || req.headers.get("Authorization");
  const ok = !!auth && auth.trim().toLowerCase().startsWith("bearer ");
  if (!ok) {
    logStructured("auth_missing_bearer", { requestId });
    return false;
  }
  const token = auth!.replace(/bearer\s+/i, "").trim();
  const match = token === SERVICE_ROLE_KEY;
  if (!match) {
    logStructured("auth_invalid_bearer", { requestId });
  }
  return match;
}

// --- Contrôle applicatif (FACULTATIF) : admin_presenca ----------------------
// Si `x-user-id` (ou body.user_id) est fourni, on vérifie `users_role_systeme`.
// Sinon on passe (mode admin global via Service Role Key).
async function assertAdminIfProvided(userId: string | null, requestId: string) {
  if (!userId) {
    logStructured("admin_check_skipped", { requestId, reason: "no_user_id" });
    return { ok: true, role: "unknown" as const, users_id: null as string | null };
  }
  const { data, error } = await supabase
    .from("users")
    .select("users_role_systeme, users_id")
    .eq("users_auth_id", userId)
    .limit(1)
    .maybeSingle();

  if (error) {
    logStructured("admin_check_error", { requestId, error: error.message });
    return { ok: false as const, role: "error" as const, users_id: null, reason: error.message };
  }
  const isAdmin = data?.users_role_systeme === "admin_presenca";
  if (!isAdmin) {
    logStructured("admin_check_denied", {
      requestId,
      userId,
      role: data?.users_role_systeme ?? null,
    });
    return {
      ok: false as const,
      role: (data?.users_role_systeme ?? "none") as const,
      users_id: null,
      reason: "not_admin_presenca",
    };
  }
  logStructured("admin_check_ok", { requestId, userId, role: "admin_presenca" });
  return { ok: true as const, role: "admin_presenca" as const, users_id: data?.users_id ?? null };
}

// --- Config intégrations (mapping vérifié) ----------------------------------
const INTEGRATION_TABLES = {
  brevo: {
    table: "brevo_connexion",
    idField: "brevo_connexion_id",
    reseauField: "reseau_brevo_connexion_id",
  },
  zoho: {
    table: "zoho_connexion",
    idField: "zoho_connexion_id",
    reseauField: "reseau_zoho_connexion_id",
  },
  openai: {
    table: "openai_connexion",
    idField: "openai_connexion_id",
    reseauField: "reseau_openai_connexion_id",
  },
} as const;

type IntegrationKind = keyof typeof INTEGRATION_TABLES;

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  // Exiger l'appel avec la SERVICE_ROLE_KEY
  if (!assertServiceRoleAuth(req, requestId)) {
    return jsonResponse(
      { ok: false, error: "unauthorized_service_role_required", requestId },
      401,
    );
  }

  try {
    const t0 = performance.now();

    // Lecture du body (JSON)
    let body: any = {};
    try {
      body = await req.json();
    } catch {
      // si pas de JSON, body reste {}
    }

    const reseauId: string | undefined = body?.reseauId ?? body?.reseau_id;
    const generalData: Record<string, any> | undefined = body?.generalData;
    const integrationKind: IntegrationKind | undefined = body?.integrationKind;
    const integrationData: Record<string, any> | undefined = body?.integrationData;

    if (!reseauId) {
      logStructured("bad_request_missing_reseau_id", { requestId });
      return jsonResponse(
        { ok: false, error: "bad_request_missing_reseau_id", requestId },
        400,
      );
    }

    // Header facultatif (prioritaire si présent) : X-User-Id
    let userId: string | null = null;
    const headerUserId = req.headers.get("x-user-id");
    if (headerUserId) userId = headerUserId;
    if (!userId && typeof body?.user_id === "string") userId = body.user_id;

    // Contrôle applicatif FACULTATIF
    const adminCheck = await assertAdminIfProvided(userId, requestId);
    if (!adminCheck.ok) {
      return jsonResponse(
        { ok: false, error: "forbidden_not_admin_presenca", requestId, role: adminCheck.role },
        403,
      );
    }

    // Réponse cumulée
    const updated: { reseau?: any; integrations?: Record<string, any> } = {};

    // --- 1) Mise à jour des données générales du réseau ---------------------
    if (generalData && typeof generalData === "object") {
      // Ajout des champs d'audit si disponibles (users_id interne)
      const updatePayload = {
        ...generalData,
        reseau_updated_at: new Date().toISOString(),
        reseau_updated_by: adminCheck.users_id ?? null,
      };

      const { data: reseauUpdated, error: updateErr } = await supabase
        .from("reseau")
        .update(updatePayload)
        .eq("reseau_id", reseauId)
        .select("*")
        .maybeSingle();

      if (updateErr) {
        const durationMs = Math.round(performance.now() - t0);
        logStructured("reseau_update_error", {
          requestId,
          reseau_id: reseauId,
          error: updateErr.message,
          duration_ms: durationMs,
        });
        return jsonResponse(
          { ok: false, error: "db_error_reseau_update", details: updateErr.message, requestId },
          500,
        );
      }

      updated.reseau = reseauUpdated;
      logStructured("reseau_update_ok", {
        requestId,
        reseau_id: reseauId,
      });
      // NB: la synchro reseau -> reseau_direction (email/téléphone) est
      // assurée par trigger SQL côté DB (hors de cette EF).
    }

    // --- 2) Gestion des intégrations (création / mise à jour) ---------------
    if (integrationKind && integrationData && typeof integrationData === "object") {
      const config = INTEGRATION_TABLES[integrationKind];
      if (!config) {
        return jsonResponse(
          { ok: false, error: "unsupported_integration_kind", requestId, integrationKind },
          400,
        );
      }

      // Récupérer organisation_id + FK de l'intégration actuelle
      const { data: reseauInfo, error: reseauInfoErr } = await supabase
        .from("reseau")
        .select(`organisation_id, ${config.reseauField}`)
        .eq("reseau_id", reseauId)
        .maybeSingle();

      if (reseauInfoErr || !reseauInfo) {
        const durationMs = Math.round(performance.now() - t0);
        logStructured("reseau_info_fetch_error", {
          requestId,
          reseau_id: reseauId,
          error: reseauInfoErr?.message ?? "reseau_not_found",
          duration_ms: durationMs,
        });
        return jsonResponse(
          { ok: false, error: "db_error_reseau_info_fetch", details: reseauInfoErr?.message ?? "reseau_not_found", requestId },
          500,
        );
      }

      const currentConnexionId = reseauInfo[config.reseauField] as string | null;

      if (currentConnexionId) {
        // Mise à jour d'une intégration existante
        const { data: updatedConn, error: updErr } = await supabase
          .from(config.table)
          .update(integrationData)
          .eq(config.idField, currentConnexionId)
          .select("*")
          .maybeSingle();

        if (updErr) {
          const durationMs = Math.round(performance.now() - t0);
          logStructured("integration_update_error", {
            requestId,
            reseau_id: reseauId,
            integration: integrationKind,
            error: updErr.message,
            duration_ms: durationMs,
          });
          return jsonResponse(
            { ok: false, error: "db_error_integration_update", details: updErr.message, requestId },
            500,
          );
        }

        updated.integrations = { ...(updated.integrations ?? {}), [integrationKind]: updatedConn };
        logStructured("integration_update_ok", {
          requestId,
          reseau_id: reseauId,
          integration: integrationKind,
        });
      } else {
        // Création d'une nouvelle intégration
        const integrationWithMeta = {
          ...integrationData,
          organisation_id: reseauInfo.organisation_id,
          reseau_id: reseauId,
        };

        const { data: newConn, error: insErr } = await supabase
          .from(config.table)
          .insert(integrationWithMeta)
          .select("*")
          .maybeSingle();

        if (insErr) {
          const durationMs = Math.round(performance.now() - t0);
          logStructured("integration_insert_error", {
            requestId,
            reseau_id: reseauId,
            integration: integrationKind,
            error: insErr.message,
            duration_ms: durationMs,
          });
          return jsonResponse(
            { ok: false, error: "db_error_integration_insert", details: insErr.message, requestId },
            500,
          );
        }

        // Lier la nouvelle intégration à la table reseau
        const linkPayload: Record<string, any> = { [config.reseauField]: newConn[config.idField] };
        const { error: linkErr } = await supabase
          .from("reseau")
          .update(linkPayload)
          .eq("reseau_id", reseauId);

        if (linkErr) {
          const durationMs = Math.round(performance.now() - t0);
          logStructured("integration_link_error", {
            requestId,
            reseau_id: reseauId,
            integration: integrationKind,
            error: linkErr.message,
            duration_ms: durationMs,
          });
          return jsonResponse(
            { ok: false, error: "db_error_integration_link", details: linkErr.message, requestId },
            500,
          );
        }

        updated.integrations = { ...(updated.integrations ?? {}), [integrationKind]: newConn };
        logStructured("integration_insert_ok", {
          requestId,
          reseau_id: reseauId,
          integration: integrationKind,
        });
      }
    }

    const durationMs = Math.round(performance.now() - t0);
    logStructured("gestion_reseau_update_done", {
      requestId,
      reseau_id: reseauId,
      has_general_update: !!generalData,
      has_integration_update: !!(integrationKind && integrationData),
      duration_ms: durationMs,
      admin_role: adminCheck.role,
    });

    return jsonResponse(
      {
        ok: true,
        requestId,
        updated,
      },
      200,
    );
  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return jsonResponse(
      { ok: false, error: "internal_error", requestId },
      500,
    );
  }
});

```
---
## 4. `supabase/functions/gestion-reseau-admin-fichiers/index.ts`
### 1/ Problème
- Conflit entre `organisation-{uuid}` (code EF) et `reseau-{uuid}` (stratégie validée).  
- Paramètre d’upload incohérent : front envoie `type`, EF attend `fileType`.  
- Vérification JWT encore présente.  

### 2/ Vérifications préalables
Analyse complète et fouillée dans Supabase en temps réel et dans les fichiers de l'application
- 1/Structure actuelle du bucket
  - Quels dossiers existent déjà dans bucket-table-reseau ?
  - Y a-t-il des fichiers enregistrés sous organisation-{uuid} ?
  - Y a-t-il des fichiers enregistrés sous reseau-{uuid} ?
  - → ça permet de savoir si on doit migrer des fichiers ou juste corriger la logique EF.
- 2/Paramètre fileType
  - Côté front, quel paramètre est envoyé aujourd’hui (type ou fileType) ?
  - Côté EF actuel, quelle clé est utilisée ?
  - → pour qu’on choisisse une seule convention (fileType) et qu’on corrige partout.
- 3/Mapping des champs en base
  - Vérifier dans la table reseau : quels champs stockent les fichiers ? (reseau_logo, reseau_ressources)
  - Vérifier qu’ils pointent bien sur un chemin de bucket basé sur reseau-{uuid}.
- 4/Fonctions d’upload existantes
  - Comment est gérée l’auth aujourd’hui ? (logique JWT à supprimer).
  - Quels headers sont envoyés par le front (Authorization, x-user-id, etc.) ?
- 5/Erreurs récentes
  - Est-ce que Supabase retourne des erreurs "No such file or directory" ou "Token invalide" dans les logs ?
  - → ça aide à confirmer si les bugs viennent bien du mapping ou de l’auth.

### 3/ Résultats de la vérification

#### 1/ Structure actuelle du bucket `bucket-table-reseau`
**RÉSULTAT: BUCKET VIDE**
- ✅ Bucket existe et est accessible
- ❌ **0 fichiers** dans le bucket actuellement
- ❌ **Aucun dossier** `organisation-{uuid}` existant
- ❌ **Aucun dossier** `reseau-{uuid}` existant

**CONCLUSION**: Pas de migration nécessaire, nous partons d'une structure vierge. Il suffit de corriger la logique de l'Edge Function pour utiliser `reseau-{uuid}` dès le début.

---

#### 2/ Paramètre fileType - Frontend vs Edge Function
**RÉSULTAT: UPLOAD NON IMPLÉMENTÉ CÔTÉ FRONTEND**

**Analyse du hook `useReseauFormData.ts`**:
- ✅ Fonction `loadReseaux()` → appelle `gestion-reseau-admin` ✓
- ✅ Fonction `loadReseauData()` → appelle `gestion-reseau-admin-donnees` ✓
- ✅ Fonction `saveReseau()` → appelle `gestion-reseau-admin-update` ✓
- ❌ **MANQUE**: Aucune fonction d'upload de fichiers (logo/documents)
- ❌ **MANQUE**: Aucun appel à `gestion-reseau-admin-fichiers`
- ❌ Recherche `formData.append` → 0 résultats dans tout le code HOOKS-STRATEGIQUE

**Analyse de l'Edge Function actuelle** (`gestion-reseau-admin-fichiers/index.ts`):
```typescript
const fileType = formData.get('fileType') as string  // ligne 44
```
- EF actuelle attend **`fileType`** (correct selon stratégie)
- Mais envoie aussi `type` dans le commentaire ligne 47: "Paramètres manquants: file, reseauId, **fileType** requis"

**CONCLUSION**: 
- Edge Function utilise déjà `fileType` (cohérent avec stratégie)
- Frontend n'a **pas encore implémenté** l'upload
- **Pas de conflit actuel** puisque rien n'envoie de données

---

#### 3/ Mapping des champs en base - Table `reseau`
**RÉSULTAT: CHAMPS EXISTENT MAIS SONT VIDES**

**Requête effectuée**:
```sql
SELECT reseau_id, reseau_nom, reseau_logo, reseau_ressources, organisation_id 
FROM reseau LIMIT 5
```

**Données actuelles**:
| reseau_nom | reseau_id | organisation_id | reseau_logo | reseau_ressources |
|------------|-----------|----------------|-------------|-------------------|
| TEST RESEAU V4 | fd5243b2-... | bd8e1128-... | **NULL** | **NULL** |
| TEST RESEAU V6 | e9d33dea-... | 6e933b02-... | **NULL** | **NULL** |
| TEST18.09.2025 | 18677b89-... | dccf61db-... | **NULL** | **NULL** |

**Structure des colonnes**:
- `reseau_logo` → TEXT (stockera le chemin du fichier logo)
- `reseau_ressources` → ARRAY (stockera les chemins des documents)

**CONCLUSION**: 
- Les champs existent et sont du bon type
- Aucun fichier n'a été uploadé pour l'instant (tous NULL)
- Pas de corruption de données à nettoyer

---

#### 4/ Fonctions d'upload existantes - Authentification actuelle

**Edge Function `gestion-reseau-admin-fichiers` (LIGNE 21-36)**:
```typescript
// ❌ PROBLÈME DÉTECTÉ: Vérification JWT avec Service Role Key
const authHeader = req.headers.get('authorization')
if (!authHeader) throw new Error('Non autorisé')

const token = authHeader.replace('Bearer ', '')
const { data: { user }, error: authError } = await supabaseAdmin.auth.getUser(token)
if (authError || !user) throw new Error('Token invalide')

// Vérifier rôle admin_presenca
const { data: userRole } = await supabaseAdmin
  .from('users')
  .select('users_role_systeme')
  .eq('users_auth_id', user.id)
  .single()
```

**INCOHÉRENCE CRITIQUE**:
1. Config Supabase: `verify_jwt = false` (pas dans config.toml actuellement mais stratégie prévue)
2. Code EF: Tente de décoder un JWT utilisateur avec `supabaseAdmin.auth.getUser(token)`
3. **CONFLIT**: Service Role Key n'est PAS un JWT utilisateur → erreur garantie

**Headers envoyés par le frontend** (analyse du hook):
```typescript
// Dans supabase.functions.invoke(), le header Authorization est automatique:
// Authorization: Bearer <SUPABASE_ANON_KEY> (client standard)
// OU
// Authorization: Bearer <SERVICE_ROLE_KEY> (si configuré manuellement)
```

**CONCLUSION**:
- ❌ Auth actuelle incompatible avec Service Role Key
- ✅ Doit être remplacée par `assertServiceRoleAuth()` + `assertAdminIfProvided()`
- ✅ Pattern identique aux 3 autres Edge Functions corrigées

---

#### 5/ Erreurs récentes dans les logs Supabase

**Requête effectuée**: Logs Edge Function `gestion-reseau-admin-fichiers`

**RÉSULTAT**: 
```
No logs found for edge function 'gestion-reseau-admin-fichiers'.
```

**INTERPRÉTATION**:
- ✅ La fonction n'a **jamais été appelée**
- ✅ Aucune erreur "Token invalide" pour cette fonction (car jamais testée)
- ✅ Aucune erreur "No such file or directory" (car bucket vide et fonction non appelée)

**CONCLUSION**:
- Fonction jamais utilisée en production
- Pas d'historique d'erreurs à analyser
- Corrections peuvent être faites proprement sans impact utilisateur

---

### SYNTHÈSE FINALE DES VÉRIFICATIONS

| Point vérifié | État | Action requise |
|--------------|------|----------------|
| **1. Structure bucket** | ✅ Vide | Implémenter directement avec `reseau-{uuid}` |
| **2. Paramètre fileType** | ⚠️ Non implémenté frontend | Utiliser `fileType` dès l'implémentation |
| **3. Champs en base** | ✅ Prêts (NULL) | Aucune migration nécessaire |https://github.com/Presenca83330/safe-v1-leadgen-ad-builder/blob/main/src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/.Etape4-ProjetFichiersCorrig%C3%A9s.md
| **4. Auth Edge Function** | ❌ Incompatible | Appliquer pattern Service Role Key |
| **5. Erreurs production** | ✅ Aucune | Fonction jamais appelée |

**DÉCISION STRATÉGIQUE**:
1. ✅ **Pas de migration de fichiers** (bucket vide)
2. ✅ **Utiliser `reseau-{uuid}`** dès le début (pas d'organisation-{uuid})
3. ✅ **Standardiser sur `fileType`** (cohérent avec code EF actuel)
4. ✅ **Corriger auth** avec pattern Service Role Key (comme les 3 autres EF)
5. ✅ **Ajouter logs structurés** (requestId, action, reseauId, fileType, path)


### 4/ Solution
- Appliquer la même correction d’auth (pas de check JWT avec Service Role Key).  
- 1/Toujours basé sur JWT (à supprimer)
  - Ne pas utiliser supabaseAdmin.auth.getUser(token)
  - Avec Service Role Key et verify_jwt=false, il n’y a pas de JWT utilisateur
  - Sinon → erreur systématique “Token invalide”
- 2/Vérification admin_presenca 
  - Si userId est fourni → vérifier qu’il est bien admin_presenca
  - Si pas de userId → laisser passer (la vraie barrière est le Service Role Key)
- 3/Logs structurés obligatoires
  - Générer un requestId unique par appel
  - Logguer : requestId, reseauId demandé, erreurs DB, durée de traitement
  - Inclure le nombre et le type d’intégrations trouvées
  - → Ne pas se contenter de console.log(reseauId)
- Uniformiser chemin → `reseau-{uuid}`.  
- Corriger paramètre → **utiliser `fileType`** partout.  
- Corriger auth.  
- Logs : `action=upload/delete, reseauId, fileType, path`.  

### 5/ Etude de code préparatoire corrigé
```typescript
// supabase/functions/gestion-reseau-admin-fichiers/index.ts
// Upload / Delete de fichiers liés à un réseau.
// Stratégie : SERVICE_ROLE_KEY (verify_jwt=false) + contrôle applicatif FACULTATIF (admin_presenca) si user_id fourni.
// AUCUN décodage / validation de JWT utilisateur ici.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { getCorsHeaders } from "../_shared/cors.ts";

type JsonRecord = Record<string, unknown>;

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const BUCKET = "bucket-table-reseau";

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

// --- Types ------------------------------------------------------------------
interface ReseauRow {
  reseau_id: string;
  reseau_logo: string | null;
  reseau_ressources: string[] | null;
  reseau_updated_at?: string;
  reseau_updated_by?: string | null;
}

// --- Utils ------------------------------------------------------------------
function jsonResponse(body: JsonRecord, status = 200, extraHeaders: HeadersInit = {}) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...extraHeaders,
    },
  });
}

function logStructured(event: string, payload: JsonRecord) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

function sanitizeFilename(name: string) {
  return name.replace(/[^a-zA-Z0-9._-]/g, "_");
}

function folderForFileType(fileType: string, requestId: string) {
  const t = (fileType || "").toLowerCase();
  switch (t) {
    case "logo":
      return "1-logos";
    case "document":
    case "doc":
      return "2-documents-institutionnels";
    case "charte":
      return "3-charte-graphique";
    default:
      logStructured("unknown_filetype", { requestId, fileType });
      return "ressources";
  }
}

const UUID_REGEX =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

// --- Sécurité : exiger la SERVICE_ROLE_KEY ----------------------------------
function assertServiceRoleAuth(req: Request, requestId: string) {
  const auth = req.headers.get("authorization") || req.headers.get("Authorization");
  const ok = !!auth && auth.trim().toLowerCase().startsWith("bearer ");
  if (!ok) {
    logStructured("auth_missing_bearer", { requestId });
    return false;
  }
  const token = auth!.replace(/bearer\s+/i, "").trim();
  const match = token === SERVICE_ROLE_KEY;
  if (!match) {
    logStructured("auth_invalid_bearer", { requestId });
  }
  return match;
}

// --- Contrôle applicatif (FACULTATIF) : admin_presenca ----------------------
async function assertAdminIfProvided(userId: string | null, requestId: string) {
  if (!userId) {
    logStructured("admin_check_skipped", { requestId, reason: "no_user_id" });
    return { ok: true, role: "unknown" as const, users_id: null as string | null };
  }
  const { data, error } = await supabase
    .from("users")
    .select("users_role_systeme, users_id")
    .eq("users_auth_id", userId)
    .limit(1)
    .maybeSingle();

  if (error) {
    logStructured("admin_check_error", { requestId, error: error.message });
    return { ok: false as const, role: "error" as const, users_id: null, reason: error.message };
  }
  const isAdmin = data?.users_role_systeme === "admin_presenca";
  if (!isAdmin) {
    logStructured("admin_check_denied", { requestId, userId, role: data?.users_role_systeme ?? null });
    return {
      ok: false as const,
      role: (data?.users_role_systeme ?? "none") as const,
      users_id: null,
      reason: "not_admin_presenca",
    };
  }
  logStructured("admin_check_ok", { requestId, userId, role: "admin_presenca" });
  return { ok: true as const, role: "admin_presenca" as const, users_id: data?.users_id ?? null };
}

// --- DB helpers -------------------------------------------------------------
async function getReseau(reseauId: string): Promise<ReseauRow | null> {
  const { data, error } = await supabase
    .from("reseau")
    .select("reseau_id, reseau_logo, reseau_ressources")
    .eq("reseau_id", reseauId)
    .maybeSingle();
  if (error) throw new Error(`db_error_reseau_fetch:${error.message}`);
  return data as ReseauRow | null;
}

async function setReseauLogo(reseauId: string, path: string | null, users_id: string | null) {
  const { error } = await supabase
    .from("reseau")
    .update({
      reseau_logo: path,
      reseau_updated_at: new Date().toISOString(),
      reseau_updated_by: users_id,
    })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`db_error_reseau_logo_update:${error.message}`);
}

async function addReseauRessource(reseauId: string, path: string, current: string[] | null, users_id: string | null) {
  const next = Array.isArray(current) ? Array.from(new Set([...current, path])) : [path];
  const { error } = await supabase
    .from("reseau")
    .update({
      reseau_ressources: next,
      reseau_updated_at: new Date().toISOString(),
      reseau_updated_by: users_id,
    })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`db_error_reseau_ressources_update:${error.message}`);
}

async function removeReseauRessource(reseauId: string, path: string, current: string[] | null, users_id: string | null) {
  const next = (Array.isArray(current) ? current : []).filter((p) => p !== path);
  const { error } = await supabase
    .from("reseau")
    .update({
      reseau_ressources: next,
      reseau_updated_at: new Date().toISOString(),
      reseau_updated_by: users_id,
    })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`db_error_reseau_ressources_update:${error.message}`);
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();
  const origin = req.headers.get("origin") || "*";
  const corsHeaders = getCorsHeaders(origin);

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  if (!assertServiceRoleAuth(req, requestId)) {
    return jsonResponse({ ok: false, error: "unauthorized_service_role_required", requestId }, 401, corsHeaders);
  }

  try {
    const t0 = performance.now();
    const contentType = req.headers.get("content-type") || "";

    // Récupération userId (flexible)
    let userId: string | null = req.headers.get("x-user-id");
    let bodyUserId: string | null = null;

    // --- Upload (multipart/form-data) --------------------------------------
    if (req.method === "POST" && contentType.toLowerCase().includes("multipart/form-data")) {
      const form = await req.formData();

      const reseauId = (form.get("reseau_id") || form.get("reseauId")) as string | null;
      const fileType = form.get("fileType") as string | null;
      const legacyType = (form.get("type") as string | null) || null;
      const finalType = fileType || legacyType;
      const file = form.get("file") as File | null;
      const providedUserId = (form.get("user_id") as string | null) || null;

      if (!reseauId) return jsonResponse({ ok: false, error: "bad_request_missing_reseau_id", requestId }, 400, corsHeaders);
      if (!UUID_REGEX.test(reseauId)) return jsonResponse({ ok: false, error: "invalid_reseau_id", requestId }, 400, corsHeaders);
      if (!finalType) return jsonResponse({ ok: false, error: "bad_request_missing_fileType", requestId }, 400, corsHeaders);
      if (!file) return jsonResponse({ ok: false, error: "bad_request_missing_file", requestId }, 400, corsHeaders);

      if (!userId && providedUserId) userId = providedUserId;
      if (!fileType && legacyType) {
        logStructured("legacy_param_used", { requestId, param: "type", value: legacyType });
      }

      const adminCheck = await assertAdminIfProvided(userId, requestId);
      if (!adminCheck.ok) {
        return jsonResponse({ ok: false, error: "forbidden_not_admin_presenca", requestId, role: adminCheck.role }, 403, corsHeaders);
      }

      const folder = folderForFileType(finalType, requestId);
      const safeName = sanitizeFilename(file.name || "file");
      const stamp = Date.now();
      const path = `reseau-${reseauId}/${folder}/${stamp}_${safeName}`;

      const { error: upErr } = await supabase.storage
        .from(BUCKET)
        .upload(path, file, {
          contentType: file.type || "application/octet-stream",
          upsert: false, // stricte → pas d'écrasement
        });

      if (upErr) {
        const durationMs = Math.round(performance.now() - t0);
        logStructured("storage_upload_error", { requestId, reseau_id: reseauId, fileType: finalType, path, error: upErr.message, duration_ms: durationMs });
        return jsonResponse({ ok: false, error: "storage_upload_error", details: upErr.message, requestId }, 500, corsHeaders);
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        await supabase.storage.from(BUCKET).remove([path]).catch(() => {});
        return jsonResponse({ ok: false, error: "not_found_reseau", requestId }, 404, corsHeaders);
      }

      if (folder === "1-logos") {
        await setReseauLogo(reseauId, path, adminCheck.users_id);
      } else if (folder === "2-documents-institutionnels") {
        await addReseauRessource(reseauId, path, reseau.reseau_ressources, adminCheck.users_id);
      }

      const durationMs = Math.round(performance.now() - t0);
      logStructured("storage_upload_ok", { requestId, reseau_id: reseauId, fileType: finalType, path, duration_ms: durationMs, admin_role: adminCheck.role });

      return jsonResponse({ ok: true, requestId, action: "upload", reseau_id: reseauId, fileType: finalType, path }, 200, corsHeaders);
    }

    // --- Delete (application/json) -----------------------------------------
    if (req.method === "POST" && contentType.toLowerCase().includes("application/json")) {
      let body: any = {};
      try {
        body = await req.json();
      } catch {
        return jsonResponse({ ok: false, error: "bad_request_invalid_json", requestId }, 400, corsHeaders);
      }

      const action = (body?.action as string | null)?.toLowerCase();
      const reseauId = (body?.reseau_id ?? body?.reseauId) as string | null;
      const fileType = body?.fileType as string | null;
      const legacyType = (body?.type as string | null) || null;
      const finalType = fileType || legacyType;
      const path = body?.path as string | null;
      bodyUserId = (body?.user_id as string | null) ?? null;

      if (!reseauId) return jsonResponse({ ok: false, error: "bad_request_missing_reseau_id", requestId }, 400, corsHeaders);
      if (!UUID_REGEX.test(reseauId)) return jsonResponse({ ok: false, error: "invalid_reseau_id", requestId }, 400, corsHeaders);
      if (action !== "delete") return jsonResponse({ ok: false, error: "bad_request_invalid_action", requestId }, 400, corsHeaders);
      if (!path) return jsonResponse({ ok: false, error: "bad_request_missing_path", requestId }, 400, corsHeaders);

      if (!userId && bodyUserId) userId = bodyUserId;
      if (!fileType && legacyType) {
        logStructured("legacy_param_used", { requestId, param: "type", value: legacyType });
      }

      const adminCheck = await assertAdminIfProvided(userId, requestId);
      if (!adminCheck.ok) {
        return jsonResponse({ ok: false, error: "forbidden_not_admin_presenca", requestId, role: adminCheck.role }, 403, corsHeaders);
      }

      const { error: rmErr } = await supabase.storage.from(BUCKET).remove([path]);
      if (rmErr) {
        const durationMs = Math.round(performance.now() - t0);
        logStructured("storage_delete_error", { requestId, reseau_id: reseauId, fileType: finalType, path, error: rmErr.message, duration_ms: durationMs });
        return jsonResponse({ ok: false, error: "storage_delete_error", details: rmErr.message, requestId }, 500, corsHeaders);
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        return jsonResponse({ ok: false, error: "not_found_reseau", requestId }, 404, corsHeaders);
      }

      const folder = finalType ? folderForFileType(finalType, requestId) : "";
      if (folder === "1-logos" && reseau.reseau_logo === path) {
        await setReseauLogo(reseauId, null, adminCheck.users_id);
      } else if (folder === "2-documents-institutionnels") {
        await removeReseauRessource(reseauId, path, reseau.reseau_ressources, adminCheck.users_id);
      }

      const durationMs = Math.round(performance.now() - t0);
      logStructured("storage_delete_ok", { requestId, reseau_id: reseauId, fileType: finalType, path, duration_ms: durationMs, admin_role: adminCheck.role });

      return jsonResponse({ ok: true, requestId, action: "delete", reseau_id: reseauId, fileType: finalType, path }, 200, corsHeaders);
    }

    return jsonResponse({ ok: false, error: "unsupported_request", requestId }, 400, corsHeaders);
  } catch (e) {
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) });
    return jsonResponse({ ok: false, error: "internal_error", requestId }, 500);
  }
});

```
---
---

---

## 5. Hooks – `useReseauFormData.ts`
### 1/ Problème
- Dépendance totale aux EF → si erreur, l’UI reste vide sans diagnostic clair.  
### 2/ Vérifications préalables
- Tester manuellement l’appel `supabase.functions.invoke('gestion-reseau-admin')` en CLI.  
### 3/ Solution
- Ajouter gestion d’erreur plus explicite (toast : “Vérifiez vos droits admin_presenca”).  
- Logguer côté front les réponses brutes pour debug.
### 4/ Décision 
- On conserve le fichier actuel et éviter de corriger des points de détails

### 5/ Rappel du fichier maintenu
```typescript
 import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import type { ReseauFormData, ReseauSelectorItem, ValidationErrors } from './types';

export function useReseauFormData() {
  const [reseaux, setReseaux] = useState<ReseauSelectorItem[]>([]);
  const [selectedReseauId, setSelectedReseauId] = useState<string>('');
  const [formData, setFormData] = useState<Partial<ReseauFormData>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [errors, setErrors] = useState<ValidationErrors>({});
  const { toast } = useToast();

  /**
   * 🔑 SERVICE_ROLE_KEY - Charger la liste des réseaux (sélecteur dropdown)
   */
  const loadReseaux = useCallback(async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin');
      if (error) throw error;
      setReseaux(data || []);
    } catch {
      toast({
        title: 'Erreur',
        description: 'Impossible de charger les réseaux',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  /**
   * 🔑 SERVICE_ROLE_KEY - Charger les données complètes d'un réseau sélectionné
   */
  const loadReseauData = useCallback(
    async (reseauId: string) => {
      if (!reseauId) return;
      setIsLoading(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {
          body: { reseauId }
        });
        if (error) throw error;
        
        if (!data?.reseau) {
          setFormData({});
          toast({
            title: 'Introuvable',
            description: 'Réseau introuvable',
            variant: 'destructive',
          });
          return;
        }

        setFormData(data.reseau);
        setErrors({});
      } catch {
        toast({
          title: 'Erreur',
          description: 'Impossible de charger les données du réseau',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  /**
   * Validation côté frontend avant sauvegarde
   * ⚠️ Dans le formulaire de gestion → uniquement des validations de forme.
   * (Les champs étaient obligatoires uniquement lors de la création.)
   */
  const validateForm = useCallback(
    (data: Partial<ReseauFormData>): ValidationErrors => {
      const newErrors: ValidationErrors = {};

      if (data.reseau_code_postal && !/^\d{5}$/.test(data.reseau_code_postal)) {
        newErrors.reseau_code_postal =
          'Le code postal doit contenir 5 chiffres';
      }

      if (data.reseau_siret && !/^\d{14}$/.test(data.reseau_siret.replace(/\s/g, ''))) {
        newErrors.reseau_siret = 'Le SIRET doit contenir 14 chiffres';
      }

      return newErrors;
    },
    []
  );

  /**
   * 🔑 SERVICE_ROLE_KEY - Sauvegarder les données d'un réseau
   */
  const saveReseau = useCallback(
    async (dataToSave: Partial<ReseauFormData>) => {
      if (!selectedReseauId) return false;

      const validationErrors = validateForm(dataToSave);
      setErrors(validationErrors);
      if (Object.keys(validationErrors).length > 0) {
        toast({
          title: 'Erreurs de validation',
          description: 'Veuillez corriger les erreurs',
          variant: 'destructive',
        });
        return false;
      }

      setIsSaving(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {
          body: { 
            reseauId: selectedReseauId,
            generalData: dataToSave 
          }
        });
        if (error) throw error;

        toast({
          title: 'Succès',
          description: 'Réseau mis à jour avec succès',
        });
        await loadReseauData(selectedReseauId);
        return true;
      } catch {
        toast({
          title: 'Erreur',
          description: 'Impossible de sauvegarder les modifications',
          variant: 'destructive',
        });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [selectedReseauId, validateForm, toast, loadReseauData]
  );

  /**
   * Mise à jour d'un champ dans l'état local
   */
  const updateFormField = useCallback(
    (field: keyof ReseauFormData | string, value: any) => {
      setFormData((prev) => ({ ...prev, [field]: value }));
      if (errors[field]) {
        setErrors((prev) => {
          const e = { ...prev };
          delete e[field];
          return e;
        });
      }
    },
    [errors]
  );

  /**
   * Sélection d'un réseau dans le dropdown
   */
  const selectReseau = useCallback(
    (reseauId: string) => {
      setSelectedReseauId(reseauId);
      if (reseauId) {
        loadReseauData(reseauId);
      } else {
        setFormData({});
        setErrors({});
      }
    },
    [loadReseauData]
  );

  return {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    validateForm,
    loadReseauData,
  };
}
```
---

## 6. Hooks – `useReseauIntegrations.ts`
### 1/ Problème
- Dépendance aux EF sans contrôle si l’ID d’intégration est absent.  
- Logs limités.  
### 2/ Vérifications préalables
- Vérifier cohérence entre `reseau.reseau_brevo_connexion_id` et la table `brevo_connexion`.  
### 3/ Solution
- Ajouter logs front en cas d’intégration absente.  -> en attente
- Utiliser la donnée retournée par l’EF au lieu de recharger systématiquement (optimisation déjà amorcée).-> en attente

### 4/ Code correctif proposé 
```typescript
import { useCallback, useRef, useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { supabase } from "@/integrations/supabase/client";
import type { BrevoFormState, ZohoFormState, OpenAIFormState } from "./types";

export function useReseauIntegrations() {
  const { toast } = useToast();

  // organisation_id (non bloquant pour la sauvegarde)
  const [organisationId, setOrganisationId] = useState<string | null>(null);

  // États UI (formulaires)
  const [brevo, setBrevo] = useState<BrevoFormState>({});
  const [zoho, setZoho] = useState<ZohoFormState>({});
  const [openai, setOpenAI] = useState<OpenAIFormState>({});

  // IDs techniques
  const [brevoConnexionId, setBrevoConnexionId] = useState<string | null>(null);
  const [zohoConnexionId, setZohoConnexionId] = useState<string | null>(null);
  const [openaiConnexionId, setOpenaiConnexionId] = useState<string | null>(null);

  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // 🔒 Référence pour éviter race conditions
  const currentReseauRef = useRef<string | null>(null);

  // ================================
  // Charger les intégrations d'un réseau
  // ================================
  const loadForReseau = useCallback(
    async (reseauId: string) => {
      if (!reseauId) return;
      setIsLoading(true);
      currentReseauRef.current = reseauId;

      try {
        const { data, error } = await supabase.functions.invoke(
          "gestion-reseau-admin-donnees",
          {
            body: { reseauId },
          }
        );
        if (error) throw error;

        // Race condition : si changement de réseau entre temps
        if (currentReseauRef.current !== reseauId) {
          return;
        }

        if (!data?.reseau) {
          // Reset states
          setOrganisationId(null);
          setBrevo({});
          setZoho({});
          setOpenAI({});
          setBrevoConnexionId(null);
          setZohoConnexionId(null);
          setOpenaiConnexionId(null);
          return;
        }

        const reseau = data.reseau;
        const integrations = data.integrations;

        setOrganisationId(reseau.organisation_id);
        setBrevo(integrations?.brevo || {});
        setZoho(integrations?.zoho || {});
        setOpenAI(integrations?.openai || {});
        setBrevoConnexionId(reseau.reseau_brevo_connexion_id);
        setZohoConnexionId(reseau.reseau_zoho_connexion_id);
        setOpenaiConnexionId(reseau.reseau_openai_connexion_id);
      } catch (e: any) {
        console.error("Erreur loadForReseau", e);
        toast({
          title: "Erreur",
          description: "Impossible de charger les intégrations",
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  // ================================
  // Sauvegarde d'une intégration
  // ================================
  const saveIntegration = useCallback(
    async (reseauId: string, kind: "brevo" | "zoho" | "openai") => {
      if (!reseauId) return false;

      setIsSaving(true);
      currentReseauRef.current = reseauId;

      try {
        let state: BrevoFormState | ZohoFormState | OpenAIFormState;
        switch (kind) {
          case "brevo":
            state = brevo;
            break;
          case "zoho":
            state = zoho;
            break;
          case "openai":
            state = openai;
            break;
        }

        const { data, error } = await supabase.functions.invoke(
          "gestion-reseau-admin-update",
          {
            body: {
              reseauId,
              integrationKind: kind,
              integrationData: state,
            },
          }
        );
        if (error) throw error;

        const updatedIntegration = data?.updatedData?.integrations?.[kind];

        // Race condition : si changement de réseau en plein save
        if (currentReseauRef.current !== reseauId) {
          return false;
        }

        if (updatedIntegration) {
          switch (kind) {
            case "brevo":
              setBrevo({
                brevo_api_key: updatedIntegration.brevo_api_key,
                brevo_email_compte: updatedIntegration.brevo_email_compte,
                brevo_nom_compte: updatedIntegration.brevo_nom_compte,
              });
              setBrevoConnexionId(updatedIntegration.brevo_connexion_id);
              break;
            case "zoho":
              setZoho({
                zoho_api_key: updatedIntegration.zoho_api_key,
                zoho_email_compte: updatedIntegration.zoho_email_compte,
                zoho_nom_compte: updatedIntegration.zoho_nom_compte,
              });
              setZohoConnexionId(updatedIntegration.zoho_connexion_id);
              break;
            case "openai":
              setOpenAI({
                openai_api_key: updatedIntegration.openai_api_key,
                openai_email_compte: updatedIntegration.openai_email_compte,
              });
              setOpenaiConnexionId(updatedIntegration.openai_connexion_id);
              break;
          }

          toast({
            title: "Succès",
            description: `Intégration ${kind} mise à jour avec succès`,
          });
          return true;
        } else {
          toast({
            title: "Erreur",
            description: `La mise à jour de l’intégration ${kind} n’a pas été confirmée par le serveur.`,
            variant: "destructive",
          });
          return false;
        }
      } catch (e: any) {
        console.error(`Erreur saveIntegration ${kind}`, e);
        toast({
          title: "Erreur",
          description:
            e?.message || "Impossible de sauvegarder l'intégration",
          variant: "destructive",
        });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [brevo, zoho, openai, toast]
  );

  return {
    organisationId,
    // États UI
    brevo,
    setBrevo,
    zoho,
    setZoho,
    openai,
    setOpenAI,
    // IDs techniques
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    // Meta
    isLoading,
    isSaving,
    // Actions
    loadForReseau,
    saveIntegration,
  };
}

```
---
---

## 7. Composant – `ReseauSelector.tsx`
### 1/ Problème
- Si la liste des réseaux est vide, aucun message explicite.
- Besoin de deux informations dans le sélecteur pour permettre à admin_presenca de sélectionner son réseau
  - reseau_nom
  - reseau_id
### 2/ Vérifications préalables
- Valider que `reseau` contient bien des données côté front après appel EF.  
### 3/ Solution
- on ne modifie rien pour l instant
- on modifie src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/types.ts
- avec deux champs : nom et id

### 4/ Code maintenu
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import type { ReseauSelectorItem } from '../hooks/types';

interface ReseauSelectorProps {
  reseaux: ReseauSelectorItem[];
  selectedReseauId: string;
  onSelect: (reseauId: string) => void;
  isLoading: boolean;
}

export const ReseauSelector: React.FC<ReseauSelectorProps> = ({
  reseaux,
  selectedReseauId,
  onSelect,
  isLoading,
}) => {
  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="text-xl font-semibold">Sélection du Réseau</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          <Select
            value={selectedReseauId}
            onValueChange={onSelect}
            disabled={isLoading}
          >
            <SelectTrigger className="w-full">
              <SelectValue 
                placeholder={
                  isLoading ? "Chargement des réseaux..." : 
                  "Sélectionner un réseau"
                } 
              />
            </SelectTrigger>
            <SelectContent>
              {reseaux?.map((reseau) => (
                <SelectItem key={reseau.reseau_id} value={reseau.reseau_id}>
                  {reseau.reseau_nom}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardContent>
    </Card>
  );
};

export default ReseauSelector;
```
---
## 8. Hook  – `types.ts`
### 1/ Problème
- Besoin de deux informations dans le sélecteur pour permettre à admin_presenca de sélectionner son réseau
  - reseau_nom
  - reseau_id
### 2/ Vérifications préalables
-  
### 3/ Solution
- 

### 4/ Code correctif
```typescript
// Types partagés pour la gestion des réseaux

// ==============================
// Données du Réseau
// ==============================
export interface ReseauFormData {
  reseau_id: string;
  organisation_id: string;
  reseau_nom: string;
  reseau_identite_commerciale?: string | null;
  reseau_adresse?: string | null;
  reseau_code_postal?: string | null;
  reseau_ville?: string | null;
  reseau_siret?: string | null;
  reseau_statut?: string | null;
  reseau_logo?: string | null;
  reseau_ressources?: string[]; // fichiers stockés
  reseau_telephone?: string | null; // Point de vérité
  reseau_email?: string | null;     // Point de vérité
  reseau_brevo_connexion_id?: string | null;
  reseau_zoho_connexion_id?: string | null;
  reseau_openai_connexion_id?: string | null;
}

// ==============================
// Eléments pour le sélecteur
// ==============================
// ⚠️ Minimal : uniquement les champs nécessaires pour le dropdown
export interface ReseauSelectorItem {
  reseau_nom: string;
  reseau_id: string;
}

// ==============================
// Intégrations - Tables connexions
// ==============================
export interface BrevoIntegration {
  brevo_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  brevo_api_key?: string | null;
  brevo_email_compte?: string | null;
  brevo_nom_compte?: string | null;
}

export interface ZohoIntegration {
  zoho_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  zoho_api_key?: string | null;
  zoho_email_compte?: string | null;
  zoho_nom_compte?: string | null;
}

export interface OpenAIIntegration {
  openai_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  openai_api_key?: string | null;
  openai_email_compte?: string | null;
}

// ==============================
// Etats du formulaire (Front) - UI UNIQUEMENT
// ==============================
export interface BrevoFormState {
  brevo_api_key?: string;
  brevo_email_compte?: string;
  brevo_nom_compte?: string;
}

export interface ZohoFormState {
  zoho_api_key?: string;
  zoho_email_compte?: string;
  zoho_nom_compte?: string;
}

export interface OpenAIFormState {
  openai_api_key?: string;
  openai_email_compte?: string;
}

export interface IntegrationsState {
  brevo: BrevoFormState;
  zoho: ZohoFormState;
  openai: OpenAIFormState;
}

// ==============================
// Erreurs de validation
// ==============================
export type ValidationErrors = {
  [K in keyof Partial<ReseauFormData>]?: string;
};

```
---
---

## 9. Fichier – `3.FormReseauGestion.tsx`
### 1/ Problème
- Upload envoie `type` au lieu de `fileType`.  
- Risque de mismatch avec EF.  
### 2/ Vérifications préalables
### 3/ Solution
- Corriger paramètre → `fd.append('fileType', type)`.  
- Ajouter gestion d’erreur explicite en cas d’upload raté.
### 4/ Proposition de code corrigé
```typescript
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../../3-Utilitaires/tabs";
import { Upload, Download, Trash2, Eye } from 'lucide-react';
import GraphBoutonModifier from '../../5-Graphisme/1.GraphFormulaires/5.GraphBoutonModifier';
import { ReseauSelector } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector';
import { useReseauFormData } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData';
import { useReseauIntegrations } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

interface Props {
  onBack?: () => void;
}

const FormReseauGestion: React.FC<Props> = ({ onBack }) => {
  const { toast } = useToast();

  const {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    loadReseauData,
  } = useReseauFormData();

  const {
    brevo, setBrevo,
    zoho, setZoho,
    openai, setOpenAI,
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    isLoading: integLoading,
    isSaving: integSaving,
    loadForReseau,
    saveIntegration,
  } = useReseauIntegrations();

  const [isEditingGeneral, setIsEditingGeneral] = useState(false);
  const [isEditingBrevo, setIsEditingBrevo] = useState(false);
  const [isEditingZoho, setIsEditingZoho] = useState(false);
  const [isEditingOpenAI, setIsEditingOpenAI] = useState(false);
  const [isEditingLogo, setIsEditingLogo] = useState(false);
  const [isEditingDocuments, setIsEditingDocuments] = useState(false);

  const logoInputRef = useRef<HTMLInputElement | null>(null);
  const docsInputRef = useRef<HTMLInputElement | null>(null);
  const [selectedLogo, setSelectedLogo] = useState<File | null>(null);
  const [selectedDocs, setSelectedDocs] = useState<File[]>([]);

  useEffect(() => { loadReseaux(); }, [loadReseaux]);
  useEffect(() => { if (selectedReseauId) loadForReseau(selectedReseauId); }, [selectedReseauId, loadForReseau]);

  const handleSaveGeneral = async () => {
    if (!selectedReseauId) return;
    const success = await saveReseau({
      reseau_nom: formData.reseau_nom,
      reseau_identite_commerciale: formData.reseau_identite_commerciale,
      reseau_adresse: formData.reseau_adresse,
      reseau_code_postal: formData.reseau_code_postal,
      reseau_ville: formData.reseau_ville,
      reseau_siret: formData.reseau_siret,
      reseau_telephone: formData.reseau_telephone,
      reseau_email: formData.reseau_email,
    });
    if (success) setIsEditingGeneral(false);
  };

  const handleSaveBrevo = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'brevo'); if (ok) setIsEditingBrevo(false); };
  const handleSaveZoho = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'zoho'); if (ok) setIsEditingZoho(false); };
  const handleSaveOpenAI = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'openai'); if (ok) setIsEditingOpenAI(false); };

  const reloadAll = async () => {
    if (selectedReseauId) {
      await loadReseauData(selectedReseauId);
      await loadForReseau(selectedReseauId);
      setSelectedLogo(null);
      setSelectedDocs([]);
    }
  };

  // --- CORRIGÉ : fileType + reseau_id + lecture data.path ---
  const uploadFile = async (type: 'logo' | 'document', file: File, reseauId: string) => {
    const fd = new FormData();
    fd.append('file', file);
    fd.append('fileType', type);      // <-- était 'type'
    fd.append('reseau_id', reseauId); // <-- compat max avec l’EF (supporte aussi reseauId)
    const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', { body: fd });
    if (error) throw error;
    return (data as any)?.path as string; // <-- était 'filePath'
  };

  const handleSaveLogo = async () => {
    if (!selectedReseauId || !selectedLogo) { setIsEditingLogo(false); return; }
    try {
      const path = await uploadFile('logo', selectedLogo, selectedReseauId);
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_logo: path } },
      });
      toast({ title: 'Succès', description: 'Logo mis à jour' });
      await reloadAll();
      setIsEditingLogo(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader le logo", variant: 'destructive' });
    }
  };

  const handleSaveDocuments = async () => {
    if (!selectedReseauId) { setIsEditingDocuments(false); return; }
    try {
      const paths: string[] = [];
      for (const f of selectedDocs) {
        paths.push(await uploadFile('document', f, selectedReseauId));
      }
      const next = Array.isArray(formData.reseau_ressources) ? [...formData.reseau_ressources, ...paths] : paths;
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_ressources: next } },
      });
      toast({ title: 'Succès', description: 'Documents mis à jour' });
      await reloadAll();
      setIsEditingDocuments(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader les documents", variant: 'destructive' });
    }
  };

  // --- CORRIGÉ : suppression via POST JSON (action: 'delete') ---
  const removeStoragePath = async (path: string, reseauId: string, type: 'logo' | 'document') => {
    const { error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', {
      body: { action: 'delete', reseau_id: reseauId, fileType: type, path }
    });
    if (error) throw error;
  };

  const handleDeleteLogo = async () => {
    if (!selectedReseauId || !formData.reseau_logo) return;
    try {
      await removeStoragePath(formData.reseau_logo, selectedReseauId, 'logo');
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_logo: null } },
      });
      toast({ title: 'Succès', description: 'Logo supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression logo impossible', variant: 'destructive' });
    }
  };

  const handleDeleteDocument = async (docPath: string) => {
    if (!selectedReseauId) return;
    try {
      await removeStoragePath(docPath, selectedReseauId, 'document');
      const remaining = (formData.reseau_ressources || []).filter(p => p !== docPath);
      await supabase.functions.invoke('gestion-reseau-admin-update', {
        body: { reseauId: selectedReseauId, generalData: { reseau_ressources: remaining } },
      });
      toast({ title: 'Succès', description: 'Document supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression document impossible', variant: 'destructive' });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); };

  return (
    <div className="space-y-6">
      <ReseauSelector
        reseaux={reseaux}
        selectedReseauId={selectedReseauId}
        onSelect={selectReseau}
        isLoading={isLoading}
      />

      <Tabs defaultValue="general" className="w-full">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="general" className="text-base font-semibold">Général</TabsTrigger>
          <TabsTrigger value="integrations" className="text-base font-semibold">Intégrations</TabsTrigger>
          <TabsTrigger value="fichiers" className="text-base font-semibold">Fichiers</TabsTrigger>
        </TabsList>

        <form onSubmit={handleSubmit}>
          {/* ✅ Informations Générales */}
          <TabsContent value="general" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">Informations Générales</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveGeneral}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingGeneral}
                    isLoading={isSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_nom">Nom du Réseau</Label>
                      <Input
                        id="reseau_nom"
                        value={formData.reseau_nom || ''}
                        onChange={e => updateFormField('reseau_nom', e.target.value)}
                        placeholder="Nom du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_identite_commerciale">Identité Commerciale du Réseau</Label>
                      <Input
                        id="reseau_identite_commerciale"
                        value={formData.reseau_identite_commerciale || ''}
                        onChange={e => updateFormField('reseau_identite_commerciale', e.target.value)}
                        placeholder="Optionnel. Si Nom Commercial différent"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_adresse">Adresse</Label>
                      <Input
                        id="reseau_adresse"
                        value={formData.reseau_adresse || ''}
                        onChange={e => updateFormField('reseau_adresse', e.target.value)}
                        placeholder="Adresse. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_code_postal">Code Postal</Label>
                      <Input
                        id="reseau_code_postal"
                        value={formData.reseau_code_postal || ''}
                        onChange={e => updateFormField('reseau_code_postal', e.target.value)}
                        placeholder="Code Postal. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_ville">Ville</Label>
                      <Input
                        id="reseau_ville"
                        value={formData.reseau_ville || ''}
                        onChange={e => updateFormField('reseau_ville', e.target.value)}
                        placeholder="Ville. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_siret">Siret</Label>
                      <Input
                        id="reseau_siret"
                        value={formData.reseau_siret || ''}
                        onChange={e => updateFormField('reseau_siret', e.target.value)}
                        placeholder="N° Siret du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_telephone">Téléphone Direction</Label>
                      <Input
                        id="reseau_telephone"
                        value={formData.reseau_telephone || ''}
                        onChange={e => updateFormField('reseau_telephone', e.target.value)}
                        placeholder="Tél. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_email">Email Direction</Label>
                      <Input
                        id="reseau_email"
                        type="email"
                        value={formData.reseau_email || ''}
                        onChange={e => updateFormField('reseau_email', e.target.value)}
                        placeholder="Email. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Intégrations */}
          <TabsContent value="integrations" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Brevo</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveBrevo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingBrevo}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="brevo_api_key">Clé API Brevo</Label>
                    <Input
                      id="brevo_api_key"
                      type="password"
                      placeholder="Renseigner. N° Clé API"
                      value={brevo.brevo_api_key || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_api_key: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_email_compte">Email Compte Brevo</Label>
                    <Input
                      id="brevo_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Brevo"
                      value={brevo.brevo_email_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_email_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_nom_compte">Nom Compte Brevo</Label>
                    <Input
                      id="brevo_nom_compte"
                      placeholder="Renseigner. Nom compte Brevo"
                      value={brevo.brevo_nom_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_nom_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Zoho</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveZoho}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingZoho}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="zoho_api_key">Clé API Zoho</Label>
                    <Input
                      id="zoho_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API Zoho"
                      value={zoho.zoho_api_key || ''}
                      onChange={e => setZoho({ ...zoho, zoho_api_key: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_email_compte">Email Compte Zoho</Label>
                    <Input
                      id="zoho_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Zoho"
                      value={zoho.zoho_email_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_email_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_nom_compte">Nom Compte Zoho</Label>
                    <Input
                      id="zoho_nom_compte"
                      placeholder="Renseigner. Nom compte Zoho"
                      value={zoho.zoho_nom_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_nom_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration OpenAI</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveOpenAI}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingOpenAI}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="openai_api_key">Clé API OpenAI</Label>
                    <Input
                      id="openai_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API OpenAI"
                      value={openai.openai_api_key || ''}
                      onChange={e => setOpenAI({ ...openai, openai_api_key: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                  <div>
                    <Label htmlFor="openai_email_compte">Email Compte OpenAI</Label>
                    <Input
                      id="openai_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte OpenAI"
                      value={openai.openai_email_compte || ''}
                      onChange={e => setOpenAI({ ...openai, openai_email_compte: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Fichiers - STRUCTURE 2 CARTES SÉPARÉES */}
          <TabsContent value="fichiers" className="space-y-6">
            {/* 🎨 CARTE 1 : Logo du Réseau */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">
                    Logo du Réseau
                  </CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveLogo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingLogo}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="reseau_logo_upload">Télécharger le Logo du Réseau</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingLogo && logoInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Upload className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner le logo</p>
                          <p className="text-xs text-muted-foreground">PNG, JPG, SVG - Max 2MB</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={logoInputRef}
                      id="reseau_logo_upload"
                      type="file"
                      accept="image/*"
                      hidden
                      disabled={!isEditingLogo}
                      onChange={e => setSelectedLogo(e.target.files?.[0] || null)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Logo actuel</Label>
                    <div className="border rounded-lg p-4 bg-muted/20">
                      {formData.reseau_logo ? (
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <div className="w-16 h-16 border rounded bg-white flex items-center justify-center">
                              <Upload className="h-5 w-5 text-muted-foreground" />
                            </div>
                            <div>
                              <p className="font-medium break-all">{formData.reseau_logo}</p>
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Button
                              type="button"
                              variant="destructive"
                              size="sm"
                              onClick={handleDeleteLogo}
                              disabled={!isEditingLogo}
                            >
                              Supprimer
                            </Button>
                          </div>
                        </div>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun logo uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* 📄 CARTE 2 : Documents Institutionnels */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">
                    Documents Institutionnels
                  </CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveDocuments}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingDocuments}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label>Télécharger les documents</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingDocuments && docsInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Download className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner les documents</p>
                          <p className="text-xs text-muted-foreground">PDF, DOC, DOCX - Max 10MB par fichier</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={docsInputRef}
                      type="file"
                      multiple
                      accept=".pdf,.doc,.docx,.xls,.xlsx"
                      hidden
                      disabled={!isEditingDocuments}
                      onChange={e => setSelectedDocs(e.target.files ? Array.from(e.target.files) : [])}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Supprimer un fichier existant</Label>
                    <div className="border rounded-lg p-4 bg-muted/20 space-y-3">
                      {formData.reseau_ressources && formData.reseau_ressources.length > 0 ? (
                        <>
                          {formData.reseau_ressources.map((p) => (
                            <div key={p} className="flex items-center justify-between p-3 border rounded bg-white">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-blue-100 rounded flex items-center justify-center">
                                  <Download className="h-4 w-4 text-blue-600" />
                                </div>
                                <div className="max-w-[60ch]">
                                  <p className="font-medium break-all">{p}</p>
                                </div>
                              </div>
                              <div className="flex gap-2">
                                <Button
                                  type="button"
                                  variant="outline"
                                  size="sm"
                                  onClick={async () => {
                                    const { data } = await supabase.storage
                                      .from('bucket-table-reseau')
                                      .createSignedUrl(p, 60);
                                    if (data?.signedUrl) window.open(data.signedUrl, '_blank');
                                  }}
                                >
                                  <Eye className="h-4 w-4 mr-1" />
                                  Voir
                                </Button>
                                <Button
                                  type="button"
                                  variant="destructive"
                                  size="sm"
                                  onClick={() => handleDeleteDocument(p)}
                                  disabled={!isEditingDocuments}
                                >
                                  <Trash2 className="h-4 w-4 mr-1" />
                                  Supprimer
                                </Button>
                              </div>
                            </div>
                          ))}
                        </>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun document uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </form>
      </Tabs>

      {onBack && (
        <div className="pt-6">
          <Button type="button" variant="outline" onClick={onBack}>
            ← Retour
          </Button>
        </div>
      )}
    </div>
  );
};

export default FormReseauGestion;

```

---
---
## 10. MIGRATION COMPLETE SQL – `  Migration SQL complète - Réseau / Direction / Bucket`
### 1/ Code 
```typescript
-- ============================================================
-- 📌 Migration SQL complète - Réseau / Direction / Bucket
-- ============================================================

-- ============================================================
-- 1. Fonction utilitaire : get_user_reseau_id()
-- ============================================================
CREATE OR REPLACE FUNCTION public.get_user_reseau_id(user_uuid uuid)
RETURNS uuid
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path TO public
AS $$
  SELECT r.reseau_id
  FROM reseau r
  WHERE r.organisation_id = get_user_organisation_id(user_uuid)
  LIMIT 1;
$$;

-- ============================================================
-- 2. Fonction de synchronisation reseau → reseau_direction
-- ============================================================
CREATE OR REPLACE FUNCTION public.sync_reseau_to_direction()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
BEGIN
  UPDATE reseau_direction
  SET 
    reseau_direction_email = NEW.reseau_email,
    reseau_direction_telephone = NEW.reseau_telephone,
    reseau_direction_updated_at = NOW(),
    reseau_direction_updated_by = auth.uid()
  WHERE reseau_id = NEW.reseau_id;

  RETURN NEW;
END;
$$;

-- ============================================================
-- 3. Trigger sur la table reseau
-- ============================================================
DROP TRIGGER IF EXISTS trigger_sync_reseau_to_direction ON reseau;

CREATE TRIGGER trigger_sync_reseau_to_direction
AFTER UPDATE OF reseau_email, reseau_telephone
ON reseau
FOR EACH ROW
EXECUTE FUNCTION sync_reseau_to_direction();

-- ============================================================
-- 4. Policy RLS stricte pour le bucket "bucket-table-reseau"
-- ============================================================
DROP POLICY IF EXISTS "RLS reseau files access" ON storage.objects;

CREATE POLICY "RLS reseau files access"
ON storage.objects
FOR ALL
TO authenticated
USING (
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    name LIKE ('reseau-' || get_user_reseau_id(auth.uid())::text || '/%')
  )
)
WITH CHECK (
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    name LIKE ('reseau-' || get_user_reseau_id(auth.uid())::text || '/%')
  )
);

-- ============================================================
-- 5. Architecture Bucket (documentation)
-- ============================================================
-- bucket-table-reseau/
-- └── reseau-{uuid}/
--     ├── 1-logos/
--     │   └── logo-principal.png
--     ├── 2-documents-institutionnels/
--     │   └── contrat.pdf
--     └── 3-charte-graphique/
--         └── charte-couleurs.pdf
--
-- Mapping :
-- - reseau.reseau_logo → chemin unique (1-logos/)
-- - reseau.reseau_ressources → tableau de documents (2-documents-institutionnels/)

```
---
---
