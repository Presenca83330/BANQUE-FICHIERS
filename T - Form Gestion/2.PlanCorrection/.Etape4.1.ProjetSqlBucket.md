# üìã ANALYSE ET CAHIER DES CHARGES - SQL & BUCKET
**Date:** 30 Janvier 2025  
**Contexte:** Formulaire de gestion R√©seau (Admin PRESENCA)  
**Statut:** √âTUDE PR√âALABLE - NE PAS IMPL√âMENTER SANS VALIDATION

---

## üîç PARTIE 1 : ANALYSE DES ERREURS ACTUELLES

### 1.1 √âtat Actuel du Bucket `bucket-table-reseau`

#### Configuration Actuelle (depuis `.Etape2.1`)
```sql
-- Bucket cr√©√© le 2025-01-19
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'bucket-table-reseau',
  'bucket-table-reseau',
  false,  -- ‚úÖ PRIV√â (correct)
  52428800,  -- 50 MB
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
);

-- Structure impos√©e dans la policy actuelle
-- organisation-{uuid}/1-logos/
-- organisation-{uuid}/2-documents-institutionnels/
```

#### Policy RLS Actuelle
```sql
CREATE POLICY "RLS reseau files access"
ON storage.objects
FOR ALL
USING (
  bucket_id = 'bucket-table-reseau'
  AND (
    -- Admin PRESENCA : acc√®s total
    is_admin_presenca(auth.uid())
    OR
    -- Membre de l'organisation
    EXISTS (
      SELECT 1 FROM organisations o
      WHERE o.organisation_id::text = (storage.foldername(name))[1]
      AND o.organisation_id = get_user_organisation_id(auth.uid())
    )
  )
)
WITH CHECK (
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    EXISTS (
      SELECT 1 FROM organisations o
      WHERE o.organisation_id::text = (storage.foldername(name))[1]
      AND o.organisation_id = get_user_organisation_id(auth.uid())
    )
  )
);
```

#### √âtat Actuel
- ‚úÖ Le bucket existe et est PRIV√â
- ‚úÖ La policy RLS fonctionne avec `is_admin_presenca()`
- ‚úÖ Le bucket est VIDE (aucun fichier √† migrer)
- ‚ö†Ô∏è **PROBL√àME MAJEUR** : Incoh√©rence conceptuelle `organisation-{uuid}` vs `reseau-{uuid}`

---

### 1.2 Probl√®mes Identifi√©s - BUCKET

#### üö® Probl√®me #1 : Incoh√©rence Conceptuelle
**Nature:** Architecture de stockage inadapt√©e au contexte m√©tier

**Situation:**
- La table `reseau` utilise `reseau_id` comme cl√© primaire (UUID)
- La table `reseau` a une FK `organisation_id` ‚Üí `organisations.organisation_id`
- **Relation:** 1 organisation peut avoir N r√©seaux (actuellement 1:1 mais potentiellement 1:N)
- Le bucket utilise `organisation-{uuid}` au lieu de `reseau-{uuid}`

**Impact:**
- **Confusion m√©tier:** Les fichiers "r√©seau" (logo, documents institutionnels) sont stock√©s au niveau organisation
- **Limitation √©volutive:** Si 1 organisation g√®re plusieurs r√©seaux ‚Üí fichiers m√©lang√©s
- **Incoh√©rence avec les edge functions:** 
  - L'edge function `gestion-reseau-admin-fichiers/index.ts` (ligne 60-64 dans .Etape5) :
    ```typescript
    const organisationFolder = `organisation-${reseauInfo.organisation_id}`
    const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
    const timestamp = Date.now()
    const fileName = `${timestamp}-${file.name}`
    const fullPath = `${organisationFolder}/${subFolder}/${fileName}`
    ```
  - **‚ùå Utilise `organisation_id` r√©cup√©r√©e depuis `reseau.organisation_id`**
  - **‚úÖ DEVRAIT utiliser directement `reseau_id`**

**Analyse:**
- Les fichiers (logo, documents) sont **sp√©cifiques √† UN r√©seau**, pas √† une organisation
- Un r√©seau A et un r√©seau B de la m√™me organisation doivent avoir leurs propres fichiers distincts
- La logique actuelle fonctionne PAR HASARD car 1 organisation = 1 r√©seau actuellement

---

#### üö® Probl√®me #2 : Redondance de Navigation
**Nature:** Double lookup inutile

**Situation actuelle:**
```typescript
// Edge function gestion-reseau-admin-fichiers (ligne 51-56)
const { data: reseauInfo } = await supabaseAdmin
  .from('reseau')
  .select('organisation_id')  // ‚ùå Requ√™te inutile
  .eq('reseau_id', reseauId)
  .single()

const organisationFolder = `organisation-${reseauInfo.organisation_id}`  // ‚ùå Indirection
```

**Impact:**
- 1 requ√™te SQL suppl√©mentaire pour r√©cup√©rer `organisation_id`
- Complexit√© inutile dans le code
- Point de d√©faillance suppl√©mentaire (si le r√©seau n'existe pas)

**Solution attendue:**
```typescript
// ‚úÖ Utilisation directe du reseau_id
const reseauFolder = `reseau-${reseauId}`
const fullPath = `${reseauFolder}/${subFolder}/${fileName}`
// Pas de requ√™te SQL n√©cessaire !
```

---

#### üö® Probl√®me #3 : Policy RLS Inadapt√©e
**Nature:** Contr√¥le d'acc√®s bas√© sur `organisation_id` au lieu de `reseau_id`

**Situation actuelle:**
```sql
-- Policy actuelle (ligne 16-18 dans .Etape2.1)
WHERE o.organisation_id::text = (storage.foldername(name))[1]
AND o.organisation_id = get_user_organisation_id(auth.uid())
```

**Impact:**
- Le contr√¥le d'acc√®s se fait via `organisation_id`
- Si plusieurs r√©seaux partagent la m√™me organisation ‚Üí tous les utilisateurs de l'organisation acc√®dent √† TOUS les fichiers de TOUS les r√©seaux
- **Violation potentielle de la s√©gr√©gation des donn√©es r√©seau**

**Solution attendue:**
- Policy bas√©e sur `reseau_id`
- V√©rifier que l'utilisateur appartient AU r√©seau concern√© (pas juste √† l'organisation parente)

---

### 1.3 Probl√®mes Identifi√©s - SQL

#### üö® Probl√®me #4 : Absence de Synchronisation `reseau` ‚Üî `reseau_direction`
**Nature:** D√©synchronisation des donn√©es de contact

**Situation actuelle:**
- **Table `reseau`** : champs `reseau_email`, `reseau_telephone` (point de v√©rit√© m√©tier)
- **Table `reseau_direction`** : champs `reseau_direction_email`, `reseau_direction_telephone`
- **Probl√®me:** Aucune propagation automatique lors d'une UPDATE dans `reseau`

**Impact:**
- Incoh√©rence des donn√©es de contact r√©seau vs direction
- Risque d'envoi d'emails/SMS √† des anciennes coordonn√©es
- Maintenance manuelle requise (erreur humaine probable)

**Exemple de sc√©nario probl√©matique:**
```sql
-- Admin PRESENCA modifie le t√©l√©phone du r√©seau via le formulaire
UPDATE reseau
SET reseau_telephone = '06 12 34 56 78'
WHERE reseau_id = 'xxx';

-- ‚ùå reseau_direction.reseau_direction_telephone reste inchang√©
-- R√©sultat : d√©synchronisation silencieuse
```

**Solution attendue:**
- Fonction SQL `sync_reseau_to_direction()`
- Trigger `AFTER UPDATE` sur `reseau` pour propagation automatique
- Logs de synchronisation pour audit

---

#### üö® Probl√®me #5 : Absence de Validation des Fichiers dans `reseau.reseau_ressources`
**Nature:** Coh√©rence bucket ‚Üî table

**Situation:**
- Le champ `reseau.reseau_ressources` (type `text[]`) stocke les chemins des fichiers
- Aucune validation que ces fichiers existent r√©ellement dans le bucket
- Aucune cascade de suppression si un fichier est supprim√© du bucket

**Impact:**
- Fichiers "fant√¥mes" r√©f√©renc√©s dans la table mais absents du bucket
- Chemins invalides non d√©tect√©s
- Difficile de nettoyer les r√©f√©rences orphelines

**Solution attendue (optionnelle, non prioritaire):**
- Fonction SQL `validate_reseau_files()` pour v√©rifier l'existence des fichiers
- Trigger ou job p√©riodique pour d√©tecter les incoh√©rences
- **Note:** Non critique pour le MVP, mais √† pr√©voir en phase 2

---

### 1.4 Probl√®mes Identifi√©s - Edge Functions (lien avec SQL/Bucket)

#### ‚ö†Ô∏è Incoh√©rence #1 : `gestion-reseau-admin-fichiers` utilise `organisation_id`
**Fichier:** `.Etape5-FichiersD√©finitifs.md` (non encore d√©ploy√©)

**Code actuel (lignes 51-64):**
```typescript
// ‚ùå R√©cup√®re organisation_id depuis reseau
const { data: reseauInfo } = await supabaseAdmin
  .from('reseau')
  .select('organisation_id')
  .eq('reseau_id', reseauId)
  .single()

// ‚ùå Construit le chemin avec organisation_id
const organisationFolder = `organisation-${reseauInfo.organisation_id}`
const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
const fullPath = `${organisationFolder}/${subFolder}/${fileName}`
```

**Correction n√©cessaire:**
```typescript
// ‚úÖ Utilisation directe de reseau_id (pas de requ√™te SQL)
const reseauFolder = `reseau-${reseauId}`
const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
const fullPath = `${reseauFolder}/${subFolder}/${fileName}`
```

---

#### ‚ö†Ô∏è Incoh√©rence #2 : `gestion-reseau-admin-update` ne d√©clenche pas la synchro
**Fichier:** `.Etape5-FichiersD√©finitifs.md` (lignes 690-780)

**Code actuel:**
```typescript
// Mise √† jour de la table reseau
const { data: updatedReseau, error: updateErr } = await supabase
  .from("reseau")
  .update({
    reseau_nom: generalData.reseau_nom,
    reseau_email: generalData.reseau_email,  // ‚ùå Pas de synchro automatique
    reseau_telephone: generalData.reseau_telephone,  // ‚ùå Pas de synchro automatique
    // ... autres champs
  })
  .eq("reseau_id", reseauId)
  .select()
  .single();
```

**Impact:**
- La synchronisation vers `reseau_direction` d√©pend du trigger SQL `AFTER UPDATE`
- Si le trigger n'existe pas ‚Üí d√©synchronisation
- **‚úÖ Bonne approche** : laisser le trigger g√©rer la synchro (pas de logique applicative dupliqu√©e)

**V√©rification n√©cessaire:**
- Confirmer que le trigger `sync_reseau_to_direction_trigger` est bien cr√©√©
- Tester la propagation `reseau.reseau_email` ‚Üí `reseau_direction.reseau_direction_email`

---

## üìê PARTIE 2 : CAHIER DES CHARGES

### 2.1 Objectifs Globaux

#### Objectif #1 : Standardisation Bucket sur `reseau-{uuid}`
**Priorit√©:** üî¥ CRITIQUE  
**Justification:** Architecture incoh√©rente, limitation √©volutive

**Sp√©cifications:**
1. **Structure cible:**
   ```
   bucket-table-reseau/
   ‚îú‚îÄ‚îÄ reseau-{uuid}/
   ‚îÇ   ‚îú‚îÄ‚îÄ 1-logos/
   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {timestamp}-{filename}
   ‚îÇ   ‚îî‚îÄ‚îÄ 2-documents-institutionnels/
   ‚îÇ       ‚îî‚îÄ‚îÄ {timestamp}-{filename}
   ```

2. **Isolation des donn√©es:**
   - Chaque r√©seau (`reseau_id`) a son propre dossier racine
   - Pas de partage de fichiers entre r√©seaux
   - Ind√©pendant de l'`organisation_id` parente

3. **Avantages:**
   - ‚úÖ Coh√©rence m√©tier : 1 r√©seau = 1 dossier
   - ‚úÖ Scalabilit√© : 1 organisation peut g√©rer N r√©seaux sans collision
   - ‚úÖ Simplicit√© : pas de lookup SQL pour `organisation_id`
   - ‚úÖ Performance : chemin direct depuis `reseau_id` (disponible dans le contexte)

4. **Migration:**
   - **Bucket actuellement VIDE** ‚Üí Pas de migration de fichiers n√©cessaire ‚úÖ
   - **Action requise:** Mise √† jour de la policy RLS uniquement

---

#### Objectif #2 : Synchronisation Automatique `reseau` ‚Üî `reseau_direction`
**Priorit√©:** üü† HAUTE  
**Justification:** Int√©grit√© des donn√©es de contact, automatisation

**Sp√©cifications:**
1. **Point de v√©rit√©:** Table `reseau`
   - Champs ma√Ætres : `reseau_email`, `reseau_telephone`
   - Modifiables UNIQUEMENT via le formulaire de gestion (Admin PRESENCA)

2. **Propagation automatique:**
   - **D√©clencheur:** `UPDATE` sur `reseau.reseau_email` OU `reseau.reseau_telephone`
   - **Action:** Mise √† jour synchrone de `reseau_direction.reseau_direction_email` et `reseau_direction.reseau_direction_telephone`
   - **M√©canisme:** Trigger SQL `AFTER UPDATE`

3. **Champs synchronis√©s:**
   | Champ source (reseau) | Champ cible (reseau_direction) |
   |-----------------------|--------------------------------|
   | `reseau_email`        | `reseau_direction_email`       |
   | `reseau_telephone`    | `reseau_direction_telephone`   |

4. **Champs exclus de la synchro:**
   - `reseau_direction_nom` / `reseau_direction_prenom` : donn√©es du responsable (non li√©es au r√©seau)
   - `reseau_direction_utilisateur_id` : FK vers `users` (immuable)

5. **Audit:**
   - Mise √† jour de `reseau_direction_updated_at` (timestamp)
   - Mise √† jour de `reseau_direction_updated_by` (via `auth.uid()`)
   - Log dans `1_historique_supabase` (optionnel, via fonction `log_audit_event()`)

---

#### Objectif #3 : Policy RLS Bucket Bas√©e sur `reseau_id`
**Priorit√©:** üü† HAUTE  
**Justification:** S√©curit√©, isolation multi-tenant au niveau r√©seau

**Sp√©cifications:**
1. **Contr√¥le d'acc√®s:**
   - **Admin PRESENCA** : acc√®s TOTAL √† tous les fichiers de tous les r√©seaux ‚úÖ
   - **Utilisateur standard** : acc√®s UNIQUEMENT aux fichiers de SON r√©seau

2. **Logique de v√©rification:**
   ```sql
   -- Extraire reseau_id depuis le chemin du fichier
   -- Chemin : reseau-{uuid}/1-logos/123456-logo.png
   -- Extraction : (storage.foldername(name))[1] ‚Üí "reseau-{uuid}"
   -- Parsing : substring(folder FROM 8) ‚Üí "{uuid}"
   
   -- V√©rifier que l'utilisateur appartient √† CE r√©seau
   EXISTS (
     SELECT 1 FROM reseau r
     WHERE r.reseau_id::text = substring((storage.foldername(name))[1] FROM 8)
     AND r.organisation_id = get_user_organisation_id(auth.uid())
   )
   ```

3. **Op√©rations autoris√©es:**
   - **SELECT** : Lecture des fichiers
   - **INSERT** : Upload de nouveaux fichiers
   - **UPDATE** : Modification des m√©tadonn√©es (nom, etc.)
   - **DELETE** : Suppression de fichiers

4. **Cas d'usage:**
   - Admin PRESENCA upload un logo pour le r√©seau X ‚Üí ‚úÖ autoris√©
   - Utilisateur du r√©seau X acc√®de au logo du r√©seau X ‚Üí ‚úÖ autoris√©
   - Utilisateur du r√©seau X tente d'acc√©der au logo du r√©seau Y (m√™me organisation) ‚Üí ‚ùå refus√©
   - Utilisateur sans organisation ‚Üí ‚ùå refus√© (sauf Admin PRESENCA)

---

### 2.2 Contraintes Techniques

#### Contrainte #1 : Compatibilit√© avec les Edge Functions Corrig√©es
**Fichiers concern√©s:** `.Etape5-FichiersD√©finitifs.md`

**Exigences:**
1. L'edge function `gestion-reseau-admin-fichiers` doit √™tre mise √† jour pour utiliser `reseau-{uuid}` au lieu de `organisation-{uuid}`
2. Modification minimale : lignes 60-64 uniquement
3. Pas d'impact sur les autres edge functions (`gestion-reseau-admin`, `gestion-reseau-admin-donnees`, `gestion-reseau-admin-update`)

**Code √† modifier:**
```typescript
// ‚ùå AVANT (ligne 60-64)
const { data: reseauInfo } = await supabaseAdmin
  .from('reseau')
  .select('organisation_id')
  .eq('reseau_id', reseauId)
  .single()

const organisationFolder = `organisation-${reseauInfo.organisation_id}`
const fullPath = `${organisationFolder}/${subFolder}/${fileName}`

// ‚úÖ APR√àS
const reseauFolder = `reseau-${reseauId}`
const fullPath = `${reseauFolder}/${subFolder}/${fileName}`
// Suppression de la requ√™te SQL inutile
```

---

#### Contrainte #2 : Trigger SQL Sans R√©cursion
**Probl√®me potentiel:** Boucle infinie si mal impl√©ment√©

**Exigences:**
1. Le trigger `AFTER UPDATE` ne doit PAS se d√©clencher lors de l'UPDATE de `reseau_direction`
2. Utiliser une condition `WHEN` pour filtrer les champs modifi√©s
3. √âviter `NEW` vs `OLD` si les valeurs n'ont pas chang√© (optimisation)

**Solution:**
```sql
CREATE TRIGGER sync_reseau_to_direction_trigger
AFTER UPDATE OF reseau_email, reseau_telephone ON reseau
FOR EACH ROW
WHEN (
  OLD.reseau_email IS DISTINCT FROM NEW.reseau_email
  OR OLD.reseau_telephone IS DISTINCT FROM NEW.reseau_telephone
)
EXECUTE FUNCTION sync_reseau_to_direction();
```

**Justification:**
- `AFTER UPDATE OF reseau_email, reseau_telephone` : ne se d√©clenche QUE si ces champs sont modifi√©s
- `WHEN (OLD IS DISTINCT FROM NEW)` : √©vite l'ex√©cution si la valeur n'a pas r√©ellement chang√© (ex: `UPDATE` sans changement)
- `FOR EACH ROW` : ex√©cution pour chaque ligne (1 r√©seau = 1 direction)

---

#### Contrainte #3 : Gestion des Cas Limites

**Cas Limite #1 : R√©seau sans Direction**
- **Situation:** `reseau.reseau_id` existe mais aucune ligne dans `reseau_direction`
- **Comportement attendu:** Le trigger ne fait rien (pas d'erreur)
- **Impl√©mentation:** `UPDATE reseau_direction ... WHERE reseau_id = NEW.reseau_id` ‚Üí 0 lignes affect√©es ‚Üí OK

**Cas Limite #2 : Direction Multiple (th√©oriquement impossible)**
- **Situation:** Plusieurs lignes dans `reseau_direction` pour un m√™me `reseau_id` (violation d'int√©grit√©)
- **Comportement attendu:** Le trigger met √† jour TOUTES les lignes (bien que ce soit une anomalie)
- **Pr√©vention:** Ajouter une contrainte `UNIQUE(reseau_id)` sur `reseau_direction` (si pas d√©j√† pr√©sente)

**Cas Limite #3 : Valeurs NULL**
- **Situation:** `reseau.reseau_email = NULL` ou `reseau.reseau_telephone = NULL`
- **Comportement attendu:** Propagation du NULL vers `reseau_direction`
- **Impl√©mentation:** Pas de `COALESCE()`, on propage la valeur telle quelle

**Cas Limite #4 : Suppression Bucket via Edge Function**
- **Situation:** Utilisateur supprime un fichier via `gestion-reseau-admin-fichiers` (DELETE)
- **Comportement attendu:** 
  1. Suppression du fichier dans le bucket ‚úÖ
  2. Mise √† jour de `reseau.reseau_ressources` pour retirer le chemin ‚ùå (non g√©r√© actuellement)
- **Impact:** `reseau_ressources` contient un chemin orphelin
- **Solution (Phase 2):** L'edge function doit √©galement mettre √† jour la colonne `reseau_ressources`

---

### 2.3 Plan de Test

#### Test #1 : Bucket - Upload Fichier
**Pr√©requis:** Bucket configur√© avec la nouvelle policy

**Sc√©nario:**
1. Admin PRESENCA se connecte
2. S√©lectionne le r√©seau X dans le formulaire de gestion
3. Upload un fichier `logo.png` via l'onglet "Fichiers"
4. V√©rifier le chemin stock√© : `reseau-{reseau_id}/1-logos/{timestamp}-logo.png`
5. V√©rifier que `reseau.reseau_logo` est mis √† jour avec ce chemin
6. V√©rifier que le fichier est accessible via l'URL publique sign√©e

**R√©sultat attendu:** ‚úÖ Upload r√©ussi, chemin correct, fichier accessible

---

#### Test #2 : Bucket - Isolation Multi-R√©seau
**Pr√©requis:** 2 r√©seaux distincts (A et B) avec la m√™me organisation

**Sc√©nario:**
1. Admin PRESENCA upload `logo-A.png` pour le r√©seau A
2. Admin PRESENCA upload `logo-B.png` pour le r√©seau B
3. V√©rifier que les chemins sont distincts :
   - R√©seau A : `reseau-{id_A}/1-logos/{timestamp}-logo-A.png`
   - R√©seau B : `reseau-{id_B}/1-logos/{timestamp}-logo-B.png`
4. Tenter d'acc√©der au fichier de B en tant qu'utilisateur du r√©seau A ‚Üí ‚ùå refus√©

**R√©sultat attendu:** ‚úÖ Isolation correcte, pas de fuite de donn√©es

---

#### Test #3 : Synchronisation Email
**Pr√©requis:** Trigger et fonction SQL d√©ploy√©s

**Sc√©nario:**
1. Admin PRESENCA modifie `reseau.reseau_email` via le formulaire (onglet "G√©n√©ral")
2. Cliquer sur "Enregistrer"
3. V√©rifier la requ√™te SQL ex√©cut√©e par `gestion-reseau-admin-update`
4. V√©rifier que `reseau_direction.reseau_direction_email` a √©t√© mis √† jour automatiquement
5. V√©rifier que `reseau_direction_updated_at` a √©t√© mis √† jour

**SQL de v√©rification:**
```sql
SELECT 
  r.reseau_id,
  r.reseau_email AS email_reseau,
  rd.reseau_direction_email AS email_direction,
  rd.reseau_direction_updated_at
FROM reseau r
JOIN reseau_direction rd ON rd.reseau_id = r.reseau_id
WHERE r.reseau_id = '{test_reseau_id}';
```

**R√©sultat attendu:** `email_reseau = email_direction` (synchronis√©s)

---

#### Test #4 : Synchronisation T√©l√©phone
**Pr√©requis:** Trigger et fonction SQL d√©ploy√©s

**Sc√©nario:**
1. Identique au Test #3, mais pour `reseau_telephone`
2. V√©rifier `reseau.reseau_telephone = reseau_direction.reseau_direction_telephone`

**R√©sultat attendu:** ‚úÖ Synchronisation OK

---

#### Test #5 : Non-R√©gression sur Formulaire Cr√©ation
**Pr√©requis:** Formulaire de cr√©ation de r√©seau (qui fonctionne d√©j√†)

**Sc√©nario:**
1. Cr√©er un nouveau r√©seau via le formulaire de cr√©ation
2. V√©rifier que la fonction SQL `create_reseau_compte_complet()` fonctionne toujours
3. V√©rifier que `reseau.reseau_email` et `reseau_direction.reseau_direction_email` sont identiques √† la cr√©ation
4. V√©rifier qu'aucun trigger ne bloque la cr√©ation

**R√©sultat attendu:** ‚úÖ Cr√©ation OK, pas de r√©gression

---

## üíª PARTIE 3 : CODES SQL COMPLETS

### 3.1 Fonction de Synchronisation `sync_reseau_to_direction()`

#### 3.1.1 Code SQL
```sql
-- =============================================================================
-- Fonction : sync_reseau_to_direction()
-- Description : Synchronise les coordonn√©es de contact (email, telephone) 
--               depuis la table `reseau` vers `reseau_direction`.
-- D√©clenchement : Via trigger AFTER UPDATE sur `reseau`
-- Auteur : PRESENCA (Admin)
-- Date : 30 Janvier 2025
-- =============================================================================

CREATE OR REPLACE FUNCTION public.sync_reseau_to_direction()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_affected_rows INT;
  v_reseau_nom TEXT;
BEGIN
  -- üìå LOG : D√©but de la synchronisation
  RAISE NOTICE '[sync_reseau_to_direction] Trigger START - reseau_id: %, OLD.email: %, NEW.email: %, OLD.tel: %, NEW.tel: %',
    NEW.reseau_id,
    OLD.reseau_email,
    NEW.reseau_email,
    OLD.reseau_telephone,
    NEW.reseau_telephone;

  -- üìå R√©cup√©rer le nom du r√©seau (pour les logs)
  v_reseau_nom := NEW.reseau_nom;

  -- üìå Mise √† jour de reseau_direction
  -- Propagation de reseau_email ‚Üí reseau_direction_email
  -- Propagation de reseau_telephone ‚Üí reseau_direction_telephone
  UPDATE public.reseau_direction
  SET
    reseau_direction_email = NEW.reseau_email,
    reseau_direction_telephone = NEW.reseau_telephone,
    reseau_direction_updated_at = now(),
    reseau_direction_updated_by = auth.uid()  -- ‚úÖ Utilisation de auth.uid() (context JWT)
  WHERE reseau_id = NEW.reseau_id;

  -- üìå R√©cup√©rer le nombre de lignes affect√©es
  GET DIAGNOSTICS v_affected_rows = ROW_COUNT;

  -- üìå LOG : Fin de la synchronisation
  RAISE NOTICE '[sync_reseau_to_direction] Trigger END - reseau_id: %, reseau_nom: %, affected_rows: %',
    NEW.reseau_id,
    v_reseau_nom,
    v_affected_rows;

  -- üìå Audit dans la table historique (optionnel, si log_audit_event() existe)
  -- ‚ö†Ô∏è ATTENTION : V√©rifier que la fonction log_audit_event() accepte les param√®tres suivants
  -- Si la fonction n'existe pas ou a une signature diff√©rente, commenter cette partie
  BEGIN
    PERFORM public.log_audit_event(
      p_table_name := 'reseau_direction',
      p_operation := 'sync_from_reseau',
      p_old_data := jsonb_build_object(
        'reseau_direction_email', OLD.reseau_email,
        'reseau_direction_telephone', OLD.reseau_telephone
      ),
      p_new_data := jsonb_build_object(
        'reseau_direction_email', NEW.reseau_email,
        'reseau_direction_telephone', NEW.reseau_telephone
      ),
      p_session_info := jsonb_build_object(
        'trigger', 'sync_reseau_to_direction',
        'reseau_id', NEW.reseau_id,
        'reseau_nom', v_reseau_nom
      ),
      p_source := 'trigger',
      p_severity := 'info',
      p_metadata := jsonb_build_object(
        'affected_rows', v_affected_rows
      )
    );
  EXCEPTION
    WHEN OTHERS THEN
      -- ‚ö†Ô∏è Si log_audit_event() √©choue, on ignore (ne pas bloquer la synchro)
      RAISE WARNING '[sync_reseau_to_direction] Audit log failed: %', SQLERRM;
  END;

  -- ‚úÖ Retourner NEW pour continuer le trigger flow
  RETURN NEW;
END;
$$;

-- üìå COMMENTAIRE : Description de la fonction
COMMENT ON FUNCTION public.sync_reseau_to_direction() IS
'Synchronise automatiquement reseau.reseau_email et reseau.reseau_telephone vers reseau_direction.reseau_direction_email et reseau_direction.reseau_direction_telephone. D√©clench√©e par un trigger AFTER UPDATE sur reseau.';
```

---

#### 3.1.2 Explication du Code

**Ligne 11-17 : D√©claration de la fonction**
- `RETURNS TRIGGER` : Indique que c'est une fonction d√©clench√©e par un trigger
- `SECURITY DEFINER` : Ex√©cute avec les privil√®ges du cr√©ateur (admin) ‚Üí contourne les RLS
- `SET search_path = public` : Force le sch√©ma `public` pour √©viter les ambigu√Øt√©s

**Ligne 19-21 : Variables locales**
- `v_affected_rows` : Nombre de lignes mises √† jour dans `reseau_direction`
- `v_reseau_nom` : Nom du r√©seau (pour les logs)

**Ligne 23-29 : Logs de d√©marrage**
- `RAISE NOTICE` : Affiche un message dans les logs Supabase (visible dans l'onglet Logs)
- Utile pour le debug : affiche les anciennes et nouvelles valeurs

**Ligne 32 : R√©cup√©ration du nom du r√©seau**
- Utilis√© uniquement pour les logs (optionnel)

**Ligne 35-42 : UPDATE de reseau_direction**
- **Ligne 37-38** : Propagation des valeurs depuis `reseau` vers `reseau_direction`
- **Ligne 39** : Mise √† jour du timestamp `reseau_direction_updated_at`
- **Ligne 40** : Enregistrement de l'utilisateur qui a d√©clench√© la synchro via `auth.uid()`
  - ‚ö†Ô∏è **IMPORTANT** : `auth.uid()` retourne l'UUID de l'utilisateur authentifi√©
  - Si le trigger est d√©clench√© par une edge function avec SERVICE_ROLE_KEY, `auth.uid()` retourne NULL
  - **Solution** : L'edge function doit passer par un contexte utilisateur (header `X-User-Id`) OU accepter `updated_by = NULL`
- **Ligne 41** : Filtre sur `reseau_id` pour cibler la bonne direction

**Ligne 45 : Comptage des lignes affect√©es**
- `GET DIAGNOSTICS v_affected_rows = ROW_COUNT` : R√©cup√®re le nombre de lignes mises √† jour
- Devrait toujours √™tre 1 (1 r√©seau = 1 direction)
- Si 0 ‚Üí R√©seau sans direction (anomalie, mais pas bloquant)

**Ligne 48-52 : Logs de fin**
- Affiche le r√©sultat de la synchronisation

**Ligne 55-82 : Audit dans 1_historique_supabase (optionnel)**
- Appelle `log_audit_event()` pour enregistrer l'op√©ration
- **‚ö†Ô∏è ATTENTION** : V√©rifier que `log_audit_event()` existe et accepte ces param√®tres
- Si la fonction √©choue ‚Üí `EXCEPTION WHEN OTHERS` : on ignore l'erreur (ne pas bloquer la synchro)

**Ligne 85 : RETURN NEW**
- Obligatoire pour un trigger `AFTER UPDATE`
- Retourne la nouvelle ligne (aucune modification ici)

---

### 3.2 Trigger `sync_reseau_to_direction_trigger`

#### 3.2.1 Code SQL
```sql
-- =============================================================================
-- Trigger : sync_reseau_to_direction_trigger
-- Description : D√©clenche la synchronisation reseau ‚Üí reseau_direction
--               UNIQUEMENT si reseau_email OU reseau_telephone sont modifi√©s.
-- Table cible : public.reseau
-- Timing : AFTER UPDATE (apr√®s validation de l'UPDATE)
-- Auteur : PRESENCA (Admin)
-- Date : 30 Janvier 2025
-- =============================================================================

-- üìå SUPPRESSION du trigger existant (si pr√©sent)
DROP TRIGGER IF EXISTS sync_reseau_to_direction_trigger ON public.reseau;

-- üìå CR√âATION du trigger
CREATE TRIGGER sync_reseau_to_direction_trigger
  AFTER UPDATE OF reseau_email, reseau_telephone ON public.reseau
  FOR EACH ROW
  WHEN (
    -- ‚úÖ Condition : se d√©clenche UNIQUEMENT si la valeur a R√âELLEMENT chang√©
    OLD.reseau_email IS DISTINCT FROM NEW.reseau_email
    OR OLD.reseau_telephone IS DISTINCT FROM NEW.reseau_telephone
  )
  EXECUTE FUNCTION public.sync_reseau_to_direction();

-- üìå COMMENTAIRE : Description du trigger
COMMENT ON TRIGGER sync_reseau_to_direction_trigger ON public.reseau IS
'Trigger AFTER UPDATE pour synchroniser reseau.reseau_email et reseau.reseau_telephone vers reseau_direction. Se d√©clenche uniquement si ces champs sont modifi√©s (optimisation via WHEN clause).';
```

---

#### 3.2.2 Explication du Code

**Ligne 12 : DROP TRIGGER IF EXISTS**
- Supprime le trigger s'il existe d√©j√† (idempotence)
- Permet de relancer le script sans erreur

**Ligne 15-16 : CREATE TRIGGER**
- `AFTER UPDATE OF reseau_email, reseau_telephone` : Se d√©clenche UNIQUEMENT si ces 2 champs sont modifi√©s
  - ‚úÖ **Optimisation** : Si on modifie `reseau_nom` uniquement ‚Üí trigger ne se d√©clenche PAS
- `ON public.reseau` : Table cible

**Ligne 17 : FOR EACH ROW**
- Le trigger s'ex√©cute pour CHAQUE ligne mise √† jour
- Exemple : Si on fait `UPDATE reseau SET reseau_email = 'test@example.com' WHERE reseau_id IN ('A', 'B')` ‚Üí trigger appel√© 2 fois

**Ligne 18-21 : WHEN (condition suppl√©mentaire)**
- `OLD.reseau_email IS DISTINCT FROM NEW.reseau_email` : V√©rifie si la valeur a R√âELLEMENT chang√©
  - `IS DISTINCT FROM` g√®re les NULL : `NULL IS DISTINCT FROM NULL` ‚Üí FALSE
  - `IS DISTINCT FROM` : comparaison stricte (valeur + type)
- `OR` : Se d√©clenche si email OU telephone changent (pas besoin des deux)
- ‚úÖ **Optimisation** : √âvite l'ex√©cution si l'UPDATE ne change rien (ex: `UPDATE reseau SET reseau_email = reseau_email`)

**Ligne 22 : EXECUTE FUNCTION**
- Appelle la fonction `sync_reseau_to_direction()` d√©finie pr√©c√©demment

---

#### 3.2.3 Cas d'Usage du Trigger

**Cas #1 : Modification de l'email uniquement**
```sql
UPDATE reseau
SET reseau_email = 'nouveau@example.com'
WHERE reseau_id = 'xxx';

-- ‚úÖ Trigger se d√©clenche
-- ‚úÖ reseau_direction.reseau_direction_email mis √† jour
-- ‚úÖ reseau_direction.reseau_direction_telephone INCHANG√â
```

**Cas #2 : Modification du t√©l√©phone uniquement**
```sql
UPDATE reseau
SET reseau_telephone = '06 12 34 56 78'
WHERE reseau_id = 'xxx';

-- ‚úÖ Trigger se d√©clenche
-- ‚úÖ reseau_direction.reseau_direction_telephone mis √† jour
-- ‚úÖ reseau_direction.reseau_direction_email INCHANG√â
```

**Cas #3 : Modification des deux champs**
```sql
UPDATE reseau
SET 
  reseau_email = 'nouveau@example.com',
  reseau_telephone = '06 12 34 56 78'
WHERE reseau_id = 'xxx';

-- ‚úÖ Trigger se d√©clenche UNE SEULE FOIS (FOR EACH ROW)
-- ‚úÖ Les deux champs de reseau_direction sont mis √† jour
```

**Cas #4 : Modification d'un autre champ (ex: reseau_nom)**
```sql
UPDATE reseau
SET reseau_nom = 'Nouveau Nom'
WHERE reseau_id = 'xxx';

-- ‚ùå Trigger NE SE D√âCLENCHE PAS (AFTER UPDATE OF reseau_email, reseau_telephone)
-- ‚úÖ Performance optimale : pas d'ex√©cution inutile
```

**Cas #5 : UPDATE sans changement r√©el**
```sql
UPDATE reseau
SET reseau_email = 'test@example.com'
WHERE reseau_id = 'xxx' AND reseau_email = 'test@example.com';

-- ‚ùå Trigger NE SE D√âCLENCHE PAS (WHEN OLD IS DISTINCT FROM NEW ‚Üí FALSE)
-- ‚úÖ Optimisation : √©vite l'ex√©cution inutile
```

---

### 3.3 Bucket - Policy RLS Bas√©e sur `reseau_id`

#### 3.3.1 Code SQL - Suppression de l'Ancienne Policy
```sql
-- =============================================================================
-- Suppression de l'ancienne policy bas√©e sur organisation_id
-- =============================================================================

-- üìå Suppression de la policy existante
DROP POLICY IF EXISTS "RLS reseau files access" ON storage.objects;

-- üìå Logs (optionnel, pour tra√ßabilit√©)
-- Si vous avez une table de logs ou utilisez RAISE NOTICE
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Ancienne policy "RLS reseau files access" supprim√©e (bas√©e sur organisation_id)';
END $$;
```

---

#### 3.3.2 Code SQL - Nouvelle Policy Bas√©e sur `reseau_id`
```sql
-- =============================================================================
-- Policy RLS : bucket-table-reseau (bas√©e sur reseau_id)
-- Description : Contr√¥le d'acc√®s aux fichiers du bucket par reseau_id
-- Structure des chemins : reseau-{uuid}/1-logos/ ou reseau-{uuid}/2-documents-institutionnels/
-- Auteur : PRESENCA (Admin)
-- Date : 30 Janvier 2025
-- =============================================================================

CREATE POLICY "RLS reseau files by reseau_id"
ON storage.objects
FOR ALL
USING (
  -- üìå V√©rification : bucket_id = 'bucket-table-reseau'
  bucket_id = 'bucket-table-reseau'
  AND (
    -- üìå CAS #1 : Admin PRESENCA ‚Üí Acc√®s total
    is_admin_presenca(auth.uid())
    
    OR
    
    -- üìå CAS #2 : Utilisateur standard ‚Üí Acc√®s √† SON r√©seau uniquement
    EXISTS (
      SELECT 1 
      FROM public.reseau r
      WHERE 
        -- ‚úÖ Extraction du reseau_id depuis le chemin du fichier
        -- Chemin format : "reseau-{uuid}/1-logos/123456-logo.png"
        -- (storage.foldername(name))[1] ‚Üí "reseau-{uuid}"
        -- substring((storage.foldername(name))[1] FROM 8) ‚Üí "{uuid}"
        r.reseau_id::text = substring((storage.foldername(name))[1] FROM 8)
        
        -- ‚úÖ V√©rification : l'utilisateur appartient √† l'organisation du r√©seau
        AND r.organisation_id = get_user_organisation_id(auth.uid())
    )
  )
)
WITH CHECK (
  -- üìå M√™me logique pour INSERT / UPDATE
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    EXISTS (
      SELECT 1 
      FROM public.reseau r
      WHERE 
        r.reseau_id::text = substring((storage.foldername(name))[1] FROM 8)
        AND r.organisation_id = get_user_organisation_id(auth.uid())
    )
  )
);

-- üìå COMMENTAIRE : Description de la policy
COMMENT ON POLICY "RLS reseau files by reseau_id" ON storage.objects IS
'Policy RLS pour le bucket bucket-table-reseau. Admin PRESENCA a un acc√®s total. Les utilisateurs standard peuvent acc√©der uniquement aux fichiers de leur propre r√©seau (via reseau_id). Structure des chemins : reseau-{uuid}/1-logos/ ou reseau-{uuid}/2-documents-institutionnels/.';
```

---

#### 3.3.3 Explication du Code

**Ligne 10 : Nom de la Policy**
- `"RLS reseau files by reseau_id"` : Nom explicite pour diff√©rencier de l'ancienne policy

**Ligne 12 : FOR ALL**
- La policy couvre toutes les op√©rations : `SELECT`, `INSERT`, `UPDATE`, `DELETE`

**Ligne 13-14 : USING (lecture)**
- Clause pour les op√©rations de **lecture** (`SELECT`)

**Ligne 15 : V√©rification du bucket_id**
- S√©curit√© de base : on ne g√®re que `bucket-table-reseau`

**Ligne 17 : CAS #1 - Admin PRESENCA**
- `is_admin_presenca(auth.uid())` : Fonction existante (d√©j√† dans Supabase)
- Si vrai ‚Üí acc√®s TOTAL √† tous les fichiers de tous les r√©seaux
- ‚úÖ Permet l'administration globale

**Ligne 21-32 : CAS #2 - Utilisateur Standard**
- **Ligne 23** : `SELECT 1 FROM public.reseau r WHERE ...` ‚Üí V√©rifie l'appartenance au r√©seau
- **Ligne 29** : `substring((storage.foldername(name))[1] FROM 8)` ‚Üí Extraction du UUID
  - Explication :
    - `name` : Chemin complet du fichier (ex: `reseau-abc123/1-logos/logo.png`)
    - `storage.foldername(name)` : Fonction Supabase qui retourne un array des dossiers
    - `(storage.foldername(name))[1]` : 1er √©l√©ment ‚Üí `"reseau-abc123"`
    - `substring(... FROM 8)` : Supprime les 7 premiers caract√®res (`"reseau-"`) ‚Üí `"abc123"`
  - R√©sultat : On obtient le `reseau_id` depuis le chemin
- **Ligne 32** : `r.organisation_id = get_user_organisation_id(auth.uid())` ‚Üí V√©rification de l'organisation
  - M√™me organisation ‚Üí acc√®s autoris√©
  - Organisation diff√©rente ‚Üí acc√®s refus√©

**Ligne 36-51 : WITH CHECK (√©criture)**
- Clause pour les op√©rations d'**√©criture** (`INSERT`, `UPDATE`, `DELETE`)
- **M√™me logique que USING** : √©vite la duplication de conditions

---

#### 3.3.4 Exemples de Chemins et Extraction

**Exemple #1 : Fichier Logo**
```
Chemin complet : reseau-550e8400-e29b-41d4-a716-446655440000/1-logos/1738287600000-logo.png

Extraction :
1. storage.foldername(name) ‚Üí ["reseau-550e8400-e29b-41d4-a716-446655440000", "1-logos"]
2. (storage.foldername(name))[1] ‚Üí "reseau-550e8400-e29b-41d4-a716-446655440000"
3. substring(...FROM 8) ‚Üí "550e8400-e29b-41d4-a716-446655440000"

R√©sultat : reseau_id = 550e8400-e29b-41d4-a716-446655440000
```

**Exemple #2 : Fichier Document**
```
Chemin complet : reseau-123e4567-e89b-12d3-a456-426614174000/2-documents-institutionnels/1738287700000-statuts.pdf

Extraction :
1. storage.foldername(name) ‚Üí ["reseau-123e4567-e89b-12d3-a456-426614174000", "2-documents-institutionnels"]
2. (storage.foldername(name))[1] ‚Üí "reseau-123e4567-e89b-12d3-a456-426614174000"
3. substring(...FROM 8) ‚Üí "123e4567-e89b-12d3-a456-426614174000"

R√©sultat : reseau_id = 123e4567-e89b-12d3-a456-426614174000
```

**Exemple #3 : Fichier √† la Racine (INVALIDE)**
```
Chemin complet : fichier-racine.png

Extraction :
1. storage.foldername(name) ‚Üí []
2. (storage.foldername(name))[1] ‚Üí NULL
3. substring(...FROM 8) ‚Üí NULL

R√©sultat : reseau_id = NULL ‚Üí ‚ùå Acc√®s refus√© (sauf Admin PRESENCA)
```

---

### 3.4 Script de Migration Complet (Ordre d'Ex√©cution)

#### 3.4.1 √âtape 1 : V√©rification de l'√âtat Actuel
```sql
-- =============================================================================
-- √âTAPE 1 : V√âRIFICATION DE L'√âTAT ACTUEL
-- =============================================================================

-- üìå V√©rifier que le bucket existe
SELECT id, name, public, file_size_limit, created_at
FROM storage.buckets
WHERE id = 'bucket-table-reseau';
-- R√©sultat attendu : 1 ligne (bucket existe)

-- üìå V√©rifier la policy actuelle
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE schemaname = 'storage' 
  AND tablename = 'objects'
  AND policyname ILIKE '%reseau%';
-- R√©sultat attendu : 1 policy "RLS reseau files access" (bas√©e sur organisation_id)

-- üìå V√©rifier l'√©tat du bucket (fichiers existants)
SELECT 
  name AS chemin_fichier,
  bucket_id,
  created_at,
  metadata->>'size' AS taille_bytes
FROM storage.objects
WHERE bucket_id = 'bucket-table-reseau'
ORDER BY created_at DESC;
-- R√©sultat attendu : 0 lignes (bucket vide selon .Etape2.1)

-- üìå V√©rifier les triggers existants sur la table reseau
SELECT 
  trigger_name,
  event_manipulation,
  event_object_table,
  action_statement
FROM information_schema.triggers
WHERE event_object_table = 'reseau'
  AND trigger_schema = 'public'
ORDER BY trigger_name;
-- R√©sultat attendu : V√©rifier si un trigger similaire existe d√©j√†

-- üìå V√©rifier les fonctions existantes
SELECT 
  proname AS function_name,
  pg_get_functiondef(oid) AS function_definition
FROM pg_proc
WHERE proname ILIKE '%sync%reseau%'
  AND pronamespace = 'public'::regnamespace;
-- R√©sultat attendu : 0 lignes (fonction n'existe pas encore)

-- üìå LOGS : √âtat actuel confirm√©
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] √âtat actuel v√©rifi√© - Bucket vide, ancienne policy pr√©sente, aucun trigger de synchro';
END $$;
```

---

#### 3.4.2 √âtape 2 : Cr√©ation de la Fonction de Synchronisation
```sql
-- =============================================================================
-- √âTAPE 2 : CR√âATION DE LA FONCTION sync_reseau_to_direction()
-- =============================================================================

-- üìå Copier-coller le code de la section 3.1.1 ici
-- (Fonction compl√®te avec logs, audit, SECURITY DEFINER)

-- V√©rification post-cr√©ation
SELECT 
  proname AS function_name,
  prosrc AS function_body
FROM pg_proc
WHERE proname = 'sync_reseau_to_direction'
  AND pronamespace = 'public'::regnamespace;
-- R√©sultat attendu : 1 ligne (fonction cr√©√©e)

-- üìå LOGS : Fonction cr√©√©e
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Fonction sync_reseau_to_direction() cr√©√©e avec succ√®s';
END $$;
```

---

#### 3.4.3 √âtape 3 : Cr√©ation du Trigger
```sql
-- =============================================================================
-- √âTAPE 3 : CR√âATION DU TRIGGER sync_reseau_to_direction_trigger
-- =============================================================================

-- üìå Copier-coller le code de la section 3.2.1 ici
-- (Trigger avec DROP IF EXISTS, WHEN clause, AFTER UPDATE OF)

-- V√©rification post-cr√©ation
SELECT 
  trigger_name,
  event_manipulation,
  action_statement,
  action_timing
FROM information_schema.triggers
WHERE trigger_name = 'sync_reseau_to_direction_trigger'
  AND event_object_table = 'reseau'
  AND trigger_schema = 'public';
-- R√©sultat attendu : 1 ligne (trigger cr√©√©)

-- üìå LOGS : Trigger cr√©√©
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Trigger sync_reseau_to_direction_trigger cr√©√© avec succ√®s';
END $$;
```

---

#### 3.4.4 √âtape 4 : Test de la Synchronisation
```sql
-- =============================================================================
-- √âTAPE 4 : TEST DE LA SYNCHRONISATION
-- =============================================================================

-- üìå S√©lectionner un r√©seau de test
SELECT reseau_id, reseau_nom, reseau_email, reseau_telephone
FROM reseau
LIMIT 1;
-- Exemple de r√©sultat : reseau_id = '550e8400-e29b-41d4-a716-446655440000'

-- üìå V√©rifier l'√©tat actuel de reseau_direction AVANT modification
SELECT 
  reseau_id,
  reseau_direction_email,
  reseau_direction_telephone,
  reseau_direction_updated_at
FROM reseau_direction
WHERE reseau_id = '550e8400-e29b-41d4-a716-446655440000';
-- Noter les valeurs actuelles

-- üìå Modifier reseau.reseau_email (test)
UPDATE reseau
SET reseau_email = 'test-sync@example.com'
WHERE reseau_id = '550e8400-e29b-41d4-a716-446655440000';
-- ‚úÖ Le trigger devrait se d√©clencher automatiquement

-- üìå V√©rifier l'√©tat de reseau_direction APR√àS modification
SELECT 
  reseau_id,
  reseau_direction_email,
  reseau_direction_telephone,
  reseau_direction_updated_at
FROM reseau_direction
WHERE reseau_id = '550e8400-e29b-41d4-a716-446655440000';
-- ‚úÖ R√©sultat attendu : reseau_direction_email = 'test-sync@example.com'
-- ‚úÖ reseau_direction_updated_at mis √† jour

-- üìå Restaurer la valeur d'origine (si n√©cessaire)
UPDATE reseau
SET reseau_email = 'original@example.com'  -- Remplacer par la valeur d'origine
WHERE reseau_id = '550e8400-e29b-41d4-a716-446655440000';

-- üìå LOGS : Test de synchro OK
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Test de synchronisation r√©ussi';
END $$;
```

---

#### 3.4.5 √âtape 5 : Suppression de l'Ancienne Policy Bucket
```sql
-- =============================================================================
-- √âTAPE 5 : SUPPRESSION DE L'ANCIENNE POLICY
-- =============================================================================

-- üìå Copier-coller le code de la section 3.3.1 ici
-- (DROP POLICY "RLS reseau files access")

-- V√©rification post-suppression
SELECT policyname
FROM pg_policies
WHERE schemaname = 'storage' 
  AND tablename = 'objects'
  AND policyname = 'RLS reseau files access';
-- R√©sultat attendu : 0 lignes (policy supprim√©e)

-- üìå LOGS : Ancienne policy supprim√©e
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Ancienne policy bucket supprim√©e';
END $$;
```

---

#### 3.4.6 √âtape 6 : Cr√©ation de la Nouvelle Policy Bucket
```sql
-- =============================================================================
-- √âTAPE 6 : CR√âATION DE LA NOUVELLE POLICY (bas√©e sur reseau_id)
-- =============================================================================

-- üìå Copier-coller le code de la section 3.3.2 ici
-- (CREATE POLICY "RLS reseau files by reseau_id")

-- V√©rification post-cr√©ation
SELECT 
  policyname,
  cmd,
  qual AS using_expression,
  with_check AS with_check_expression
FROM pg_policies
WHERE schemaname = 'storage' 
  AND tablename = 'objects'
  AND policyname = 'RLS reseau files by reseau_id';
-- R√©sultat attendu : 1 ligne (nouvelle policy cr√©√©e)

-- üìå LOGS : Nouvelle policy cr√©√©e
DO $$
BEGIN
  RAISE NOTICE '[MIGRATION] Nouvelle policy bucket cr√©√©e (bas√©e sur reseau_id)';
END $$;
```

---

#### 3.4.7 √âtape 7 : V√©rification Finale
```sql
-- =============================================================================
-- √âTAPE 7 : V√âRIFICATION FINALE DE LA MIGRATION
-- =============================================================================

-- üìå R√©capitulatif des changements
SELECT 
  '‚úÖ Fonction sync_reseau_to_direction() cr√©√©e' AS statut
WHERE EXISTS (
  SELECT 1 FROM pg_proc 
  WHERE proname = 'sync_reseau_to_direction' 
  AND pronamespace = 'public'::regnamespace
);

SELECT 
  '‚úÖ Trigger sync_reseau_to_direction_trigger cr√©√©' AS statut
WHERE EXISTS (
  SELECT 1 FROM information_schema.triggers
  WHERE trigger_name = 'sync_reseau_to_direction_trigger'
  AND event_object_table = 'reseau'
);

SELECT 
  '‚úÖ Nouvelle policy bucket cr√©√©e (reseau_id)' AS statut
WHERE EXISTS (
  SELECT 1 FROM pg_policies
  WHERE policyname = 'RLS reseau files by reseau_id'
  AND schemaname = 'storage'
);

SELECT 
  '‚úÖ Ancienne policy bucket supprim√©e (organisation_id)' AS statut
WHERE NOT EXISTS (
  SELECT 1 FROM pg_policies
  WHERE policyname = 'RLS reseau files access'
  AND schemaname = 'storage'
);

-- üìå LOGS FINAUX
DO $$
BEGIN
  RAISE NOTICE '========================================';
  RAISE NOTICE '[MIGRATION] MIGRATION BUCKET + SQL TERMIN√âE';
  RAISE NOTICE '========================================';
  RAISE NOTICE 'Prochaine √©tape : Modifier edge function gestion-reseau-admin-fichiers';
  RAISE NOTICE 'Remplacer organisation-{uuid} par reseau-{uuid} (lignes 60-64)';
  RAISE NOTICE '========================================';
END $$;
```

---

## üìå PARTIE 4 : MODIFICATIONS N√âCESSAIRES DES EDGE FUNCTIONS

### 4.1 Modification de `gestion-reseau-admin-fichiers/index.ts`

#### 4.1.1 Fichier Actuel (avant correction)
**Source:** `.Etape5-FichiersD√©finitifs.md` lignes 51-86

```typescript
// ‚ùå CODE ACTUEL (√† modifier)
// R√©cup√©rer l'organisation_id du r√©seau
const { data: reseauInfo } = await supabaseAdmin
  .from('reseau')
  .select('organisation_id')
  .eq('reseau_id', reseauId)
  .single()

if (!reseauInfo) throw new Error('R√©seau introuvable')

// üîß Construction du chemin selon votre design
const organisationFolder = `organisation-${reseauInfo.organisation_id}`  // ‚ùå ANCIEN
const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
const timestamp = Date.now()
const fileName = `${timestamp}-${file.name}`
const fullPath = `${organisationFolder}/${subFolder}/${fileName}`  // ‚ùå ANCIEN
```

---

#### 4.1.2 Fichier Corrig√© (nouvelle version)
**Changements:** Lignes 51-86 uniquement

```typescript
// ‚úÖ CODE CORRIG√â (nouvelle version)
// ‚ùå SUPPRIMER la requ√™te pour r√©cup√©rer organisation_id
// const { data: reseauInfo } = await supabaseAdmin
//   .from('reseau')
//   .select('organisation_id')
//   .eq('reseau_id', reseauId)
//   .single()
//
// if (!reseauInfo) throw new Error('R√©seau introuvable')

// ‚úÖ NOUVELLE LOGIQUE : Utilisation directe de reseau_id
const reseauFolder = `reseau-${reseauId}`  // ‚úÖ NOUVEAU
const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
const timestamp = Date.now()
const fileName = `${timestamp}-${file.name}`
const fullPath = `${reseauFolder}/${subFolder}/${fileName}`  // ‚úÖ NOUVEAU

// üìå LOG : Chemin construit
logStructured("file_path_constructed", {
  requestId,
  reseau_id: reseauId,
  file_type: fileType,
  full_path: fullPath,
  file_size: file.size,
  file_name: file.name
});
```

---

#### 4.1.3 Diff Complet (Avant ‚Üí Apr√®s)
```diff
// supabase/functions/gestion-reseau-admin-fichiers/index.ts
// Ligne 51-86

-     // R√©cup√©rer l'organisation_id du r√©seau
-     const { data: reseauInfo } = await supabaseAdmin
-       .from('reseau')
-       .select('organisation_id')
-       .eq('reseau_id', reseauId)
-       .single()
-
-     if (!reseauInfo) throw new Error('R√©seau introuvable')
-
-     // üîß Construction du chemin selon votre design
-     const organisationFolder = `organisation-${reseauInfo.organisation_id}`
+     // ‚úÖ Construction du chemin bas√©e sur reseau_id (pas de requ√™te SQL n√©cessaire)
+     const reseauFolder = `reseau-${reseauId}`
      const subFolder = fileType === 'logo' ? '1-logos' : '2-documents-institutionnels'
      const timestamp = Date.now()
      const fileName = `${timestamp}-${file.name}`
-     const fullPath = `${organisationFolder}/${subFolder}/${fileName}`
+     const fullPath = `${reseauFolder}/${subFolder}/${fileName}`
+
+     // üìå LOG : Chemin construit
+     logStructured("file_path_constructed", {
+       requestId,
+       reseau_id: reseauId,
+       file_type: fileType,
+       full_path: fullPath,
+       file_size: file.size,
+       file_name: file.name
+     });
```

---

#### 4.1.4 Impact de la Modification

**Avant la modification:**
- 1 requ√™te SQL suppl√©mentaire pour r√©cup√©rer `organisation_id`
- Latence additionnelle (~10-50 ms)
- Point de d√©faillance si le r√©seau n'existe pas (bien que v√©rifi√© par Admin)

**Apr√®s la modification:**
- ‚úÖ 0 requ√™te SQL (chemin construit directement depuis `reseauId`)
- ‚úÖ Performance am√©lior√©e
- ‚úÖ Code simplifi√©
- ‚úÖ Coh√©rence avec la nouvelle policy RLS (bas√©e sur `reseau_id`)

---

### 4.2 V√©rification des Autres Edge Functions

#### 4.2.1 `gestion-reseau-admin/index.ts`
**√âtat:** ‚úÖ Aucune modification n√©cessaire  
**Raison:** Ne g√®re pas de fichiers, uniquement la liste des r√©seaux

---

#### 4.2.2 `gestion-reseau-admin-donnees/index.ts`
**√âtat:** ‚úÖ Aucune modification n√©cessaire  
**Raison:** Ne g√®re pas de fichiers, lit uniquement `reseau.reseau_logo` et `reseau.reseau_ressources` (chemins stock√©s)

**Note:** Si `reseau.reseau_logo` contient un ancien chemin `organisation-{uuid}/...`, il faudra mettre √† jour manuellement les valeurs en base apr√®s la migration du bucket.

---

#### 4.2.3 `gestion-reseau-admin-update/index.ts`
**√âtat:** ‚úÖ Aucune modification n√©cessaire  
**Raison:** Ne g√®re pas de fichiers, met √† jour uniquement les champs de la table `reseau`

**V√©rification importante:**
- Le trigger `sync_reseau_to_direction_trigger` se d√©clenche automatiquement lors de l'UPDATE de `reseau.reseau_email` ou `reseau.reseau_telephone`
- Pas besoin de code applicatif suppl√©mentaire dans l'edge function

---

## üìä PARTIE 5 : R√âCAPITULATIF ET VALIDATION

### 5.1 Checklist de Migration

#### √âtape SQL
- [ ] Fonction `sync_reseau_to_direction()` cr√©√©e
- [ ] Trigger `sync_reseau_to_direction_trigger` cr√©√©
- [ ] Test de synchronisation `reseau.reseau_email` ‚Üí `reseau_direction.reseau_direction_email` OK
- [ ] Test de synchronisation `reseau.reseau_telephone` ‚Üí `reseau_direction.reseau_direction_telephone` OK
- [ ] Logs visibles dans Supabase Logs (RAISE NOTICE)
- [ ] Audit dans `1_historique_supabase` (optionnel, si activ√©)

---

#### √âtape Bucket
- [ ] Ancienne policy `"RLS reseau files access"` supprim√©e
- [ ] Nouvelle policy `"RLS reseau files by reseau_id"` cr√©√©e
- [ ] Test d'acc√®s Admin PRESENCA : ‚úÖ Tous les fichiers accessibles
- [ ] Test d'acc√®s Utilisateur R√©seau A : ‚úÖ Fichiers de A accessibles, fichiers de B inaccessibles
- [ ] Test d'upload : Chemin g√©n√©r√© = `reseau-{uuid}/1-logos/{timestamp}-fichier.ext`

---

#### √âtape Edge Functions
- [ ] `gestion-reseau-admin-fichiers/index.ts` modifi√© (lignes 51-86)
- [ ] Suppression de la requ√™te `select('organisation_id')`
- [ ] Remplacement de `organisation-${reseauInfo.organisation_id}` par `reseau-${reseauId}`
- [ ] Logs structur√©s ajout√©s (`logStructured("file_path_constructed", ...)`)
- [ ] Edge function red√©ploy√©e (automatique avec Lovable)
- [ ] Test d'upload via le formulaire : ‚úÖ Chemin correct dans le bucket

---

### 5.2 Tests de Non-R√©gression

#### Test #1 : Formulaire de Cr√©ation (ne doit PAS √™tre impact√©)
**Action:** Cr√©er un nouveau r√©seau via le formulaire de cr√©ation  
**R√©sultat attendu:**
- ‚úÖ Cr√©ation OK via `create_reseau_compte_complet()`
- ‚úÖ `reseau.reseau_email = reseau_direction.reseau_direction_email` (√† la cr√©ation)
- ‚úÖ Aucune erreur de trigger

---

#### Test #2 : Formulaire de Gestion - Onglet G√©n√©ral
**Action:** Modifier `reseau_nom`, `reseau_adresse`, `reseau_siret` (sans toucher email/telephone)  
**R√©sultat attendu:**
- ‚úÖ Mise √† jour OK dans `reseau`
- ‚ùå Trigger NE SE D√âCLENCHE PAS (optimisation via `AFTER UPDATE OF`)
- ‚úÖ `reseau_direction` INCHANG√â

---

#### Test #3 : Formulaire de Gestion - Onglet Int√©grations
**Action:** Modifier `brevo_api_key` (sans toucher les donn√©es r√©seau)  
**R√©sultat attendu:**
- ‚úÖ Mise √† jour OK dans `brevo_connexion`
- ‚ùå Trigger NE SE D√âCLENCHE PAS (pas de changement dans `reseau`)
- ‚úÖ `reseau_direction` INCHANG√â

---

#### Test #4 : Formulaire de Gestion - Onglet Fichiers
**Action:** Upload d'un fichier `logo.png`  
**R√©sultat attendu:**
- ‚úÖ Chemin g√©n√©r√© : `reseau-{uuid}/1-logos/{timestamp}-logo.png`
- ‚úÖ Fichier visible dans le bucket Supabase
- ‚úÖ `reseau.reseau_logo` mis √† jour avec le nouveau chemin
- ‚úÖ Aucune erreur RLS (Admin PRESENCA)

---

### 5.3 Points d'Attention

#### ‚ö†Ô∏è Point #1 : `auth.uid()` dans le Trigger
**Situation:** Le trigger utilise `auth.uid()` pour renseigner `reseau_direction_updated_by`

**Comportement:**
- ‚úÖ Si l'UPDATE provient d'un utilisateur authentifi√© ‚Üí `auth.uid()` retourne l'UUID de l'utilisateur
- ‚ùå Si l'UPDATE provient d'une edge function avec SERVICE_ROLE_KEY ‚Üí `auth.uid()` retourne NULL

**Solution:**
- **Option A (recommand√©e)** : Accepter `updated_by = NULL` si l'op√©ration vient du SERVICE_ROLE_KEY
- **Option B** : L'edge function passe un contexte utilisateur (header `X-User-Id`) et le trigger lit `current_setting('request.jwt.claims')::json->>'sub'`

**Choix actuel:** Option A (simplification)

---

#### ‚ö†Ô∏è Point #2 : Migration des Valeurs Existantes de `reseau.reseau_logo`
**Situation:** Si des r√©seaux ont d√©j√† un `reseau_logo` avec un ancien chemin `organisation-{uuid}/...`

**Impact:**
- ‚ùå Les anciennes URLs ne fonctionneront plus apr√®s la migration de la policy
- ‚úÖ Bucket actuellement VIDE ‚Üí Pas de fichiers √† migrer

**Action requise (si fichiers existants):**
```sql
-- Mise √† jour manuelle des chemins (si n√©cessaire)
UPDATE reseau
SET reseau_logo = REPLACE(reseau_logo, 'organisation-', 'reseau-')
WHERE reseau_logo LIKE 'organisation-%';

-- Idem pour reseau_ressources (tableau)
UPDATE reseau
SET reseau_ressources = ARRAY(
  SELECT REPLACE(elem, 'organisation-', 'reseau-')
  FROM unnest(reseau_ressources) AS elem
)
WHERE EXISTS (
  SELECT 1 FROM unnest(reseau_ressources) AS elem
  WHERE elem LIKE 'organisation-%'
);
```

---

#### ‚ö†Ô∏è Point #3 : Ordre d'Ex√©cution de la Migration
**CRITIQUE:** Respecter l'ordre suivant pour √©viter les erreurs

1. ‚úÖ Cr√©er la fonction SQL `sync_reseau_to_direction()`
2. ‚úÖ Cr√©er le trigger `sync_reseau_to_direction_trigger`
3. ‚úÖ Tester la synchronisation (UPDATE manuel)
4. ‚úÖ Supprimer l'ancienne policy bucket
5. ‚úÖ Cr√©er la nouvelle policy bucket
6. ‚úÖ Modifier l'edge function `gestion-reseau-admin-fichiers`
7. ‚úÖ Red√©ployer l'edge function (automatique avec Lovable)
8. ‚úÖ Tester l'upload de fichiers

**‚ùå NE PAS FAIRE :**
- Supprimer l'ancienne policy avant de cr√©er la nouvelle ‚Üí Bucket inaccessible
- Modifier l'edge function avant de cr√©er la nouvelle policy ‚Üí Erreurs RLS
- Cr√©er le trigger avant la fonction ‚Üí Erreur de r√©f√©rence

---

## üéØ CONCLUSION

### R√©sum√© des Changements

#### SQL
‚úÖ **Fonction** `sync_reseau_to_direction()` : Synchronisation automatique email/telephone  
‚úÖ **Trigger** `sync_reseau_to_direction_trigger` : D√©clenchement AFTER UPDATE (optimis√©)  
‚úÖ **Audit** : Logs dans console + table `1_historique_supabase` (optionnel)

#### Bucket
‚úÖ **Structure** : Migration de `organisation-{uuid}` vers `reseau-{uuid}`  
‚úÖ **Policy RLS** : Nouvelle policy bas√©e sur `reseau_id` (isolation par r√©seau)  
‚úÖ **S√©curit√©** : Admin PRESENCA acc√®s total, utilisateurs acc√®s restreint √† leur r√©seau

#### Edge Functions
‚úÖ **gestion-reseau-admin-fichiers** : Suppression requ√™te SQL inutile, chemin direct via `reseau_id`  
‚úÖ **Autres edge functions** : Aucune modification n√©cessaire (trigger g√®re la synchro)

---

### Validation Finale

**Avant de d√©ployer en production :**
1. Ex√©cuter TOUS les scripts SQL dans l'ordre (voir section 3.4)
2. V√©rifier les logs Supabase apr√®s chaque √©tape
3. Tester la synchronisation email/telephone (UPDATE manuel)
4. Tester l'upload de fichiers (formulaire de gestion)
5. V√©rifier que le formulaire de cr√©ation fonctionne toujours (non-r√©gression)
6. V√©rifier les logs des edge functions (onglet Logs Supabase)

---

### Prochaines √âtapes (apr√®s validation)

#### Phase 1 : D√©ploiement
- [ ] Valider ce document avec l'√©quipe
- [ ] Ex√©cuter les migrations SQL (environnement de test d'abord)
- [ ] Modifier l'edge function `gestion-reseau-admin-fichiers`
- [ ] Red√©ployer (automatique avec Lovable)

#### Phase 2 : Am√©liorations Futures (optionnel)
- [ ] Fonction SQL `validate_reseau_files()` pour v√©rifier la coh√©rence bucket ‚Üî table
- [ ] Gestion de la suppression de fichiers : mise √† jour automatique de `reseau_ressources`
- [ ] Dashboard Admin : statistiques d'utilisation du bucket par r√©seau
- [ ] Notifications : alertes si un fichier est manquant dans le bucket

---

**FIN DU DOCUMENT**

---

**Note :** Ce document est une **√âTUDE PR√âALABLE** et ne doit **PAS √™tre d√©ploy√©** sans validation explicite. Toutes les modifications SQL et edge functions doivent √™tre test√©es en environnement de d√©veloppement avant toute mise en production.

---

**Auteur :** PRESENCA (Admin)  
**Date de cr√©ation :** 30 Janvier 2025  
**Derni√®re mise √† jour :** 30 Janvier 2025  
**Version :** 1.0 (DRAFT)
