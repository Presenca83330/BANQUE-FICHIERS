
# BIBLE COMPLÈTE N2 - Processus de Conception des Formulaires Gestion des Tables à partir de Formulaire Table Réseau
## (Numéroration de la structure de nommage de la table)
- Par convention les Hooks et composants des formulaires des tables lors de leur conception suivent ce nomage
    - 1.Reseau/
    - 2.ReseauDirection/
    - 3.ReseauAgence/
    - 4.ReseauAgenceResponsable/
    - 5.ReseauAgenceCollaborateur/
    - 6.AgenceIndependante/
    - 7.AgenceIndependanteResponsable/
    - 8.AgenceIndependanteCollaborateur/
---
---
# Architecture Complète
## Structure des Dossiers
```
src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/
├── 3.FormReseauGestion.tsx          # Composant principal du formulaire

src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/
├── types.ts 
├── useReseauFormData.ts 
└── useReseauIntegrations.ts 

src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components
├── ReseauSelector.tsx          

supabase/functions/
└── gestion-reseau-admin/
    └── index.ts                   
└── gestion-reseau-admin-donnees/
    └── index.ts          
└── gestion-reseau-admin-fichiers/
    └── index.ts          
└── gestion-reseau-admin-update/
    └── index.ts          

supabase/functions/_shared/
└── cors.ts                        # Configuration CORS
```
---
---
---
---
# ÉTAPE INITIALE IMPÉRATIVE : Tables Reference
**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/.TablesReferenceReseau.ts`
- Suivre la directive : public/3. ReadMe FormPresenca/01.FormReseau/3.FormCreateurGestion/02.1.CadrageInitialTable.md
- Toujours utiliser la structure de nomage
- src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/(Numéroration de la structure de nommage de la table)/.TablesReferenceReseau.ts
---
---
# ÉTAPE 1 : Types TypeScript
**Fichier :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/types.ts`
- Toujours utiliser la structure de nomage
- src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/(Numéroration de la structure de nommage de la table)/hooks/types.ts
```typescript
// Types partagés pour la gestion des réseaux

// ==============================
// Données du Réseau
// ==============================
export interface ReseauFormData {
  reseau_id: string;
  organisation_id: string;
  reseau_nom: string;
  reseau_identite_commerciale?: string | null;
  reseau_adresse?: string | null;
  reseau_code_postal?: string | null;
  reseau_ville?: string | null;
  reseau_siret?: string | null;
  reseau_statut?: string | null;
  reseau_logo?: string | null;
  reseau_ressources?: string[]; // fichiers stockés
  reseau_telephone?: string | null; // Point de vérité
  reseau_email?: string | null;     // Point de vérité
  reseau_brevo_connexion_id?: string | null;
  reseau_zoho_connexion_id?: string | null;
  reseau_openai_connexion_id?: string | null;
}

// ==============================
// Eléments pour le sélecteur
// ==============================
// ⚠️ Minimal : uniquement les champs nécessaires pour le dropdown
export interface ReseauSelectorItem {
  reseau_nom: string;
  reseau_id: string;
}

// ==============================
// Intégrations - Tables connexions
// ==============================
export interface BrevoIntegration {
  brevo_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  brevo_api_key?: string | null;
  brevo_email_compte?: string | null;
  brevo_nom_compte?: string | null;
}

export interface ZohoIntegration {
  zoho_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  zoho_api_key?: string | null;
  zoho_email_compte?: string | null;
  zoho_nom_compte?: string | null;
}

export interface OpenAIIntegration {
  openai_connexion_id: string;
  organisation_id: string;
  reseau_id: string;
  openai_api_key?: string | null;
  openai_email_compte?: string | null;
}

// ==============================
// Etats du formulaire (Front) - UI UNIQUEMENT
// ==============================
export interface BrevoFormState {
  brevo_api_key?: string;
  brevo_email_compte?: string;
  brevo_nom_compte?: string;
}

export interface ZohoFormState {
  zoho_api_key?: string;
  zoho_email_compte?: string;
  zoho_nom_compte?: string;
}

export interface OpenAIFormState {
  openai_api_key?: string;
  openai_email_compte?: string;
}

export interface IntegrationsState {
  brevo: BrevoFormState;
  zoho: ZohoFormState;
  openai: OpenAIFormState;
}

// ==============================
// Erreurs de validation
// ==============================
export type ValidationErrors = {
  [K in keyof Partial<ReseauFormData>]?: string;
};
```
---
## **Explications. Comment générer le fichier types.ts pour la gestion**
### Sous-Étape 1 : Créer l'interface {Table}FormData (Données complètes)
- Objectif : Définir tous les champs éditables de la table pour le formulaire de gestion
- Directives :
  - Consulter impérativement la Table Référence pour avoir les noms exacts des colonnes
  - Vérifier dans Supabase les noms réels des colonnes (préfixes corrects)
  - TOUJOURS inclure : {table}_id et organisation_id en premier
  - Adapter tous les champs avec le préfixe de la table (ex: reseau_nom, agence_indep_nom)
  - Inclure les champs de synchronisation (ex: reseau_telephone, reseau_email) avec commentaire "Point de vérité"
  - Inclure les champs d'intégrations : {table}_brevo_connexion_id, {table}_zoho_connexion_id, {table}_openai_connexion_id
  - Tous les champs sauf les IDs sont optionnels : string | null ou string[] pour les fichiers
```typescript
export interface ReseauFormData {           // ← À PERSONNALISER (ex: AgenceIndepFormData)
  reseau_id: string;                        // ← À PERSONNALISER (ex: agence_indep_id)
  organisation_id: string;                  // CONSERVER
  reseau_nom: string;                       // ← À PERSONNALISER selon table
  // ... autres champs de la table
  reseau_telephone?: string | null;         // ← À PERSONNALISER - Point de vérité
  reseau_email?: string | null;             // ← À PERSONNALISER - Point de vérité
  reseau_brevo_connexion_id?: string | null; // ← À PERSONNALISER
  reseau_zoho_connexion_id?: string | null;  // ← À PERSONNALISER
  reseau_openai_connexion_id?: string | null;// ← À PERSONNALISER
}
```
  - Votre table	Préfixe colonnes	Exemple ID	Exemple champ
  - reseau	reseau_	reseau_id	reseau_nom
  - reseau_agence	reseau_agence_	reseau_agence_id	reseau_agence_nom
  - agence_independante	agence_indep_	agence_indep_id	agence_indep_nom
---
### Sous-Étape 2 : Créer l'interface {Table}SelectorItem (Sélecteur minimal)
- Objectif : Interface minimale pour le dropdown de sélection (uniquement nom + id)
- Directives :
  - TOUJOURS respecter l'ordre : nom en 1er, id en 2ème
  - Adapter le nom de l'interface : {Table}SelectorItem
  - Adapter les champs avec le préfixe de la table
  - Vérifier le nom exact du champ "nom" dans Supabase (ex: reseau_nom, agence_indep_nom)
```typescript
export interface ReseauSelectorItem {       // ← À PERSONNALISER (ex: AgenceIndepSelectorItem)
  reseau_nom: string;                       // ← À PERSONNALISER (toujours le champ "nom" en 1er)
  reseau_id: string;                        // ← À PERSONNALISER (l'ID en 2ème)
}
```
---
### Sous-Étape 3 : Créer les interfaces d'intégrations (Tables de connexion)
- Objectif : Typer les données des tables brevo_connexion, zoho_connexion, openai_connexion
- Directives :
  - CONSERVER les noms d'interfaces identiques : BrevoIntegration, ZohoIntegration, OpenAIIntegration
  - CONSERVER tous les champs de chaque intégration (préfixes brevo_, zoho_, openai_)
  - ADAPTER uniquement le champ de liaison à la table :
    - reseau_id pour table réseau
    - reseau_agence_id pour table reseau_agence
    - agence_indep_id pour table agence_independante
    - Consulter le document 10. Structure des Tables de Connexion pour la logique de liaison
```typescript
export interface BrevoIntegration {         // CONSERVER (nom identique)
  brevo_connexion_id: string;               // CONSERVER
  organisation_id: string;                  // CONSERVER
  reseau_id: string;                        // ← À PERSONNALISER (reseau_agence_id, agence_indep_id)
  brevo_api_key?: string | null;            // CONSERVER
  brevo_email_compte?: string | null;       // CONSERVER
  brevo_nom_compte?: string | null;         // CONSERVER
}

export interface ZohoIntegration {          // CONSERVER (nom identique)
  zoho_connexion_id: string;                // CONSERVER
  organisation_id: string;                  // CONSERVER
  reseau_id: string;                        // ← À PERSONNALISER
  zoho_api_key?: string | null;             // CONSERVER
  zoho_email_compte?: string | null;        // CONSERVER
  zoho_nom_compte?: string | null;          // CONSERVER
}

export interface OpenAIIntegration {        // CONSERVER (nom identique)
  openai_connexion_id: string;              // CONSERVER
  organisation_id: string;                  // CONSERVER
  reseau_id: string;                        // ← À PERSONNALISER
  openai_api_key?: string | null;           // CONSERVER
  openai_email_compte?: string | null;      // CONSERVER
}
```
---
### Sous-Étape 4 : Créer les interfaces d'état formulaire (UI uniquement)
- Objectif : Gérer l'état local du formulaire d'intégrations (onglet Intégrations)
- Directives :
  - CONSERVER intégralement toutes les interfaces :
    - BrevoFormState
    - ZohoFormState
    - OpenAIFormState
    - IntegrationsState
  - Ces interfaces sont identiques pour toutes les tables (aucune personnalisation)
```typescript
export interface BrevoFormState {           // CONSERVER intégralement
  brevo_api_key?: string;
  brevo_email_compte?: string;
  brevo_nom_compte?: string;
}

export interface ZohoFormState {            // CONSERVER intégralement
  zoho_api_key?: string;
  zoho_email_compte?: string;
  zoho_nom_compte?: string;
}

export interface OpenAIFormState {          // CONSERVER intégralement
  openai_api_key?: string;
  openai_email_compte?: string;
}

export interface IntegrationsState {        // CONSERVER intégralement
  brevo: BrevoFormState;
  zoho: ZohoFormState;
  openai: OpenAIFormState;
}
```
---
### Sous-Étape 5 : Créer le type ValidationErrors
- Objectif : Gérer les messages d'erreur de validation du formulaire (onglet Général)
- Directives :
  - CONSERVER le nom du type : ValidationErrors
  - ADAPTER uniquement la référence à {Table}FormData
  - Utilise Partial et keyof pour générer automatiquement les clés optionnelles
```typescript
export type ValidationErrors = {                     // CONSERVER (nom identique)
  [K in keyof Partial<ReseauFormData>]?: string;     // ← À PERSONNALISER (remplacer ReseauFormData)
};
```
  - Exemple pour agence_independante :
```typescript
export type ValidationErrors = {
  [K in keyof Partial<AgenceIndepFormData>]?: string;
};
```
---
---
# ÉTAPE 2 : MIGRATION SQL 1 - Fonctions + Trigger
```typescript
-- ============================================================
-- MIGRATION 1 - Fonctions + Trigger reseau
-- ============================================================

-- 1. Fonction utilitaire : get_user_reseau_id()
CREATE OR REPLACE FUNCTION public.get_user_reseau_id(user_uuid uuid)
RETURNS uuid
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path TO public
AS $$
  SELECT r.reseau_id
  FROM reseau r
  WHERE r.organisation_id = get_user_organisation_id(user_uuid)
  LIMIT 1;
$$;

-- 2. Fonction de synchronisation reseau → reseau_direction
CREATE OR REPLACE FUNCTION public.sync_reseau_to_direction()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
BEGIN
  UPDATE reseau_direction
  SET 
    reseau_direction_email = NEW.reseau_email,
    reseau_direction_telephone = NEW.reseau_telephone,
    reseau_direction_updated_at = NOW(),
    reseau_direction_updated_by = auth.uid()
  WHERE reseau_id = NEW.reseau_id;

  RETURN NEW;
END;
$$;

-- 3. Trigger sur la table reseau
DROP TRIGGER IF EXISTS trigger_sync_reseau_to_direction ON reseau;

CREATE TRIGGER trigger_sync_reseau_to_direction
AFTER UPDATE OF reseau_email, reseau_telephone
ON reseau
FOR EACH ROW
EXECUTE FUNCTION sync_reseau_to_direction();

```
---
## **Explications. Comment générer la migration SQL pour les fonctions et trigger de gestion**
---
### Sous-Étape 1 : Créer la fonction utilitaire get_user_{table}_id()
- Objectif : Récupérer l'ID de la table métier liée à l'organisation de l'utilisateur connecté
- Directives :
  - Adapter le nom de la fonction : get_user_{table}_id()
    - Exemple : get_user_reseau_id(), get_user_agence_indep_id(), get_user_reseau_agence_id()
  - CONSERVER : user_uuid uuid en paramètre
  - CONSERVER : RETURNS uuid
  - CONSERVER : LANGUAGE sql, STABLE, SECURITY DEFINER, SET search_path TO public
  - Adapter la requête SELECT selon la table :
    - Personnaliser le nom de la table dans FROM
    - Personnaliser le nom de la colonne ID retournée (ex: r.reseau_id, a.agence_indep_id)
  - Conserver WHERE r.organisation_id = get_user_organisation_id(user_uuid)
  - Conserver LIMIT 1
    - Votre table	Nom fonction	FROM table	Colonne ID
    - reseau	get_user_reseau_id	FROM reseau r	r.reseau_id
    - reseau_agence	get_user_reseau_agence_id	FROM reseau_agence ra	ra.reseau_agence_id
    - agence_independante	get_user_agence_indep_id	FROM agence_independante a	a.agence_indep_id
---
### Sous-Étape 2 : Créer la fonction de synchronisation sync_{table}to{responsable}()
- Objectif : Synchroniser automatiquement les champs email et telephone de la table métier vers la table responsable
- Directives :
  - Adapter le nom de la fonction : sync_{table}_to_{responsable}()
    - Exemple : sync_reseau_to_direction(), sync_agence_indep_to_responsable()
  - CONSERVER : RETURNS trigger, LANGUAGE plpgsql, SECURITY DEFINER, SET search_path TO public
    - Dans le BEGIN...END :
    - Personnaliser le nom de la table responsable dans UPDATE {table_responsable}
    - Personnaliser les colonnes SET selon les noms exacts dans Supabase :
```typescript
{responsable}_email = NEW.{table}_email
{responsable}_telephone = NEW.{table}_telephone
{responsable}_updated_at = NOW()
{responsable}_updated_by = auth.uid()
```
  - Personnaliser la clause WHERE avec l'ID de liaison :
    - WHERE {table}_id = NEW.{table}_id
  - CONSERVER : RETURN NEW;

- Référence obligatoire :
  - Consulter public/1. Documents Stratégiques/07.1. Stratégie - Gestion des informations partagées entre Réseau et Réseau Direction.md
  - Votre table	Nom fonction	UPDATE table	WHERE condition
  - reseau	sync_reseau_to_direction	UPDATE reseau_direction	WHERE reseau_id = NEW.reseau_id
  - reseau_agence	sync_reseau_agence_to_responsable	UPDATE reseau_agence_responsable	WHERE reseau_agence_id = NEW.reseau_agence_id
  - agence_independante	sync_agence_indep_to_responsable	UPDATE agence_independante_responsable	WHERE agence_indep_id = NEW.agence_indep_id
---
### Sous-Étape 3 : Créer le trigger sur la table métier
- Objectif : Déclencher automatiquement la synchronisation lors de la modification des champs email et telephone
- Directives :
  - Toujours commencer par DROP TRIGGER IF EXISTS pour éviter les erreurs
  - Adapter le nom du trigger : trigger_sync_{table}_to_{responsable}
  - Adapter la clause AFTER UPDATE OF avec les colonnes exactes :
  - AFTER UPDATE OF {table}_email, {table}_telephone
  - Adapter ON {table} avec le nom de la table métier
  - CONSERVER : FOR EACH ROW
  - Adapter EXECUTE FUNCTION avec le nom de la fonction créée à la sous-étape 2
  - Votre table	Nom trigger	ON table	UPDATE OF colonnes	EXECUTE FUNCTION
    - reseau	trigger_sync_reseau_to_direction	ON reseau	reseau_email, reseau_telephone	sync_reseau_to_direction()
    - reseau_agence	trigger_sync_reseau_agence_to_responsable	ON reseau_agence	reseau_agence_email, reseau_agence_telephone	sync_reseau_agence_to_responsable()
    - agence_independante	trigger_sync_agence_indep_to_responsable	ON agence_independante	agence_indep_email, agence_indep_telephone	sync_agence_indep_to_responsable()

- Points Critiques à Vérifier
  - Consulter impérativement la Table Référence pour les noms exacts des colonnes
  - Vérifier dans Supabase les noms réels des tables et colonnes (préfixes corrects)
  - Respecter la logique de synchronisation : table métier = source de vérité → table responsable
  - Toujours utiliser SECURITY DEFINER pour les fonctions (exécution avec privilèges élevés)
---
---
# ÉTAPE 3 : Edge Function - Liste (Selector)
**Fichier :** `supabase/functions/gestion-reseau-admin/index.ts`
- Toujours utiliser la structure de nomage
- supabase/functions/gestion-(table-admin/index.ts
```typescript
// Liste les réseaux pour l'espace de gestion.
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// --- CORS -------------------------------------------------------------------
const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

// --- Logs structurés --------------------------------------------------------
function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

// --- Handler ----------------------------------------------------------------
Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  // Preflight CORS
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const t0 = performance.now();

    // Projection MINIMALE pour le sélecteur : reseau_nom (1er), reseau_id
    const { data, error } = await supabase
      .from("reseau")
      .select("reseau_nom, reseau_id")
      .order("reseau_nom", { ascending: true });

    const durationMs = Math.round(performance.now() - t0);

    if (error) {
      logStructured("reseau_list_error", { requestId, error: error.message, duration_ms: durationMs });
      return new Response(
        JSON.stringify({
          success: false,
          error: "db_error_reseau_list",
          details: error.message,
          requestId
        }),
        { 
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        }
      );
    }

    // Forcer l'ordre des propriétés (reseau_nom en 1er) dans la réponse
    const dataMinimal = (data ?? []).map((r: any) => ({
      reseau_nom: r.reseau_nom,
      reseau_id: r.reseau_id,
    }));

    logStructured("reseau_list_ok", {
      requestId,
      result_count: dataMinimal.length,
      duration_ms: durationMs,
    });

    // ✅ PATTERN DATA.DATA RESPECTÉ
    return new Response(
      JSON.stringify({
        success: true,
        data: dataMinimal,  // ← Données dans "data"
        message: `${dataMinimal.length} réseau(x) récupéré(s)`,
        requestId
      }),
      { 
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );

  } catch (e) {
    logStructured("unhandled_exception", {
      requestId,
      msg: e instanceof Error ? e.message : String(e),
    });
    return new Response(
      JSON.stringify({
        success: false,
        error: "internal_error",
        requestId
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});
```
---
## **Explications. Comment générer l'Edge Function Liste pour le sélecteur**
---
### Sous-Étape 1 : Imports et configuration Supabase Admin
- Objectif : Initialiser le client Supabase avec SERVICE_ROLE_KEY pour bypasser RLS
- Directives :
  - CONSERVER l'import ESM : "https://esm.sh/@supabase/supabase-js@2"
  - CONSERVER les variables d'environnement : SUPABASE_URL et SUPABASE_SERVICE_ROLE_KEY
  - CONSERVER la configuration du client avec auth: { autoRefreshToken: false, persistSession: false }
---
### Sous-Étape 2 : Configuration CORS
- Objectif : Permettre les appels depuis le frontend
- Directives :
  - CONSERVER intégralement l'objet corsHeaders
  - CONSERVER les méthodes autorisées : "POST, GET, OPTIONS"
---
### Sous-Étape 3 : Fonction de logs structurés
- Objectif : Tracer les événements de manière structurée (debugging)
- Directives :
  - CONSERVER intégralement la fonction logStructured(event, payload)
  - Cette fonction est identique pour toutes les tables
---
### Sous-Étape 4 : Handler principal - Preflight CORS
- Objectif : Gérer les requêtes OPTIONS (preflight CORS)
- Directives :
  - CONSERVER intégralement le bloc if (req.method === "OPTIONS")
  - Retourne toujours status: 204 avec corsHeaders
---
### Sous-Étape 5 : Requête SELECT - Projection minimale
- Objectif : Récupérer uniquement les champs nécessaires pour le dropdown (nom + id)
- Directives :
  - Adapter le nom de la table dans .from("{table}")
  - Adapter la projection .select() avec exactement 2 colonnes dans cet ordre :
```typescript
{table}_nom (champ nom en 1er)
{table}_id (champ id en 2ème)
```
  - CONSERVER .order("{table}_nom", { ascending: true })
  - Vérifier le nom exact du champ "nom" dans Supabase (peut varier selon la table)
```typescript
Votre tab```typescriptle	.from()	.select()	.order()
reseau	.from("reseau")	"reseau_nom, reseau_id"	.order("reseau_nom", ...)
reseau_agence	.from("reseau_agence")	"reseau_agence_nom, reseau_agence_id"	.order("reseau_agence_nom", ...)
agence_independante	.from("agence_independante")	"agence_indep_nom, agence_indep_id"	.order("agence_indep_nom", ...)
```
---
### Sous-Étape 6 : Gestion d'erreur DB
- Objectif : Retourner une erreur structurée si la requête échoue
- Directives :
  - Adapter le message de log : "{table}_list_error"
  - Adapter le code d'erreur : "db_error_{table}_list"
  - CONSERVER : status: 500, structure JSON avec success: false, error, details, requestId
---
### Sous-Étape 7 : Forcer l'ordre des propriétés dans la réponse
- Objectif : Garantir que le nom est toujours en 1ère position dans l'objet JSON (pour cohérence)
- Directives :
  - Adapter le mapping avec les noms exacts des colonnes :
```typescript
const dataMinimal = (data ?? []).map((r: any) => ({
  {table}_nom: r.{table}_nom,    // ← À PERSONNALISER (toujours en 1er)
  {table}_id: r.{table}_id,      // ← À PERSONNALISER (toujours en 2ème)
}));
```
  - Cette étape garantit l'ordre même si Supabase retourne les colonnes dans un autre ordre
---
### Sous-Étape 8 : Log de succès
- Objectif : Tracer le nombre de résultats récupérés
- Directives :
  - Adapter le message de log : "{table}_list_ok"
  - CONSERVER : result_count, duration_ms, requestId
---
### Sous-Étape 9 : Retour de la réponse (Pattern data.data)
- Objectif : Respecter le pattern data.data obligatoire pour tous les Edge Functions
- Directives :
  - CONSERVER intégralement la structure JSON de retour :
    - success: true
    - data: dataMinimal (← les données dans "data")
    - message (adapter le texte avec le nom de la table au singulier/pluriel)
    - requestId
  - CONSERVER : status: 200, Content-Type: application/json
  - ATTENTION : Ne jamais retourner directement dataMinimal, toujours l'encapsuler dans data

- Référence obligatoire :
  - public/3. ReadMe FormPresenca/01.FormReseau/1.FormCreateur/06.GUIDE-DataData-EdgeFunctions.md
---
### Sous-Étape 10 : Gestion des exceptions non gérées
- Objectif : Capturer toute erreur imprévue
- Directives :
  - CONSERVER intégralement le bloc catch (e)
  - CONSERVER la structure de retour : success: false, error: "internal_error", status: 500

- Points Critiques à Vérifier
  - Vérifier le nom exact du champ "nom" dans Supabase (ex: reseau_nom, agence_indep_nom)
  - Respecter l'ordre : nom en 1er, id en 2ème (dans .select() ET dans le mapping)
  - Pattern data.data obligatoire : toujours encapsuler les données dans { success: true, data: ... }
  - SERVICE_ROLE_KEY utilisé = bypass total de RLS (fonction admin uniquement)
---
---
# ÉTAPE 4 : Composant Selector
**Fichier :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector.tsx`
- Toujours utiliser la structure de nomage
- src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/(Numéroration de la structure de nommage de la table)/components/ReseauSelector.tsx
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import type { ReseauSelectorItem } from '../hooks/types';

interface ReseauSelectorProps {
  reseaux: ReseauSelectorItem[];
  selectedReseauId: string;
  onSelect: (reseauId: string) => void;
  isLoading: boolean;
}

export const ReseauSelector: React.FC<ReseauSelectorProps> = ({
  reseaux,
  selectedReseauId,
  onSelect,
  isLoading,
}) => {
  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle className="text-xl font-semibold">Sélection du Réseau</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          <Select
            value={selectedReseauId}
            onValueChange={onSelect}
            disabled={isLoading}
          >
            <SelectTrigger className="w-full">
              <SelectValue 
                placeholder={
                  isLoading ? "Chargement des réseaux..." : 
                  "Sélectionner un réseau"
                } 
              />
            </SelectTrigger>
            <SelectContent>
              {reseaux?.map((reseau) => (
                <SelectItem key={reseau.reseau_id} value={reseau.reseau_id}>
                  {reseau.reseau_nom}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </CardContent>
    </Card>
  );
};

export default ReseauSelector;
```
---
## **Explications. Comment générer le composant Selector pour le dropdown**
---
### Sous-Étape 1 : Imports des composants UI
- Objectif : Importer les composants shadcn nécessaires pour le sélecteur
- Directives :
  - CONSERVER intégralement les imports de @/components/ui/card
  - CONSERVER intégralement les imports de @/components/ui/select
  - CONSERVER l'import React
  - Adapter uniquement l'import du type depuis types.ts :
    - import type { ReseauSelectorItem } from '../hooks/types';
    ← À PERSONNALISER (ex: AgenceIndepSelectorItem)
---
### Sous-Étape 2 : Interface Props du composant
- Objectif : Typer les props passées au composant Selector
- Directives :
  - Adapter le nom de l'interface : {Table}SelectorProps
  - Adapter le type du tableau : {table}s: {Table}SelectorItem[]
  - Adapter le nom de la prop ID : selected{Table}Id: string
  - CONSERVER : onSelect: (reseauId: string) => void (le paramètre reste générique)
  - CONSERVER : isLoading: boolean
    - Votre table	Nom interface	Prop tableau	Prop ID sélectionné
```typescript
reseau	ReseauSelectorProps	reseaux: ReseauSelectorItem[]	selectedReseauId: string
reseau_agence	ReseauAgenceSelectorProps	reseauxAgence: ReseauAgenceSelectorItem[]	selectedReseauAgenceId: string
agence_independante	AgenceIndepSelectorProps	agencesIndep: AgenceIndepSelectorItem[]	selectedAgenceIndepId: string
```
---
### Sous-Étape 3 : Déclaration du composant React.FC
- Objectif : Créer le composant fonctionnel avec destructuration des props
- Directives :
  - Adapter le nom du composant : export const {Table}Selector: React.FC<{Table}SelectorProps>
  - Adapter les noms des props destructurées selon l'interface définie à la sous-étape 2
  - CONSERVER : React.FC, syntaxe de destructuration, structure globale
---
### Sous-Étape 4 : Structure Card principale
- Objectif : Encapsuler le sélecteur dans une Card avec titre
- Directives :
  - CONSERVER : <Card className="mb-6">, <CardHeader>, <CardContent>.
  - Adapter le texte du titre dans <CardTitle> :
    - Exemple : "Sélection du Réseau", "Sélection de l'Agence Indépendante"
  - CONSERVER : className="text-xl font-semibold", className="space-y-3"
---
### Sous-Étape 5 : Composant Select (shadcn)
- Objectif : Créer le dropdown de sélection
- Directives :
  - Adapter la prop value : value={selected{Table}Id}
  - CONSERVER : onValueChange={onSelect} (fonction callback reste générique)
  - CONSERVER : disabled={isLoading}
  - CONSERVER : <SelectTrigger className="w-full">
---
### Sous-Étape 6 : SelectValue - Placeholder dynamique
- Objectif : Afficher un message différent selon l'état de chargement
- Directives :
  - Adapter les textes de placeholder selon la table :
    - État chargement : "Chargement des réseaux..."
    - ← À PERSONNALISER (ex: "Chargement des agences indépendantes...")
    - État normal : "Sélectionner un réseau"
    - ← À PERSONNALISER (ex: "Sélectionner une agence indépendante")
- CONSERVER : Ternaire isLoading ? ... : ...
---
### Sous-Étape 7 : SelectContent - Mapping des items
- Objectif : Générer dynamiquement les options du dropdown
- Directives :
  - Adapter le nom de la variable mappée : {table}s?.map(({table}) => ...)
  - Adapter la key : key={{table}.{table}_id}
  - Adapter la value : value={{table}.{table}_id}
  - Adapter l'affichage : {{table}.{table}_nom}
  - CONSERVER : <SelectContent>, <SelectItem>, opérateur de coalescence ?.
  - Votre table	Variable map	key	value	Texte affiché
```typescript
reseau	reseaux?.map((reseau) =>	reseau.reseau_id	reseau.reseau_id	reseau.reseau_nom
reseau_agence	reseauxAgence?.map((agence) =>	agence.reseau_agence_id	agence.reseau_agence_id	agence.reseau_agence_nom
agence_independante	agencesIndep?.map((agence) =>	agence.agence_indep_id	agence.agence_indep_id	agence.agence_indep_nom
```
---
### Sous-Étape 8 : Export par défaut
- Objectif : Permettre l'import par défaut du composant
- Directives :
  - Adapter le nom : export default {Table}Selector;
  - CONSERVER : Toujours faire un export default en plus du export const

- Points Critiques à Vérifier
  - Cohérence des noms : Props, interface, variable de map doivent correspondre
  - Vérifier les noms exacts : {table}_nom et {table}_id dans Supabase
  - Textes au pluriel/singulier : "Chargement des réseaux" vs "Sélectionner un réseau"
  - Import du bon type : {Table}SelectorItem doit correspondre au fichier types.ts
---
---
# ÉTAPE 5 : Edge Function - Données Complètes
**Fichier :** `supabase/functions/gestion-reseau-admin-donnees/index.ts`
- Toujours utiliser la structure de nomage
- supabase/functions/gestion-(table-admin-donnees/index.ts
```typescript
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: { autoRefreshToken: false, persistSession: false }
});

const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
};

function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

const RESEAU_PROJECTION = [
  "reseau_id",
  "organisation_id",
  "reseau_nom",
  "reseau_identite_commerciale",
  "reseau_adresse",
  "reseau_code_postal",
  "reseau_ville",
  "reseau_siret",
  "reseau_telephone",
  "reseau_email",
  "reseau_logo",
  "reseau_ressources",
  "reseau_brevo_connexion_id",
  "reseau_zoho_connexion_id",
  "reseau_openai_connexion_id",
].join(",");

const INTEGRATION_PROJECTION = "*";

Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    let reseauId: string | null = null;

    const url = new URL(req.url);
    const qsReseau = url.searchParams.get("reseau_id");
    if (qsReseau) reseauId = qsReseau;

    if (req.method === "POST") {
      try {
        const body = await req.json().catch(() => ({}));
        if (!reseauId && body && typeof body.reseau_id === "string") {
          reseauId = body.reseau_id;
        }
      } catch {}
    }

    if (!reseauId) {
      logStructured("missing_reseau_id", { requestId });
      return new Response(
        JSON.stringify({ success: false, error: "bad_request_missing_reseau_id", requestId }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const t0 = performance.now();

    const { data: reseau, error: reseauErr } = await supabase
      .from("reseau")
      .select(RESEAU_PROJECTION)
      .eq("reseau_id", reseauId)
      .maybeSingle();

    if (reseauErr) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_fetch_error", { requestId, reseau_id: reseauId, error: reseauErr.message, duration_ms: durationMs });
      return new Response(
        JSON.stringify({ success: false, error: "db_error_reseau_fetch", details: reseauErr.message, requestId }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    if (!reseau) {
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_not_found", { requestId, reseau_id: reseauId, duration_ms: durationMs });
      return new Response(
        JSON.stringify({ success: false, error: "not_found_reseau", requestId, reseau_id: reseauId }),
        { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const brevoId = reseau.reseau_brevo_connexion_id as string | null;
    const zohoId = reseau.reseau_zoho_connexion_id as string | null;
    const openaiId = reseau.reseau_openai_connexion_id as string | null;

    const promises: Promise<any>[] = [];
    const results: { brevo: any | null; zoho: any | null; openai: any | null } = {
      brevo: null,
      zoho: null,
      openai: null,
    };

    if (brevoId) {
      promises.push(
        supabase.from("brevo_connexion").select(INTEGRATION_PROJECTION).eq("brevo_connexion_id", brevoId).maybeSingle()
          .then(({ data, error }) => { if (error) throw new Error(`brevo_fetch_error:${error.message}`); results.brevo = data ?? null; })
      );
    }
    if (zohoId) {
      promises.push(
        supabase.from("zoho_connexion").select(INTEGRATION_PROJECTION).eq("zoho_connexion_id", zohoId).maybeSingle()
          .then(({ data, error }) => { if (error) throw new Error(`zoho_fetch_error:${error.message}`); results.zoho = data ?? null; })
      );
    }
    if (openaiId) {
      promises.push(
        supabase.from("openai_connexion").select(INTEGRATION_PROJECTION).eq("openai_connexion_id", openaiId).maybeSingle()
          .then(({ data, error }) => { if (error) throw new Error(`openai_fetch_error:${error.message}`); results.openai = data ?? null; })
      );
    }

    let integrationsError: string | null = null;
    try {
      if (promises.length > 0) await Promise.all(promises);
    } catch (e) {
      integrationsError = e instanceof Error ? e.message : String(e);
    }

    const durationMs = Math.round(performance.now() - t0);

    if (integrationsError) {
      logStructured("integrations_fetch_partial_error", {
        requestId, reseau_id: reseauId, error: integrationsError,
        found: { brevo: !!results.brevo, zoho: !!results.zoho, openai: !!results.openai },
        duration_ms: durationMs,
      });
      return new Response(
        JSON.stringify({
          success: true,
          data: { reseau, integrations: results },
          message: "Données réseau récupérées (quelques intégrations en erreur)",
          warning: "some_integrations_failed",
          requestId
        }),
        { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    logStructured("reseau_and_integrations_ok", {
      requestId, reseau_id: reseauId,
      found: { brevo: !!results.brevo, zoho: !!results.zoho, openai: !!results.openai },
      duration_ms: durationMs,
    });

    return new Response(
      JSON.stringify({ success: true, data: { reseau, integrations: results }, message: "Données réseau récupérées avec succès", requestId }),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (e) {
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) });
    return new Response(
      JSON.stringify({ success: false, error: "internal_error", requestId }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```
---
## **Explications. Comment concevoir une Edge Function de récupération des données complètes**

---

### Sous-Étape 1 : Imports et Configuration Supabase Admin avec SERVICE_ROLE_KEY

- **Objectif** : Initialiser le client Supabase avec SERVICE_ROLE_KEY pour bypasser RLS et accéder à toutes les données

- **Directives** :
  - **CONSERVER** tel quel les imports (URL ESM pour Deno)
  - **CONSERVER** la configuration supabaseAdmin avec les options d'auth désactivées
  - **CONSERVER** les variables d'environnement SUPABASE_URL et SERVICE_ROLE_KEY

```typescript
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";   // ← CONSERVER

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;                       // ← CONSERVER
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;     // ← CONSERVER

// Client admin (bypass RLS)
const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {          // ← CONSERVER
  auth: { autoRefreshToken: false, persistSession: false }                // ← CONSERVER
});
```

---

### Sous-Étape 2 : Configuration CORS et Logging

- **Objectif** : Configurer les headers CORS pour autoriser les appels depuis le frontend et créer une fonction de logging structuré

- **Directives** :
  - **CONSERVER** intégralement la configuration corsHeaders
  - **CONSERVER** la fonction logStructured pour les logs JSON

```typescript
const corsHeaders: HeadersInit = {                                        // ← CONSERVER
  "Access-Control-Allow-Origin": "*",                                     // ← CONSERVER
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type", // ← CONSERVER
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS",                   // ← CONSERVER
};

function logStructured(event: string, payload: Record) { // ← CONSERVER
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload })); // ← CONSERVER
}
```

---

### Sous-Étape 3 : Définir les Projections de Colonnes

- **Objectif** : Lister explicitement les colonnes à récupérer depuis la table métier et les tables d'intégrations

- **Directives** :
  - **À PERSONNALISER** : Nom de la constante selon la table (ex: `RESEAU_PROJECTION`, `AGENCE_INDEP_PROJECTION`)
  - **À PERSONNALISER** : Liste des colonnes avec les bons préfixes de table
  - **TOUJOURS INCLURE** : `{table}_id`, `organisation_id`, `{table}_brevo_connexion_id`, `{table}_zoho_connexion_id`, `{table}_openai_connexion_id`
  - **CONSERVER** : `INTEGRATION_PROJECTION = "*"`

```typescript
const RESEAU_PROJECTION = [                          // ← À PERSONNALISER (nom de la constante)
  "reseau_id",                                       // ← À PERSONNALISER (ID de la table)
  "organisation_id",                                 // ← CONSERVER
  "reseau_nom",                                      // ← À PERSONNALISER (colonnes de la table)
  "reseau_identite_commerciale",                     // ← À PERSONNALISER
  "reseau_adresse",                                  // ← À PERSONNALISER
  "reseau_code_postal",                              // ← À PERSONNALISER
  "reseau_ville",                                    // ← À PERSONNALISER
  "reseau_siret",                                    // ← À PERSONNALISER
  "reseau_telephone",                                // ← À PERSONNALISER
  "reseau_email",                                    // ← À PERSONNALISER
  "reseau_logo",                                     // ← À PERSONNALISER
  "reseau_ressources",                               // ← À PERSONNALISER
  "reseau_brevo_connexion_id",                       // ← À PERSONNALISER (préfixe de table)
  "reseau_zoho_connexion_id",                        // ← À PERSONNALISER (préfixe de table)
  "reseau_openai_connexion_id",                      // ← À PERSONNALISER (préfixe de table)
].join(",");

const INTEGRATION_PROJECTION = "*";                  // ← CONSERVER
```

---

### Sous-Étape 4 : Handler Principal et Gestion OPTIONS (CORS Preflight)

- **Objectif** : Créer le handler Deno.serve et gérer les requêtes OPTIONS pour CORS

- **Directives** :
  - **CONSERVER** intégralement la structure Deno.serve
  - **CONSERVER** la génération du requestId
  - **CONSERVER** le handler OPTIONS

```typescript
Deno.serve(async (req) => {                          // ← CONSERVER
  const requestId = crypto.randomUUID();             // ← CONSERVER

  if (req.method === "OPTIONS") {                    // ← CONSERVER
    return new Response(null, { headers: corsHeaders, status: 204 }); // ← CONSERVER
  }
```

---

### Sous-Étape 5 : Extraction du Paramètre ID depuis Query String ou Body

- **Objectif** : Récupérer l'ID de l'entité à charger depuis la query string ou le body JSON

- **Directives** :
  - **À PERSONNALISER** : Nom de la variable selon la table (ex: `reseauId`, `agenceIndepId`, `reseauAgenceId`)
  - **À PERSONNALISER** : Nom du paramètre en snake_case (ex: `reseau_id`, `agence_indep_id`, `reseau_agence_id`)
  - **CONSERVER** : La logique d'extraction (query string puis body)

```typescript
  try {
    let reseauId: string | null = null;              // ← À PERSONNALISER (nom variable)

    const url = new URL(req.url);                    // ← CONSERVER
    const qsReseau = url.searchParams.get("reseau_id"); // ← À PERSONNALISER (nom paramètre)
    if (qsReseau) reseauId = qsReseau;               // ← À PERSONNALISER (nom variable)

    if (req.method === "POST") {                     // ← CONSERVER
      try {
        const body = await req.json().catch(() => ({})); // ← CONSERVER
        if (!reseauId && body && typeof body.reseau_id === "string") { // ← À PERSONNALISER (body.reseau_id)
          reseauId = body.reseau_id;                 // ← À PERSONNALISER
        }
      } catch {}
    }

    if (!reseauId) {                                 // ← À PERSONNALISER (nom variable)
      logStructured("missing_reseau_id", { requestId }); // ← À PERSONNALISER (event name)
      return new Response(
        JSON.stringify({ success: false, error: "bad_request_missing_reseau_id", requestId }), // ← À PERSONNALISER (error code)
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }
```

---

### Sous-Étape 6 : Récupération des Données de la Table Métier

- **Objectif** : Charger l'enregistrement complet de la table métier avec toutes ses colonnes

- **Directives** :
  - **À PERSONNALISER** : Nom de la table dans `.from("reseau")`
  - **À PERSONNALISER** : Utiliser la constante PROJECTION définie à la sous-étape 3
  - **À PERSONNALISER** : Colonne ID dans `.eq("reseau_id", reseauId)`
  - **À PERSONNALISER** : Noms des variables et événements de log
  - **CONSERVER** : La structure complète avec timing, gestion erreur, logs

```typescript
    const t0 = performance.now();                    // ← CONSERVER (mesure performance)

    const { data: reseau, error: reseauErr } = await supabase  // ← À PERSONNALISER (nom variable data)
      .from("reseau")                                // ← À PERSONNALISER (nom table)
      .select(RESEAU_PROJECTION)                     // ← À PERSONNALISER (constante projection)
      .eq("reseau_id", reseauId)                     // ← À PERSONNALISER (colonne ID + variable)
      .maybeSingle();                                // ← CONSERVER

    if (reseauErr) {                                 // ← À PERSONNALISER (nom variable error)
      const durationMs = Math.round(performance.now() - t0); // ← CONSERVER
      logStructured("reseau_fetch_error", { requestId, reseau_id: reseauId, error: reseauErr.message, duration_ms: durationMs }); // ← À PERSONNALISER
      return new Response(
        JSON.stringify({ success: false, error: "db_error_reseau_fetch", details: reseauErr.message, requestId }), // ← À PERSONNALISER
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    if (!reseau) {                                   // ← À PERSONNALISER (nom variable data)
      const durationMs = Math.round(performance.now() - t0);
      logStructured("reseau_not_found", { requestId, reseau_id: reseauId, duration_ms: durationMs }); // ← À PERSONNALISER
      return new Response(
        JSON.stringify({ success: false, error: "not_found_reseau", requestId, reseau_id: reseauId }), // ← À PERSONNALISER
        { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }
```

---

### Sous-Étape 7 : Extraction des IDs d'Intégrations

- **Objectif** : Récupérer les IDs de connexion Brevo, Zoho, OpenAI depuis l'objet chargé

- **Directives** :
  - **À PERSONNALISER** : Préfixe des colonnes selon la table (ex: `reseau.reseau_brevo_connexion_id`)
  - **CONSERVER** : Les noms de variables brevoId, zohoId, openaiId

```typescript
    const brevoId = reseau.reseau_brevo_connexion_id as string | null;   // ← À PERSONNALISER (préfixe colonne)
    const zohoId = reseau.reseau_zoho_connexion_id as string | null;     // ← À PERSONNALISER (préfixe colonne)
    const openaiId = reseau.reseau_openai_connexion_id as string | null; // ← À PERSONNALISER (préfixe colonne)
```

---

### Sous-Étape 8 : Préparation des Promesses Parallèles pour les Intégrations

- **Objectif** : Initialiser la structure pour charger les intégrations en parallèle avec Promise.all()

- **Directives** :
  - **CONSERVER** intégralement cette structure (identique pour toutes les tables)

```typescript
    const promises: Promise[] = [];             // ← CONSERVER
    const results: { brevo: any | null; zoho: any | null; openai: any | null } = { // ← CONSERVER
      brevo: null,                                   // ← CONSERVER
      zoho: null,                                    // ← CONSERVER
      openai: null,                                  // ← CONSERVER
    };
```

---

### Sous-Étape 9 : Chargement Conditionnel des Intégrations (Promise.all)

- **Objectif** : Charger chaque intégration uniquement si son ID existe dans la table métier

- **Directives** :
  - **CONSERVER** intégralement la structure des 3 blocs if (brevoId), if (zohoId), if (openaiId)
  - **CONSERVER** les noms de tables d'intégrations : brevo_connexion, zoho_connexion, openai_connexion
  - **CONSERVER** INTEGRATION_PROJECTION (= "*")
  - **CONSERVER** la gestion d'erreur avec throw new Error()

```typescript
    if (brevoId) {                                   // ← CONSERVER
      promises.push(
        supabase.from("brevo_connexion").select(INTEGRATION_PROJECTION).eq("brevo_connexion_id", brevoId).maybeSingle() // ← CONSERVER
          .then(({ data, error }) => { if (error) throw new Error(`brevo_fetch_error:${error.message}`); results.brevo = data ?? null; }) // ← CONSERVER
      );
    }
    if (zohoId) {                                    // ← CONSERVER
      promises.push(
        supabase.from("zoho_connexion").select(INTEGRATION_PROJECTION).eq("zoho_connexion_id", zohoId).maybeSingle() // ← CONSERVER
          .then(({ data, error }) => { if (error) throw new Error(`zoho_fetch_error:${error.message}`); results.zoho = data ?? null; }) // ← CONSERVER
      );
    }
    if (openaiId) {                                  // ← CONSERVER
      promises.push(
        supabase.from("openai_connexion").select(INTEGRATION_PROJECTION).eq("openai_connexion_id", openaiId).maybeSingle() // ← CONSERVER
          .then(({ data, error }) => { if (error) throw new Error(`openai_fetch_error:${error.message}`); results.openai = data ?? null; }) // ← CONSERVER
      );
    }
```

---

### Sous-Étape 10 : Exécution Parallèle et Gestion Erreurs Partielles

- **Objectif** : Exécuter toutes les promesses en parallèle et gérer les erreurs partielles sans bloquer

- **Directives** :
  - **CONSERVER** intégralement cette logique (identique pour toutes les tables)

```typescript
    let integrationsError: string | null = null;     // ← CONSERVER
    try {
      if (promises.length > 0) await Promise.all(promises); // ← CONSERVER
    } catch (e) {
      integrationsError = e instanceof Error ? e.message : String(e); // ← CONSERVER
    }

    const durationMs = Math.round(performance.now() - t0); // ← CONSERVER
```

---

### Sous-Étape 11 : Retour des Données avec Pattern `data.data`

- **Objectif** : Retourner les données au format standardisé `{ success: true, data: { reseau, integrations }, message, requestId }`

- **Directives** :
  - **À PERSONNALISER** : Nom de la propriété dans data (ex: `reseau`, `agenceIndep`, `reseauAgence`)
  - **À PERSONNALISER** : Messages de log et de réponse selon la table
  - **CONSERVER** : La structure `{ reseau, integrations: results }` (pattern data.data)
  - **CONSERVER** : La gestion erreur partielle avec warning

```typescript
    if (integrationsError) {                         // ← CONSERVER
      logStructured("integrations_fetch_partial_error", {  // ← À PERSONNALISER (event name)
        requestId, reseau_id: reseauId, error: integrationsError, // ← À PERSONNALISER (reseau_id)
        found: { brevo: !!results.brevo, zoho: !!results.zoho, openai: !!results.openai }, // ← CONSERVER
        duration_ms: durationMs,
      });
      return new Response(
        JSON.stringify({
          success: true,                             // ← CONSERVER
          data: { reseau, integrations: results },   // ← À PERSONNALISER (nom propriété reseau)
          message: "Données réseau récupérées (quelques intégrations en erreur)", // ← À PERSONNALISER
          warning: "some_integrations_failed",       // ← CONSERVER
          requestId
        }),
        { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    logStructured("reseau_and_integrations_ok", {    // ← À PERSONNALISER (event name)
      requestId, reseau_id: reseauId,                // ← À PERSONNALISER
      found: { brevo: !!results.brevo, zoho: !!results.zoho, openai: !!results.openai },
      duration_ms: durationMs,
    });

    return new Response(
      JSON.stringify({ success: true, data: { reseau, integrations: results }, message: "Données réseau récupérées avec succès", requestId }), // ← À PERSONNALISER
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (e) {                                      // ← CONSERVER
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) });
    return new Response(
      JSON.stringify({ success: false, error: "internal_error", requestId }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```

---
---
# ÉTAPE 6 : Hook - FormData
**Fichier :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData.ts`
- Toujours utiliser la structure de nomage
- src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/(Numéroration de la structure de nommage de la table)/hooks/useReseauFormData.ts
```typescript
import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import type { ReseauFormData, ReseauSelectorItem, ValidationErrors } from './types';

/**
 * Hook principal pour la gestion du formulaire Réseau (Espace Gestion).
 * Corrections 2025-10-02 :
 *  - Appels Edge Functions avec body: {} (stabilisation SDK v2)
 *  - Parsing conforme au pattern { success, data, message } (data.data côté client)
 *  - Paramètre harmonisé: reseau_id (snake_case) pour les EF
 */
export function useReseauFormData() {
  const [reseaux, setReseaux] = useState<ReseauSelectorItem[]>([]);
  const [selectedReseauId, setSelectedReseauId] = useState<string>('');
  const [formData, setFormData] = useState<Partial<ReseauFormData>>({});
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [errors, setErrors] = useState<ValidationErrors>({});
  const { toast } = useToast();

  /**
   * 🔑 SERVICE_ROLE_KEY via EF (verify_jwt=false)
   * Charger la liste des réseaux pour le sélecteur
   */
  const loadReseaux = useCallback(async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin', {
        body: {},
      });
      if (error) throw error;
      const items = (data?.data || []) as ReseauSelectorItem[];
      setReseaux(items);
    } catch (e: any) {
      toast({
        title: 'Erreur',
        description: 'Impossible de charger les réseaux',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  /**
   * 🔑 Charger les données complètes d'un réseau sélectionné
   */
  const loadReseauData = useCallback(
    async (reseauId: string) => {
      if (!reseauId) return;
      setIsLoading(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {
          body: { reseau_id: reseauId },
        });
        if (error) throw error;

        const reseau = data?.data?.reseau as Partial<ReseauFormData> | undefined;
        if (!reseau) {
          setFormData({});
          toast({
            title: 'Introuvable',
            description: 'Réseau introuvable',
            variant: 'destructive',
          });
          return;
        }

        setFormData(reseau);
        setErrors({});
      } catch (e: any) {
        toast({
          title: 'Erreur',
          description: 'Impossible de charger les données du réseau',
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    },
    [toast]
  );

  /**
   * Validation côté frontend (forme uniquement)
   */
  const validateForm = useCallback(
    (data: Partial<ReseauFormData>): ValidationErrors => {
      const newErrors: ValidationErrors = {};

      if (data.reseau_code_postal && !/^\d{5}$/.test(data.reseau_code_postal)) {
        newErrors.reseau_code_postal = 'Le code postal doit contenir 5 chiffres';
      }

      if (data.reseau_siret && !/^\d{14}$/.test((data.reseau_siret as string).replace(/\s/g, ''))) {
        newErrors.reseau_siret = 'Le SIRET doit contenir 14 chiffres';
      }

      return newErrors;
    },
    []
  );

  /**
   * 🔑 Sauvegarder les données générales d'un réseau
   */
  const saveReseau = useCallback(
    async (dataToSave: Partial<ReseauFormData>) => {
      if (!selectedReseauId) return false;

      const validationErrors = validateForm(dataToSave);
      setErrors(validationErrors);
      if (Object.keys(validationErrors).length > 0) {
        toast({
          title: 'Erreurs de validation',
          description: 'Veuillez corriger les erreurs',
          variant: 'destructive',
        });
        return false;
      }

      setIsSaving(true);
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {
          body: {
            reseauId: selectedReseauId,
            generalData: dataToSave,
          },
        });
        if (error || !data?.success) throw error || new Error('Update échoué');

        toast({
          title: 'Succès',
          description: 'Réseau mis à jour avec succès',
        });
        await loadReseauData(selectedReseauId);
        return true;
      } catch (e: any) {
        toast({
          title: 'Erreur',
          description: 'Impossible de sauvegarder les modifications',
          variant: 'destructive',
        });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [selectedReseauId, validateForm, toast, loadReseauData]
  );

  /**
   * Mise à jour d'un champ local
   */
  const updateFormField = useCallback(
    (field: keyof ReseauFormData | string, value: any) => {
      setFormData((prev) => ({ ...prev, [field]: value }));
      if (errors[field]) {
        setErrors((prev) => {
          const e = { ...prev };
          delete e[field];
          return e;
        });
      }
    },
    [errors]
  );

  /**
   * Sélection d'un réseau
   */
  const selectReseau = useCallback(
    (reseauId: string) => {
      setSelectedReseauId(reseauId);
      if (reseauId) {
        loadReseauData(reseauId);
      } else {
        setFormData({});
        setErrors({});
      }
    },
    [loadReseauData]
  );

  return {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    validateForm,
    loadReseauData,
  };
}
```
---
# ETAPE 6
## **Explications. Comment concevoir le Hook Principal de Gestion des Données Générales**

---

### Sous-Étape 1 : Imports et Déclaration du Hook

- **Objectif** : Importer les dépendances React et Supabase, et les types TypeScript nécessaires

- **Directives** :
  - CONSERVER les imports React : `useState`, `useCallback`
  - CONSERVER l'import Supabase client : `@/integrations/supabase/client`
  - CONSERVER l'import useToast : `@/hooks/use-toast`
  - ADAPTER le chemin vers le fichier `types` selon votre structure de dossiers
  - ADAPTER le nom du hook : `useReseauFormData` → `use{Table}FormData`
  - ADAPTER les types importés : `ReseauFormData`, `ReseauSelectorItem` → `{Table}FormData`, `{Table}SelectorItem`

```typescript
import { useState, useCallback } from 'react';                              // ← CONSERVER
import { supabase } from '@/integrations/supabase/client';                  // ← CONSERVER
import { useToast } from '@/hooks/use-toast';                               // ← CONSERVER
import type { ReseauFormData, ReseauSelectorItem, ValidationErrors } from './types';  // ← À PERSONNALISER (chemin + noms types)

export function useReseauFormData() {                                       // ← À PERSONNALISER (nom hook)
```

---

### Sous-Étape 2 : Initialisation des États Locaux

- **Objectif** : Gérer l'état du formulaire (liste des entités, entité sélectionnée, données du formulaire, loading, erreurs)

- **Directives** :
  - ADAPTER le nom du tableau d'entités : `reseaux` → `reseauxAgences`, `agencesIndep`, etc.
  - ADAPTER le type : `ReseauSelectorItem[]` → `{Table}SelectorItem[]`
  - ADAPTER le nom de l'ID sélectionné : `selectedReseauId` → `selected{Table}Id`
  - ADAPTER le type du formData : `ReseauFormData` → `{Table}FormData`
  - CONSERVER tous les autres états : `isLoading`, `isSaving`, `errors`, `toast`

```typescript
  const [reseaux, setReseaux] = useState([]);         // ← À PERSONNALISER (nom + type)
  const [selectedReseauId, setSelectedReseauId] = useState('');     // ← À PERSONNALISER (nom)
  const [formData, setFormData] = useState>({});    // ← À PERSONNALISER (type)
  const [isLoading, setIsLoading] = useState(false);                        // ← CONSERVER
  const [isSaving, setIsSaving] = useState(false);                          // ← CONSERVER
  const [errors, setErrors] = useState({});               // ← CONSERVER
  const { toast } = useToast();                                             // ← CONSERVER
```

---

### Sous-Étape 3 : Fonction `loadReseaux` - Charger la Liste des Entités

- **Objectif** : Récupérer la liste complète des entités via Edge Function (SERVICE_ROLE_KEY) pour le sélecteur

- **Directives** :
  - ADAPTER le nom de la fonction : `loadReseaux` → `load{Tables}`
  - ADAPTER le nom de l'Edge Function : `'gestion-reseau-admin'` → `'gestion-{table}-admin'`
  - CONSERVER le body vide : `body: {}`
  - CONSERVER le pattern de parsing : `data?.data || []`
  - ADAPTER le type de casting : `ReseauSelectorItem[]` → `{Table}SelectorItem[]`
  - ADAPTER le setter : `setReseaux` → `set{Tables}`
  - ADAPTER le message d'erreur : `'Impossible de charger les réseaux'` → `'Impossible de charger les {entités}'`
  - CONSERVER la structure try/catch/finally et la gestion du loading

```typescript
  const loadReseaux = useCallback(async () => {                            // ← À PERSONNALISER (nom fonction)
    setIsLoading(true);                                                     // ← CONSERVER
    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin', {  // ← À PERSONNALISER (nom EF)
        body: {},                                                           // ← CONSERVER
      });
      if (error) throw error;                                               // ← CONSERVER
      const items = (data?.data || []) as ReseauSelectorItem[];             // ← À PERSONNALISER (type)
      setReseaux(items);                                                    // ← À PERSONNALISER (setter)
    } catch (e: any) {                                                      // ← CONSERVER
      toast({                                                               // ← CONSERVER
        title: 'Erreur',                                                    // ← CONSERVER
        description: 'Impossible de charger les réseaux',                  // ← À PERSONNALISER (message)
        variant: 'destructive',                                             // ← CONSERVER
      });
    } finally {
      setIsLoading(false);                                                  // ← CONSERVER
    }
  }, [toast]);                                                              // ← CONSERVER
```

---

### Sous-Étape 4 : Fonction `loadReseauData` - Charger les Données Complètes d'une Entité

- **Objectif** : Récupérer toutes les données d'une entité sélectionnée (général + intégrations) via Edge Function

- **Directives** :
  - ADAPTER le nom de la fonction : `loadReseauData` → `load{Table}Data`
  - ADAPTER le paramètre : `reseauId` → `{table}Id` (camelCase)
  - ADAPTER le nom de l'Edge Function : `'gestion-reseau-admin-donnees'` → `'gestion-{table}-admin-donnees'`
  - ADAPTER la clé du body : `reseau_id: reseauId` → `{table}_id: {table}Id` (snake_case pour l'EF)
  - CONSERVER le pattern de parsing : `data?.data?.reseau`
  - ADAPTER le chemin d'extraction : `data?.data?.reseau` → `data?.data?.{table}` (correspond au retour de l'EF)
  - ADAPTER le type de casting : `Partial` → `Partial<{Table}FormData>`
  - ADAPTER les messages d'erreur : `'Réseau introuvable'` → `'{Entité} introuvable'`
  - CONSERVER la gestion du formData vide si introuvable
  - CONSERVER la structure try/catch/finally

```typescript
  const loadReseauData = useCallback(                                       // ← À PERSONNALISER (nom fonction)
    async (reseauId: string) => {                                           // ← À PERSONNALISER (nom paramètre)
      if (!reseauId) return;                                                // ← CONSERVER
      setIsLoading(true);                                                   // ← CONSERVER
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {  // ← À PERSONNALISER (nom EF)
          body: { reseau_id: reseauId },                                    // ← À PERSONNALISER (clé snake_case)
        });
        if (error) throw error;                                             // ← CONSERVER

        const reseau = data?.data?.reseau as Partial | undefined;  // ← À PERSONNALISER (chemin + type)
        if (!reseau) {                                                      // ← CONSERVER
          setFormData({});                                                  // ← CONSERVER
          toast({
            title: 'Introuvable',                                           // ← CONSERVER
            description: 'Réseau introuvable',                              // ← À PERSONNALISER (message)
            variant: 'destructive',                                         // ← CONSERVER
          });
          return;                                                           // ← CONSERVER
        }

        setFormData(reseau);                                                // ← CONSERVER
        setErrors({});                                                      // ← CONSERVER
      } catch (e: any) {                                                    // ← CONSERVER
        toast({
          title: 'Erreur',                                                  // ← CONSERVER
          description: 'Impossible de charger les données du réseau',      // ← À PERSONNALISER (message)
          variant: 'destructive',                                           // ← CONSERVER
        });
      } finally {
        setIsLoading(false);                                                // ← CONSERVER
      }
    },
    [toast]                                                                 // ← CONSERVER
  );
```

---

### Sous-Étape 5 : Fonction `validateForm` - Validation Frontend

- **Objectif** : Valider les champs du formulaire côté client (format code postal, SIRET, etc.)

- **Directives** :
  - CONSERVER le nom de la fonction : `validateForm`
  - ADAPTER le type du paramètre : `Partial` → `Partial<{Table}FormData>`
  - ADAPTER les validations selon les champs de votre table :
    - Code postal : `data.reseau_code_postal` → `data.{table}_code_postal`
    - SIRET : `data.reseau_siret` → `data.{table}_siret`
  - CONSERVER les regex de validation :
    - Code postal : `/^\d{5}$/`
    - SIRET : `/^\d{14}$/` avec suppression des espaces
  - ADAPTER les clés d'erreur dans `newErrors` selon vos noms de colonnes
  - CONSERVER la structure générale et le retour `newErrors`

```typescript
  const validateForm = useCallback(                                         // ← CONSERVER (nom)
    (data: Partial): ValidationErrors => {                  // ← À PERSONNALISER (type paramètre)
      const newErrors: ValidationErrors = {};                               // ← CONSERVER

      if (data.reseau_code_postal && !/^\d{5}$/.test(data.reseau_code_postal)) {  // ← À PERSONNALISER (nom champ)
        newErrors.reseau_code_postal = 'Le code postal doit contenir 5 chiffres';  // ← À PERSONNALISER (clé erreur)
      }

      if (data.reseau_siret && !/^\d{14}$/.test((data.reseau_siret as string).replace(/\s/g, ''))) {  // ← À PERSONNALISER (nom champ)
        newErrors.reseau_siret = 'Le SIRET doit contenir 14 chiffres';      // ← À PERSONNALISER (clé erreur)
      }

      return newErrors;                                                     // ← CONSERVER
    },
    []                                                                      // ← CONSERVER
  );
```

---

### Sous-Étape 6 : Fonction `saveReseau` - Sauvegarder les Données Générales

- **Objectif** : Valider et sauvegarder les données générales de l'entité via Edge Function de mise à jour

- **Directives** :
  - ADAPTER le nom de la fonction : `saveReseau` → `save{Table}`
  - ADAPTER le type du paramètre : `Partial` → `Partial<{Table}FormData>`
  - ADAPTER la vérification de l'ID : `selectedReseauId` → `selected{Table}Id`
  - CONSERVER l'appel à `validateForm(dataToSave)`
  - CONSERVER la gestion des erreurs de validation et le toast
  - ADAPTER le nom de l'Edge Function : `'gestion-reseau-admin-update'` → `'gestion-{table}-admin-update'`
  - ADAPTER la clé du body : `reseauId: selectedReseauId` → `{table}Id: selected{Table}Id` (camelCase pour l'EF)
  - CONSERVER la clé `generalData: dataToSave` (standardisée)
  - CONSERVER la vérification `!data?.success`
  - ADAPTER les messages toast : `'Réseau mis à jour avec succès'` → `'{Entité} mis à jour avec succès'`
  - ADAPTER l'appel au rechargement : `loadReseauData(selectedReseauId)` → `load{Table}Data(selected{Table}Id)`
  - CONSERVER la structure try/catch/finally et le retour booléen

```typescript
  const saveReseau = useCallback(                                           // ← À PERSONNALISER (nom fonction)
    async (dataToSave: Partial) => {                        // ← À PERSONNALISER (type paramètre)
      if (!selectedReseauId) return false;                                  // ← À PERSONNALISER (nom ID)

      const validationErrors = validateForm(dataToSave);                    // ← CONSERVER
      setErrors(validationErrors);                                          // ← CONSERVER
      if (Object.keys(validationErrors).length > 0) {                       // ← CONSERVER
        toast({
          title: 'Erreurs de validation',                                  // ← CONSERVER
          description: 'Veuillez corriger les erreurs',                    // ← CONSERVER
          variant: 'destructive',                                           // ← CONSERVER
        });
        return false;                                                       // ← CONSERVER
      }

      setIsSaving(true);                                                    // ← CONSERVER
      try {
        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {  // ← À PERSONNALISER (nom EF)
          body: {
            reseauId: selectedReseauId,                                     // ← À PERSONNALISER (clé camelCase + variable)
            generalData: dataToSave,                                        // ← CONSERVER (clé standardisée)
          },
        });
        if (error || !data?.success) throw error || new Error('Update échoué');  // ← CONSERVER

        toast({
          title: 'Succès',                                                  // ← CONSERVER
          description: 'Réseau mis à jour avec succès',                    // ← À PERSONNALISER (message)
        });
        await loadReseauData(selectedReseauId);                             // ← À PERSONNALISER (fonction + variable)
        return true;                                                        // ← CONSERVER
      } catch (e: any) {                                                    // ← CONSERVER
        toast({
          title: 'Erreur',                                                  // ← CONSERVER
          description: 'Impossible de sauvegarder les modifications',      // ← CONSERVER
          variant: 'destructive',                                           // ← CONSERVER
        });
        return false;                                                       // ← CONSERVER
      } finally {
        setIsSaving(false);                                                 // ← CONSERVER
      }
    },
    [selectedReseauId, validateForm, toast, loadReseauData]                 // ← À PERSONNALISER (dépendances)
  );
```

---

### Sous-Étape 7 : Fonction `updateFormField` - Mise à Jour d'un Champ Local

- **Objectif** : Mettre à jour un champ du formulaire dans l'état local et supprimer l'erreur associée

- **Directives** :
  - CONSERVER intégralement cette fonction (aucune personnalisation nécessaire)
  - ADAPTER uniquement le type dans la signature : `keyof ReseauFormData` → `keyof {Table}FormData`
  - Cette fonction fonctionne de manière générique pour tous les formulaires

```typescript
  const updateFormField = useCallback(                                      // ← CONSERVER
    (field: keyof ReseauFormData | string, value: any) => {                 // ← À PERSONNALISER (type seulement)
      setFormData((prev) => ({ ...prev, [field]: value }));                // ← CONSERVER
      if (errors[field]) {                                                  // ← CONSERVER
        setErrors((prev) => {                                               // ← CONSERVER
          const e = { ...prev };                                            // ← CONSERVER
          delete e[field];                                                  // ← CONSERVER
          return e;                                                         // ← CONSERVER
        });
      }
    },
    [errors]                                                                // ← CONSERVER
  );
```

---

### Sous-Étape 8 : Fonction `selectReseau` - Sélection d'une Entité

- **Objectif** : Gérer la sélection d'une entité dans le sélecteur et charger ses données complètes

- **Directives** :
  - ADAPTER le nom de la fonction : `selectReseau` → `select{Table}`
  - ADAPTER le nom du paramètre : `reseauId` → `{table}Id` (camelCase)
  - ADAPTER le setter d'ID : `setSelectedReseauId` → `setSelected{Table}Id`
  - ADAPTER l'appel au chargement : `loadReseauData(reseauId)` → `load{Table}Data({table}Id)`
  - CONSERVER la logique conditionnelle : si ID vide, réinitialiser formData et errors
  - CONSERVER la structure générale

```typescript
  const selectReseau = useCallback(                                         // ← À PERSONNALISER (nom fonction)
    (reseauId: string) => {                                                 // ← À PERSONNALISER (nom paramètre)
      setSelectedReseauId(reseauId);                                        // ← À PERSONNALISER (setter)
      if (reseauId) {                                                       // ← CONSERVER
        loadReseauData(reseauId);                                           // ← À PERSONNALISER (fonction + variable)
      } else {                                                              // ← CONSERVER
        setFormData({});                                                    // ← CONSERVER
        setErrors({});                                                      // ← CONSERVER
      }
    },
    [loadReseauData]                                                        // ← À PERSONNALISER (dépendance)
  );
```

---

### Sous-Étape 9 : Retour du Hook (Return)

- **Objectif** : Exposer toutes les fonctions et états nécessaires au composant formulaire

- **Directives** :
  - ADAPTER les noms des variables retournées selon votre table :
    - `reseaux` → `{tables}` (liste des entités)
    - `selectedReseauId` → `selected{Table}Id`
  - ADAPTER les noms des fonctions retournées selon votre table :
    - `loadReseaux` → `load{Tables}`
    - `selectReseau` → `select{Table}`
    - `saveReseau` → `save{Table}`
    - `loadReseauData` → `load{Table}Data`
  - CONSERVER tous les autres états et fonctions : `formData`, `isLoading`, `isSaving`, `errors`, `updateFormField`, `validateForm`
  - CONSERVER l'ordre des retours pour la cohérence

```typescript
  return {
    reseaux,                                                                // ← À PERSONNALISER (nom)
    selectedReseauId,                                                       // ← À PERSONNALISER (nom)
    formData,                                                               // ← CONSERVER
    isLoading,                                                              // ← CONSERVER
    isSaving,                                                               // ← CONSERVER
    errors,                                                                 // ← CONSERVER
    loadReseaux,                                                            // ← À PERSONNALISER (nom)
    selectReseau,                                                           // ← À PERSONNALISER (nom)
    updateFormField,                                                        // ← CONSERVER
    saveReseau,                                                             // ← À PERSONNALISER (nom)
    validateForm,                                                           // ← CONSERVER
    loadReseauData,                                                         // ← À PERSONNALISER (nom)
  };
}
```

---

**Points Clés à Retenir :**

1. **Pattern `data.data`** : Toutes les Edge Functions retournent `{ success, data, message }`, et les données réelles sont dans `data.data`
2. **Nommage snake_case pour EF** : Les clés de body des Edge Functions utilisent le snake_case (`reseau_id`, `generalData`)
3. **Nommage camelCase pour Hook** : Les variables TypeScript utilisent le camelCase (`reseauId`, `selectedReseauId`)
4. **Validation séparée** : La validation frontend est distincte de la validation backend (dans l'EF)
5. **Gestion erreurs** : Toast pour chaque erreur + état `errors` pour les erreurs de validation
6. **Loading states** : `isLoading` pour les chargements, `isSaving` pour les sauvegardes
7. **Rechargement automatique** : Après une sauvegarde réussie, `load{Table}Data()` est appelé pour synchroniser l'état

---
---
# ÉTAPE 7 : Edge Function - Update 
**Fichier :** `supabase/functions/gestion-reseau-admin-update/index.ts`
- Toujours utiliser la structure de nomage
- supabase/functions/gestion-(table)-admin-update/index.ts
```typescript
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: { autoRefreshToken: false, persistSession: false }
});

const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

const INTEGRATION_TABLES = {
  brevo: { table: "brevo_connexion", idField: "brevo_connexion_id", fkField: "reseau_brevo_connexion_id" },
  zoho: { table: "zoho_connexion", idField: "zoho_connexion_id", fkField: "reseau_zoho_connexion_id" },
  openai: { table: "openai_connexion", idField: "openai_connexion_id", fkField: "reseau_openai_connexion_id" },
} as const;

type IntegrationKind = keyof typeof INTEGRATION_TABLES;

Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const body = await req.json();
    const { reseauId, generalData, integrationKind, integrationData } = body;

    if (!reseauId) {
      logStructured("missing_reseau_id", { requestId });
      return new Response(
        JSON.stringify({ success: false, error: "bad_request_missing_reseau_id", requestId }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const t0 = performance.now();
    let updatedReseau: any = null;
    let updatedIntegration: any = null;
    let message = "";

    if (generalData && typeof generalData === "object") {
      const { data: updated, error: updateErr } = await supabase
        .from("reseau")
        .update({ ...generalData, reseau_updated_at: new Date().toISOString() })
        .eq("reseau_id", reseauId)
        .select("*")
        .single();

      if (updateErr) {
        logStructured("reseau_update_error", { requestId, reseau_id: reseauId, error: updateErr.message });
        return new Response(
          JSON.stringify({ success: false, error: "db_error_reseau_update", details: updateErr.message, requestId }),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      updatedReseau = updated;
      message = "Réseau mis à jour";
      logStructured("reseau_update_ok", { requestId, reseau_id: reseauId });
    }

    if (integrationKind && integrationData && typeof integrationData === "object") {
      const config = INTEGRATION_TABLES[integrationKind as IntegrationKind];
      if (!config) {
        return new Response(
          JSON.stringify({ success: false, error: "unknown_integration_kind", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      // ✅ FIX: sélectionner organisation_id + fk d'intégration
      const { data: reseauRow, error: fetchErr } = await supabase
        .from("reseau")
        .select(`organisation_id, ${config.fkField}`)
        .eq("reseau_id", reseauId)
        .single();

      if (fetchErr || !reseauRow) {
        return new Response(
          JSON.stringify({ success: false, error: "db_error_fetch_reseau_for_integration", details: fetchErr?.message || "reseau_not_found", requestId }),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const currentConnexionId = reseauRow[config.fkField] as string | null;

      if (currentConnexionId) {
        const { data: updatedInt, error: updateIntErr } = await supabase
          .from(config.table)
          .update(integrationData)
          .eq(config.idField, currentConnexionId)
          .select("*")
          .single();

        if (updateIntErr) {
          logStructured("integration_update_error", { requestId, kind: integrationKind, error: updateIntErr.message });
          return new Response(
            JSON.stringify({ success: false, error: "db_error_integration_update", details: updateIntErr.message, requestId }),
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }

        updatedIntegration = updatedInt;
        message += (message ? " + " : "") + `Intégration ${integrationKind} mise à jour`;
        logStructured("integration_update_ok", { requestId, kind: integrationKind });
      } else {
        const { data: newInt, error: insertErr } = await supabase
          .from(config.table)
          .insert({ ...integrationData, reseau_id: reseauId, organisation_id: reseauRow.organisation_id })
          .select("*")
          .single();

        if (insertErr) {
          logStructured("integration_insert_error", { requestId, kind: integrationKind, error: insertErr.message });
          return new Response(
            JSON.stringify({ success: false, error: "db_error_integration_insert", details: insertErr.message, requestId }),
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }

        const newConnexionId = newInt[config.idField];
        const { error: linkErr } = await supabase
          .from("reseau")
          .update({ [config.fkField]: newConnexionId })
          .eq("reseau_id", reseauId);

        if (linkErr) {
          logStructured("integration_link_error", { requestId, kind: integrationKind, error: linkErr.message });
          return new Response(
            JSON.stringify({ success: false, error: "db_error_integration_link", details: linkErr.message, requestId }),
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
          );
        }

        updatedIntegration = newInt;
        message += (message ? " + " : "") + `Intégration ${integrationKind} créée`;
        logStructured("integration_insert_ok", { requestId, kind: integrationKind });
      }
    }

    const durationMs = Math.round(performance.now() - t0);
    logStructured("update_complete", { requestId, reseau_id: reseauId, duration_ms: durationMs });

    return new Response(
      JSON.stringify({ success: true, data: { reseau: updatedReseau, integration: updatedIntegration }, message: message || "Aucune modification", requestId }),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (e) {
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) });
    return new Response(
      JSON.stringify({ success: false, error: "internal_error", requestId }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```
---
## **Explications. Comment concevoir une Edge Function de Mise à Jour pour une table**

---

### Sous-Étape 1 : Imports et Configuration Supabase Admin avec SERVICE_ROLE_KEY

- **Objectif** : Initialiser le client Supabase avec SERVICE_ROLE_KEY pour bypasser RLS et permettre les mises à jour

- **Directives** :
  - CONSERVER tel quel les imports (utiliser l'URL ESM pour Deno)
  - CONSERVER la configuration supabaseAdmin avec les options d'auth désactivées
  - CONSERVER les variables d'environnement SUPABASE_URL et SERVICE_ROLE_KEY

```typescript
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";  // ← CONSERVER

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;                     // ← CONSERVER
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;   // ← CONSERVER

const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {        // ← CONSERVER
  auth: { autoRefreshToken: false, persistSession: false }             // ← CONSERVER
});                                                                      // ← CONSERVER
```

---

### Sous-Étape 2 : Configuration CORS et Logging

- **Objectif** : Configurer les headers CORS et la fonction de logging structuré

- **Directives** :
  - CONSERVER intégralement corsHeaders (pas de personnalisation)
  - CONSERVER intégralement la fonction logStructured

```typescript
const corsHeaders: HeadersInit = {                                      // ← CONSERVER
  "Access-Control-Allow-Origin": "*",                                   // ← CONSERVER
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type", // ← CONSERVER
  "Access-Control-Allow-Methods": "POST, OPTIONS",                      // ← CONSERVER
};                                                                       // ← CONSERVER

function logStructured(event: string, payload: Record) { // ← CONSERVER
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload })); // ← CONSERVER
}                                                                        // ← CONSERVER
```

---

### Sous-Étape 3 : Définir la Configuration des Tables d'Intégration

- **Objectif** : Mapper les tables d'intégration avec leurs clés primaires et étrangères

- **Directives** :
  - CONSERVER la structure de l'objet INTEGRATION_TABLES
  - ADAPTER les clés d'intégration selon votre table :
    - Pour `reseau` : `reseau_brevo_connexion_id`, `reseau_zoho_connexion_id`, `reseau_openai_connexion_id`
    - Pour `reseau_agence` : `reseau_agence_brevo_connexion_id`, `reseau_agence_zoho_connexion_id`, etc.
    - Pour `agence_independante` : `agence_indep_brevo_connexion_id`, `agence_indep_zoho_connexion_id`, etc.
  - CONSERVER les noms de tables d'intégration (brevo_connexion, zoho_connexion, openai_connexion)
  - CONSERVER les noms de champs ID (brevo_connexion_id, zoho_connexion_id, openai_connexion_id)
  - CONSERVER le type IntegrationKind

```typescript
const INTEGRATION_TABLES = {                                                    // ← CONSERVER (structure)
  brevo: { 
    table: "brevo_connexion",                                                   // ← CONSERVER
    idField: "brevo_connexion_id",                                              // ← CONSERVER
    fkField: "reseau_brevo_connexion_id"                                        // ← À PERSONNALISER
  },
  zoho: { 
    table: "zoho_connexion",                                                    // ← CONSERVER
    idField: "zoho_connexion_id",                                               // ← CONSERVER
    fkField: "reseau_zoho_connexion_id"                                         // ← À PERSONNALISER
  },
  openai: { 
    table: "openai_connexion",                                                  // ← CONSERVER
    idField: "openai_connexion_id",                                             // ← CONSERVER
    fkField: "reseau_openai_connexion_id"                                       // ← À PERSONNALISER
  },
} as const;                                                                     // ← CONSERVER

type IntegrationKind = keyof typeof INTEGRATION_TABLES;                         // ← CONSERVER
```

---

### Sous-Étape 4 : Handler Principal et Gestion OPTIONS (CORS Preflight)

- **Objectif** : Initialiser le handler Deno.serve et gérer les requêtes OPTIONS pour CORS

- **Directives** :
  - CONSERVER intégralement la structure Deno.serve
  - CONSERVER la génération du requestId
  - CONSERVER la gestion des requêtes OPTIONS

```typescript
Deno.serve(async (req) => {                                                     // ← CONSERVER
  const requestId = crypto.randomUUID();                                        // ← CONSERVER

  if (req.method === "OPTIONS") {                                               // ← CONSERVER
    return new Response(null, { headers: corsHeaders, status: 204 });           // ← CONSERVER
  }                                                                              // ← CONSERVER
```

---

### Sous-Étape 5 : Extraction des Paramètres depuis le Body

- **Objectif** : Récupérer les paramètres de mise à jour depuis le corps de la requête

- **Directives** :
  - CONSERVER la structure try/catch globale
  - ADAPTER le nom du paramètre ID selon votre table :
    - `reseauId` pour table reseau
    - `reseauAgenceId` pour table reseau_agence
    - `agenceIndepId` pour table agence_independante
  - CONSERVER les paramètres `generalData`, `integrationKind`, `integrationData`
  - ADAPTER le message d'erreur et les logs avec le bon nom d'ID

```typescript
  try {                                                                          // ← CONSERVER
    const body = await req.json();                                               // ← CONSERVER
    const { reseauId, generalData, integrationKind, integrationData } = body;    // ← À PERSONNALISER (nom ID)

    if (!reseauId) {                                                             // ← À PERSONNALISER (nom ID)
      logStructured("missing_reseau_id", { requestId });                         // ← À PERSONNALISER (nom log)
      return new Response(                                                       // ← CONSERVER
        JSON.stringify({ success: false, error: "bad_request_missing_reseau_id", requestId }), // ← À PERSONNALISER
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
      );                                                                         // ← CONSERVER
    }                                                                            // ← CONSERVER
```

---

### Sous-Étape 6 : Initialisation des Variables de Réponse

- **Objectif** : Préparer les variables pour stocker les résultats de mise à jour

- **Directives** :
  - CONSERVER intégralement cette section (aucune personnalisation)

```typescript
    const t0 = performance.now();                                                // ← CONSERVER
    let updatedReseau: any = null;                                               // ← CONSERVER
    let updatedIntegration: any = null;                                          // ← CONSERVER
    let message = "";                                                            // ← CONSERVER
```

---

### Sous-Étape 7 : Mise à Jour des Données Générales (si `generalData` fourni)

- **Objectif** : Mettre à jour la table métier avec les données générales

- **Directives** :
  - CONSERVER la vérification `if (generalData && typeof generalData === "object")`
  - ADAPTER le nom de la table dans `.from("reseau")`
  - ADAPTER le nom de la colonne updated_at : `{table}_updated_at`
  - ADAPTER le nom de la colonne ID dans `.eq()` : `{table}_id`
  - ADAPTER les noms dans les logs (reseau → {table})
  - CONSERVER la structure `.update().eq().select("*").single()`
  - CONSERVER la gestion d'erreur et le retour 500

```typescript
    if (generalData && typeof generalData === "object") {                        // ← CONSERVER
      const { data: updated, error: updateErr } = await supabase                 // ← CONSERVER
        .from("reseau")                                                          // ← À PERSONNALISER (nom table)
        .update({ ...generalData, reseau_updated_at: new Date().toISOString() }) // ← À PERSONNALISER (colonne)
        .eq("reseau_id", reseauId)                                               // ← À PERSONNALISER (colonne + variable)
        .select("*")                                                             // ← CONSERVER
        .single();                                                               // ← CONSERVER

      if (updateErr) {                                                           // ← CONSERVER
        logStructured("reseau_update_error", { requestId, reseau_id: reseauId, error: updateErr.message }); // ← À PERSONNALISER
        return new Response(                                                     // ← CONSERVER
          JSON.stringify({ success: false, error: "db_error_reseau_update", details: updateErr.message, requestId }), // ← À PERSONNALISER
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
        );                                                                       // ← CONSERVER
      }                                                                          // ← CONSERVER

      updatedReseau = updated;                                                   // ← CONSERVER
      message = "Réseau mis à jour";                                             // ← À PERSONNALISER (message)
      logStructured("reseau_update_ok", { requestId, reseau_id: reseauId });    // ← À PERSONNALISER
    }                                                                            // ← CONSERVER
```

---

### Sous-Étape 8 : Mise à Jour d'une Intégration (si `integrationKind` fourni)

- **Objectif** : Mettre à jour ou créer une intégration (Brevo, Zoho, OpenAI)

- **Directives** :
  - CONSERVER la vérification `if (integrationKind && integrationData && typeof integrationData === "object")`
  - CONSERVER la récupération de `config` depuis `INTEGRATION_TABLES`
  - CONSERVER la gestion d'erreur pour `unknown_integration_kind`

```typescript
    if (integrationKind && integrationData && typeof integrationData === "object") { // ← CONSERVER
      const config = INTEGRATION_TABLES[integrationKind as IntegrationKind];     // ← CONSERVER
      if (!config) {                                                             // ← CONSERVER
        return new Response(                                                     // ← CONSERVER
          JSON.stringify({ success: false, error: "unknown_integration_kind", requestId }), // ← CONSERVER
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
        );                                                                       // ← CONSERVER
      }                                                                          // ← CONSERVER
```

---

### Sous-Étape 9 : Récupérer organisation_id et FK d'Intégration

- **Objectif** : Charger l'organisation_id et la clé étrangère d'intégration depuis la table métier

- **Directives** :
  - ADAPTER le nom de la table dans `.from("reseau")`
  - CONSERVER la sélection `organisation_id, ${config.fkField}`
  - ADAPTER le nom de la colonne ID dans `.eq()` : `{table}_id`
  - ADAPTER les noms dans les logs et messages d'erreur
  - CONSERVER la structure de gestion d'erreur

```typescript
      const { data: reseauRow, error: fetchErr } = await supabase                // ← CONSERVER (structure)
        .from("reseau")                                                          // ← À PERSONNALISER (nom table)
        .select(`organisation_id, ${config.fkField}`)                            // ← CONSERVER
        .eq("reseau_id", reseauId)                                               // ← À PERSONNALISER (colonne + variable)
        .single();                                                               // ← CONSERVER

      if (fetchErr || !reseauRow) {                                              // ← CONSERVER
        return new Response(                                                     // ← CONSERVER
          JSON.stringify({ success: false, error: "db_error_fetch_reseau_for_integration", details: fetchErr?.message || "reseau_not_found", requestId }), // ← À PERSONNALISER
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
        );                                                                       // ← CONSERVER
      }                                                                          // ← CONSERVER

      const currentConnexionId = reseauRow[config.fkField] as string | null;     // ← CONSERVER
```

---

### Sous-Étape 10 : UPDATE de l'Intégration Existante (si `currentConnexionId` existe)

- **Objectif** : Mettre à jour l'intégration si elle existe déjà

- **Directives** :
  - CONSERVER intégralement la structure `if (currentConnexionId) { ... }`
  - CONSERVER `.from(config.table)` (utilise la config dynamique)
  - CONSERVER `.update(integrationData).eq(config.idField, currentConnexionId)`
  - CONSERVER la gestion d'erreur et les logs
  - CONSERVER l'assignation `updatedIntegration = updatedInt`
  - CONSERVER la concaténation du message

```typescript
      if (currentConnexionId) {                                                  // ← CONSERVER
        const { data: updatedInt, error: updateIntErr } = await supabase         // ← CONSERVER
          .from(config.table)                                                    // ← CONSERVER
          .update(integrationData)                                               // ← CONSERVER
          .eq(config.idField, currentConnexionId)                                // ← CONSERVER
          .select("*")                                                           // ← CONSERVER
          .single();                                                             // ← CONSERVER

        if (updateIntErr) {                                                      // ← CONSERVER
          logStructured("integration_update_error", { requestId, kind: integrationKind, error: updateIntErr.message }); // ← CONSERVER
          return new Response(                                                   // ← CONSERVER
            JSON.stringify({ success: false, error: "db_error_integration_update", details: updateIntErr.message, requestId }), // ← CONSERVER
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
          );                                                                     // ← CONSERVER
        }                                                                        // ← CONSERVER

        updatedIntegration = updatedInt;                                         // ← CONSERVER
        message += (message ? " + " : "") + `Intégration ${integrationKind} mise à jour`; // ← CONSERVER
        logStructured("integration_update_ok", { requestId, kind: integrationKind }); // ← CONSERVER
```

---

### Sous-Étape 11 : INSERT de l'Intégration + Liaison (si `currentConnexionId` n'existe pas)

- **Objectif** : Créer une nouvelle intégration et la lier à la table métier

- **Directives** :
  - CONSERVER la structure `else { ... }`
  - ADAPTER le nom du champ de liaison dans `.insert()` :
    - `reseau_id: reseauId` pour table reseau
    - `reseau_agence_id: reseauAgenceId` pour table reseau_agence
    - `agence_indep_id: agenceIndepId` pour table agence_independante
  - CONSERVER `organisation_id: reseauRow.organisation_id`
  - ADAPTER le nom de la table dans le second `.from("reseau").update()`
  - ADAPTER le nom de la colonne ID dans `.eq()` du second update
  - CONSERVER toute la gestion d'erreur et les logs

```typescript
      } else {                                                                   // ← CONSERVER
        const { data: newInt, error: insertErr } = await supabase                // ← CONSERVER
          .from(config.table)                                                    // ← CONSERVER
          .insert({ ...integrationData, reseau_id: reseauId, organisation_id: reseauRow.organisation_id }) // ← À PERSONNALISER (clé liaison)
          .select("*")                                                           // ← CONSERVER
          .single();                                                             // ← CONSERVER

        if (insertErr) {                                                         // ← CONSERVER
          logStructured("integration_insert_error", { requestId, kind: integrationKind, error: insertErr.message }); // ← CONSERVER
          return new Response(                                                   // ← CONSERVER
            JSON.stringify({ success: false, error: "db_error_integration_insert", details: insertErr.message, requestId }), // ← CONSERVER
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
          );                                                                     // ← CONSERVER
        }                                                                        // ← CONSERVER

        const newConnexionId = newInt[config.idField];                           // ← CONSERVER
        const { error: linkErr } = await supabase                                // ← CONSERVER
          .from("reseau")                                                        // ← À PERSONNALISER (nom table)
          .update({ [config.fkField]: newConnexionId })                          // ← CONSERVER
          .eq("reseau_id", reseauId);                                            // ← À PERSONNALISER (colonne + variable)

        if (linkErr) {                                                           // ← CONSERVER
          logStructured("integration_link_error", { requestId, kind: integrationKind, error: linkErr.message }); // ← CONSERVER
          return new Response(                                                   // ← CONSERVER
            JSON.stringify({ success: false, error: "db_error_integration_link", details: linkErr.message, requestId }), // ← CONSERVER
            { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
          );                                                                     // ← CONSERVER
        }                                                                        // ← CONSERVER

        updatedIntegration = newInt;                                             // ← CONSERVER
        message += (message ? " + " : "") + `Intégration ${integrationKind} créée`; // ← CONSERVER
        logStructured("integration_insert_ok", { requestId, kind: integrationKind }); // ← CONSERVER
      }                                                                          // ← CONSERVER
    }                                                                            // ← CONSERVER
```

---

### Sous-Étape 12 : Retour de la Réponse avec Pattern `data.data`

- **Objectif** : Retourner les données mises à jour dans le format standardisé

- **Directives** :
  - CONSERVER le calcul de `durationMs`
  - ADAPTER le log `update_complete` avec le bon nom d'ID
  - CONSERVER intégralement la structure de retour JSON
  - CONSERVER le pattern `data: { reseau: ..., integration: ... }`
  - CONSERVER la gestion d'exception catch

```typescript
    const durationMs = Math.round(performance.now() - t0);                       // ← CONSERVER
    logStructured("update_complete", { requestId, reseau_id: reseauId, duration_ms: durationMs }); // ← À PERSONNALISER

    return new Response(                                                         // ← CONSERVER
      JSON.stringify({ success: true, data: { reseau: updatedReseau, integration: updatedIntegration }, message: message || "Aucune modification", requestId }), // ← CONSERVER
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
    );                                                                           // ← CONSERVER

  } catch (e) {                                                                  // ← CONSERVER
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) }); // ← CONSERVER
    return new Response(                                                         // ← CONSERVER
      JSON.stringify({ success: false, error: "internal_error", requestId }),    // ← CONSERVER
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } } // ← CONSERVER
    );                                                                           // ← CONSERVER
  }                                                                              // ← CONSERVER
});                                                                              // ← CONSERVER
```

---

## **Points Clés à Retenir**

1. **Pattern `data.data`** : Toujours retourner `{ success, data: { reseau, integration }, message, requestId }`
2. **Logique Conditionnelle** : Permet de mettre à jour SOIT les données générales, SOIT une intégration, SOIT les deux
3. **UPSERT des Intégrations** : Si l'intégration existe (FK présente) → UPDATE, sinon → INSERT + lien FK
4. **SERVICE_ROLE_KEY** : Permet de bypasser RLS pour les opérations admin
5. **snake_case** : Tous les paramètres reçus et envoyés aux Edge Functions sont en snake_case
6. **Personnalisation Minimale** : Seuls les noms de tables, colonnes ID et champs de liaison nécessitent une adaptation

---
---

# ÉTAPE 8 : Hook - Integrations
**Fichier :** `src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations.ts`
- Toujours utiliser la structure de nomage
- src/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/(Numéroration de la structure de nommage de la table)/hooks/useReseauIntegrations.ts
```typescript
import { useCallback, useState } from 'react';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import type { BrevoFormState, ZohoFormState, OpenAIFormState } from './types';

/**
 * Hook de gestion des intégrations (Brevo, Zoho, OpenAI)
 * Corrections 2025-10-02 :
 *  - Appels EF avec reseau_id (snake_case)
 *  - Parsing conforme { success, data: { reseau, integrations } }
 *  - saveIntegration lit data.data.integration (plus updatedData.*)
 */
export function useReseauIntegrations() {
  const { toast } = useToast();

  // ✅ organisation_id séparé (si besoin futur)
  const [organisationId, setOrganisationId] = useState<string | null>(null);

  // ✅ États UI (formulaire uniquement)
  const [brevo, setBrevo] = useState<BrevoFormState>({});
  const [zoho, setZoho] = useState<ZohoFormState>({});
  const [openai, setOpenAI] = useState<OpenAIFormState>({});

  // ✅ IDs techniques séparés
  const [brevoConnexionId, setBrevoConnexionId] = useState<string | null>(null);
  const [zohoConnexionId, setZohoConnexionId] = useState<string | null>(null);
  const [openaiConnexionId, setOpenaiConnexionId] = useState<string | null>(null);

  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // ================================
  // 🔑 Charger les intégrations d'un réseau
  // ================================
  const loadForReseau = useCallback(async (reseauId: string) => {
    if (!reseauId) return;
    setIsLoading(true);

    try {
      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {
        body: { reseau_id: reseauId },
      });
      if (error) throw error;
      
      const reseau = data?.data?.reseau;
      const integrations = data?.data?.integrations;

      if (!reseau) {
        setOrganisationId(null);
        setBrevo({});
        setZoho({});
        setOpenAI({});
        setBrevoConnexionId(null);
        setZohoConnexionId(null);
        setOpenaiConnexionId(null);
        return;
      }
      
      setOrganisationId(reseau.organisation_id || null);
      setBrevo(integrations?.brevo || {});
      setZoho(integrations?.zoho || {});
      setOpenAI(integrations?.openai || {});
      setBrevoConnexionId(reseau.reseau_brevo_connexion_id || null);
      setZohoConnexionId(reseau.reseau_zoho_connexion_id || null);
      setOpenaiConnexionId(reseau.reseau_openai_connexion_id || null);
      
    } catch (e: any) {
      console.error('Erreur loadForReseau', e);
      toast({ 
        title: 'Erreur', 
        description: 'Impossible de charger les intégrations', 
        variant: 'destructive' 
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // ================================
  // 🔑 Sauvegarde d'une intégration
  // ================================
  const saveIntegration = useCallback(
    async (reseauId: string, kind: 'brevo' | 'zoho' | 'openai') => {
      if (!reseauId) return false;
      setIsSaving(true);

      try {
        let state: any;
        switch (kind) {
          case 'brevo':
            state = brevo;
            break;
          case 'zoho':
            state = zoho;
            break;
          case 'openai':
            state = openai;
            break;
        }

        const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {
          body: { 
            reseauId,
            integrationKind: kind,
            integrationData: state
          }
        });
        if (error || !data?.success) throw error || new Error('Update intégration échoué');

        const updatedIntegration = data?.data?.integration;
        if (updatedIntegration) {
          switch (kind) {
            case 'brevo':
              setBrevo({
                brevo_api_key: updatedIntegration.brevo_api_key,
                brevo_email_compte: updatedIntegration.brevo_email_compte,
                brevo_nom_compte: updatedIntegration.brevo_nom_compte
              });
              setBrevoConnexionId(updatedIntegration.brevo_connexion_id || null);
              break;
            case 'zoho':
              setZoho({
                zoho_api_key: updatedIntegration.zoho_api_key,
                zoho_email_compte: updatedIntegration.zoho_email_compte,
                zoho_nom_compte: updatedIntegration.zoho_nom_compte
              });
              setZohoConnexionId(updatedIntegration.zoho_connexion_id || null);
              break;
            case 'openai':
              setOpenAI({
                openai_api_key: updatedIntegration.openai_api_key,
                openai_email_compte: updatedIntegration.openai_email_compte
              });
              setOpenaiConnexionId(updatedIntegration.openai_connexion_id || null);
              break;
          }
        }

        toast({ title: 'Succès', description: `Intégration ${kind} mise à jour avec succès` });
        return true;
      } catch (e: any) {
        console.error(`Erreur saveIntegration ${kind}`, e);
        toast({ title: 'Erreur', description: e?.message || "Impossible de sauvegarder l'intégration", variant: 'destructive' });
        return false;
      } finally {
        setIsSaving(false);
      }
    },
    [brevo, zoho, openai, toast]
  );

  return {
    organisationId,
    brevo, setBrevo,
    zoho, setZoho,
    openai, setOpenAI,
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    isLoading,
    isSaving,
    loadForReseau,
    saveIntegration,
  };
}
```
---
## **Explications. Comment générer le hook Intégrations pour l'onglet Intégrations**
---
### Sous-Étape 1 : Imports et Déclaration du Hook
- **Objectif** : Importer les dépendances et déclarer le hook principal de gestion des intégrations
- **Directives** :
  - CONSERVER les imports standards : `useCallback`, `useState`, `useToast`, `supabase`
  - PERSONNALISER le nom du hook : `useReseauIntegrations` → `use{Table}Integrations`
  - PERSONNALISER l'import des types : depuis `./types` du dossier de la table concernée

```typescript
import { useCallback, useState } from 'react';              // ← CONSERVER
import { useToast } from '@/hooks/use-toast';                // ← CONSERVER
import { supabase } from '@/integrations/supabase/client';   // ← CONSERVER
import type { BrevoFormState, ZohoFormState, OpenAIFormState } from './types';  // ← CONSERVER

export function useReseauIntegrations() {                    // ← À PERSONNALISER (ex: useAgenceIndepIntegrations)
  const { toast } = useToast();                              // ← CONSERVER
```

---
### Sous-Étape 2 : États UI des Formulaires d'Intégrations
- **Objectif** : Gérer l'état local de chaque intégration (Brevo, Zoho, OpenAI) dans l'interface utilisateur
- **Directives** :
  - CONSERVER intégralement tous les états (types BrevoFormState, ZohoFormState, OpenAIFormState)
  - Ces états sont identiques pour toutes les tables (aucune personnalisation nécessaire)

```typescript
const [brevo, setBrevo] = useState({});      // ← CONSERVER
const [zoho, setZoho] = useState({});        // ← CONSERVER
const [openai, setOpenAI] = useState({});  // ← CONSERVER
```

---
### Sous-Étape 3 : États des IDs Techniques de Connexion
- **Objectif** : Stocker séparément les IDs des tables de connexion (brevo_connexion_id, zoho_connexion_id, openai_connexion_id)
- **Directives** :
  - CONSERVER intégralement : Ces états sont identiques pour toutes les tables
  - Ces IDs permettent de savoir si une intégration existe déjà (pour UPSERT)

```typescript
const [brevoConnexionId, setBrevoConnexionId] = useState(null);    // ← CONSERVER
const [zohoConnexionId, setZohoConnexionId] = useState(null);      // ← CONSERVER
const [openaiConnexionId, setOpenaiConnexionId] = useState(null);  // ← CONSERVER
```

---
### Sous-Étape 4 : États de Chargement et Organisation
- **Objectif** : Gérer les états de chargement et l'organisation associée
- **Directives** :
  - CONSERVER intégralement tous les états (isLoading, isSaving, organisationId)

```typescript
const [organisationId, setOrganisationId] = useState(null);  // ← CONSERVER
const [isLoading, setIsLoading] = useState(false);                          // ← CONSERVER
const [isSaving, setIsSaving] = useState(false);                            // ← CONSERVER
```

---
### Sous-Étape 5 : Fonction `loadForReseau` - Charger les Intégrations
- **Objectif** : Récupérer les données d'intégrations via l'Edge Function de données complètes
- **Directives** :
  - PERSONNALISER le nom de la fonction : `loadForReseau` → `loadFor{Table}`
  - PERSONNALISER le paramètre : `reseauId` → `{table}Id` (ex: `agenceIndepId`)
  - PERSONNALISER l'appel Edge Function : `gestion-reseau-admin-donnees` → `gestion-{table}-admin-donnees`
  - PERSONNALISER le paramètre body : `reseau_id` → `{table}_id` (snake_case)
  - PERSONNALISER l'extraction des IDs de connexion : `reseau.reseau_brevo_connexion_id` → `{table}.{table}_brevo_connexion_id`
  - CONSERVER : La logique générale, le pattern `data.data`, la gestion des erreurs

```typescript
const loadForReseau = useCallback(async (reseauId: string) => {  // ← À PERSONNALISER nom fonction + paramètre
  if (!reseauId) return;                                          // ← CONSERVER
  setIsLoading(true);                                             // ← CONSERVER

  try {
    const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-donnees', {  // ← À PERSONNALISER nom EF
      body: { reseau_id: reseauId },                              // ← À PERSONNALISER clé (snake_case)
    });
    if (error) throw error;                                       // ← CONSERVER

    const reseau = data?.data?.reseau;                            // ← À PERSONNALISER nom variable
    const integrations = data?.data?.integrations;                // ← CONSERVER

    if (!reseau) {                                                // ← À PERSONNALISER nom variable
      setOrganisationId(null);                                    // ← CONSERVER
      setBrevo({});                                               // ← CONSERVER
      setZoho({});                                                // ← CONSERVER
      setOpenAI({});                                              // ← CONSERVER
      setBrevoConnexionId(null);                                  // ← CONSERVER
      setZohoConnexionId(null);                                   // ← CONSERVER
      setOpenaiConnexionId(null);                                 // ← CONSERVER
      return;
    }

    setOrganisationId(reseau.organisation_id || null);                                 // ← CONSERVER
    setBrevo(integrations?.brevo || {});                                               // ← CONSERVER
    setZoho(integrations?.zoho || {});                                                 // ← CONSERVER
    setOpenAI(integrations?.openai || {});                                             // ← CONSERVER
    setBrevoConnexionId(reseau.reseau_brevo_connexion_id || null);                     // ← À PERSONNALISER préfixe
    setZohoConnexionId(reseau.reseau_zoho_connexion_id || null);                       // ← À PERSONNALISER préfixe
    setOpenaiConnexionId(reseau.reseau_openai_connexion_id || null);                   // ← À PERSONNALISER préfixe

  } catch (e: any) {
    console.error('Erreur loadForReseau', e);                     // ← À PERSONNALISER nom dans log
    toast({ 
      title: 'Erreur', 
      description: 'Impossible de charger les intégrations',      // ← CONSERVER
      variant: 'destructive' 
    });
  } finally {
    setIsLoading(false);                                          // ← CONSERVER
  }
}, [toast]);                                                      // ← CONSERVER
```

---
### Sous-Étape 6 : Fonction `saveIntegration` - Sauvegarde d'une Intégration
- **Objectif** : Enregistrer ou mettre à jour une intégration (Brevo, Zoho ou OpenAI)
- **Directives** :
  - PERSONNALISER le paramètre : `reseauId` → `{table}Id` (ex: `agenceIndepId`)
  - PERSONNALISER l'appel Edge Function : `gestion-reseau-admin-update` → `gestion-{table}-admin-update`
  - PERSONNALISER la clé du body : `reseauId` → `{table}Id` (camelCase)
  - CONSERVER : Le paramètre `kind`, la logique switch/case, le pattern `integrationKind` et `integrationData`
  - CONSERVER : La logique de mise à jour des états selon `kind`
  - CONSERVER : Les noms de colonnes des intégrations (brevo_api_key, zoho_email_compte, etc.)

```typescript
const saveIntegration = useCallback(
  async (reseauId: string, kind: 'brevo' | 'zoho' | 'openai') => {  // ← À PERSONNALISER paramètre
    if (!reseauId) return false;                                     // ← À PERSONNALISER nom variable
    setIsSaving(true);                                               // ← CONSERVER

    try {
      let state: any;                                                // ← CONSERVER
      switch (kind) {                                                // ← CONSERVER
        case 'brevo':                                                // ← CONSERVER
          state = brevo;                                             // ← CONSERVER
          break;
        case 'zoho':                                                 // ← CONSERVER
          state = zoho;                                              // ← CONSERVER
          break;
        case 'openai':                                               // ← CONSERVER
          state = openai;                                            // ← CONSERVER
          break;
      }

      const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-update', {  // ← À PERSONNALISER nom EF
        body: { 
          reseauId,                                                  // ← À PERSONNALISER clé (camelCase)
          integrationKind: kind,                                     // ← CONSERVER
          integrationData: state                                     // ← CONSERVER
        }
      });
      if (error || !data?.success) throw error || new Error('Update intégration échoué');  // ← CONSERVER

      const updatedIntegration = data?.data?.integration;            // ← CONSERVER
      if (updatedIntegration) {                                      // ← CONSERVER
        switch (kind) {                                              // ← CONSERVER
          case 'brevo':                                              // ← CONSERVER
            setBrevo({                                               // ← CONSERVER
              brevo_api_key: updatedIntegration.brevo_api_key,       // ← CONSERVER
              brevo_email_compte: updatedIntegration.brevo_email_compte,  // ← CONSERVER
              brevo_nom_compte: updatedIntegration.brevo_nom_compte  // ← CONSERVER
            });
            setBrevoConnexionId(updatedIntegration.brevo_connexion_id || null);  // ← CONSERVER
            break;
          case 'zoho':                                               // ← CONSERVER
            setZoho({                                                // ← CONSERVER
              zoho_api_key: updatedIntegration.zoho_api_key,         // ← CONSERVER
              zoho_email_compte: updatedIntegration.zoho_email_compte,  // ← CONSERVER
              zoho_nom_compte: updatedIntegration.zoho_nom_compte    // ← CONSERVER
            });
            setZohoConnexionId(updatedIntegration.zoho_connexion_id || null);  // ← CONSERVER
            break;
          case 'openai':                                             // ← CONSERVER
            setOpenAI({                                              // ← CONSERVER
              openai_api_key: updatedIntegration.openai_api_key,     // ← CONSERVER
              openai_email_compte: updatedIntegration.openai_email_compte  // ← CONSERVER
            });
            setOpenaiConnexionId(updatedIntegration.openai_connexion_id || null);  // ← CONSERVER
            break;
        }
      }

      toast({ title: 'Succès', description: `Intégration ${kind} mise à jour avec succès` });  // ← CONSERVER
      return true;                                                   // ← CONSERVER
    } catch (e: any) {
      console.error(`Erreur saveIntegration ${kind}`, e);            // ← CONSERVER
      toast({ title: 'Erreur', description: e?.message || "Impossible de sauvegarder l'intégration", variant: 'destructive' });  // ← CONSERVER
      return false;                                                  // ← CONSERVER
    } finally {
      setIsSaving(false);                                            // ← CONSERVER
    }
  },
  [brevo, zoho, openai, toast]                                       // ← CONSERVER
);
```

---
### Sous-Étape 7 : Retour du Hook (Return)
- **Objectif** : Exposer tous les états et fonctions nécessaires au composant formulaire
- **Directives** :
  - CONSERVER intégralement toute la structure de retour
  - Aucune personnalisation nécessaire

```typescript
return {
  organisationId,              // ← CONSERVER
  brevo, setBrevo,            // ← CONSERVER
  zoho, setZoho,              // ← CONSERVER
  openai, setOpenAI,          // ← CONSERVER
  brevoConnexionId,           // ← CONSERVER
  zohoConnexionId,            // ← CONSERVER
  openaiConnexionId,          // ← CONSERVER
  isLoading,                  // ← CONSERVER
  isSaving,                   // ← CONSERVER
  loadForReseau,              // ← À PERSONNALISER nom fonction (loadFor{Table})
  saveIntegration,            // ← CONSERVER
};
```

---
**Points Critiques à Vérifier** :
- **Séparation des états** : États UI (brevo, zoho, openai) séparés des IDs techniques (brevoConnexionId, etc.)
- **Pattern `data.data`** : Parsing conforme `data?.data?.reseau` et `data?.data?.integrations`
- **Snake_case pour EF** : Paramètres body en snake_case (`reseau_id`) vs variables Hook en camelCase (`reseauId`)
- **Nom du hook** : Adapter le nom selon la table (ex: `useReseauIntegrations` → `useAgenceIndepIntegrations`)
- **Edge Functions** : Appeler les bonnes EF (`gestion-{table}-admin-donnees`, `gestion-{table}-admin-update`)
- **IDs de connexion** : Extraire avec le bon préfixe (ex: `reseau.reseau_brevo_connexion_id` → `agenceIndep.agence_indep_brevo_connexion_id`)

**Référence obligatoire** :
- `public/1. Documents Stratégiques/10. Structure des Tables de Connexion & Règles Collaborateurs.md`
---
---
# ÉTAPE 9 : MIGRATION SQL 2 - RLS Storage
```typescript
-- ============================================================
-- 📌 MIGRATION 2 - Policy RLS storage.objects
-- ============================================================

DROP POLICY IF EXISTS "RLS reseau files access" ON storage.objects;

CREATE POLICY "RLS reseau files access"
ON storage.objects
FOR ALL
TO authenticated
USING (
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    name LIKE ('reseau-' || get_user_reseau_id(auth.uid())::text || '/%')
  )
)
WITH CHECK (
  bucket_id = 'bucket-table-reseau'
  AND (
    is_admin_presenca(auth.uid())
    OR
    name LIKE ('reseau-' || get_user_reseau_id(auth.uid())::text || '/%')
  )
);

```
---
## **Explications. Comment générer la migration SQL pour la policy RLS du storage**
---
### Sous-Étape 1 : DROP POLICY IF EXISTS (Sécurité)
- Objectif : Supprimer la policy existante pour éviter les erreurs de duplication
- Directives :
  - Adapter le nom de la policy : "RLS reseau files access"
    - ← À PERSONNALISER (ex: "RLS agence_indep files access", "RLS reseau_agence files access")
  - CONSERVER : DROP POLICY IF EXISTS ... ON storage.objects;
---
### Sous-Étape 2 : CREATE POLICY - Déclaration
- Objectif : Créer la policy RLS pour contrôler l'accès aux fichiers du bucket
- Directives :
  - Adapter le nom de la policy (identique à la sous-étape 1)
  - CONSERVER : ON storage.objects
  - CONSERVER : FOR ALL
  - CONSERVER : TO authenticated
---
### Sous-Étape 3 : Clause USING - Contrôle d'accès en lecture
- Objectif : Définir qui peut lire/accéder aux fichiers
- Directives :
  - Adapter le nom du bucket : bucket_id = 'bucket-table-reseau'
    - ← À PERSONNALISER (ex: 'bucket-table-agence-independante', 'bucket-table-reseau-agence')
  - CONSERVER : Condition admin is_admin_presenca(auth.uid())
    - Adapter la condition organisation avec la fonction utilitaire :
  - name LIKE ('reseau-' || get_user_reseau_id(auth.uid())::text || '/%')
    - ← À PERSONNALISER :
  - Préfixe du nom de fichier : 'reseau-' → 'agence-indep-', 'reseau-agence-'
    - Fonction utilitaire : get_user_reseau_id() → get_user_agence_indep_id(), get_user_reseau_agence_id()
    - CONSERVER : Opérateur OR entre admin et organisation, opérateur LIKE pour le pattern
  - Structure du pattern de fichier :
```typescript
bucket-table-{table}/
  └── {table}-{table_id}/
      ├── logo/
      └── ressources/
```
  - Votre table	Bucket ID	Pattern nom fichier	Fonction utilitaire
```typescript
reseau	bucket-table-reseau	`'reseau-'	
reseau_agence	bucket-table-reseau-agence	`'reseau-agence-'	
agence_independante	bucket-table-agence-independante	`'agence-indep-'
```
---
### Sous-Étape 4 : Clause WITH CHECK - Contrôle d'accès en écriture
- Objectif : Définir qui peut créer/modifier/supprimer des fichiers
- Directives :
  - CONSERVER : La clause WITH CHECK est identique à la clause USING
  - Adapter les mêmes éléments que la sous-étape 3 (bucket_id, pattern, fonction)
  - IMPORTANT : Les deux clauses doivent être strictement identiques pour éviter les incohérences

- Points Critiques à Vérifier
  - Fonction utilitaire créée : La fonction get_user_{table}_id() doit avoir été créée lors de la MIGRATION SQL 1 (ÉTAPE 2)
  - Nom du bucket cohérent : Le bucket doit exister et son nom doit correspondre à celui utilisé dans l'Edge Function Fichiers
  - Pattern de fichier multi-tenant : {table}-{table_id}/ garantit l'isolation des données par organisation
  - Double accès : Admin PRESENCA voit tout (is_admin_presenca) + Organisations voient uniquement leurs fichiers (pattern LIKE)
  - USING = WITH CHECK : Les deux clauses doivent être identiques pour cohérence lecture/écriture

- Référence obligatoire :
  - public/1. Documents Stratégiques/03. Logique Organisations.md (isolation multi-tenant)
  - ÉTAPE 2 de ce document (création de get_user_{table}_id())
---
---
# ÉTAPE 10 : Edge Function - Fichiers (Storage)
**Fichier** : `supabase/functions/gestion-reseau-admin-fichiers/index.ts`
- Toujours utiliser la structure de nomage
- supabase/functions/gestion-(table)-admin-fichiers/index.ts
```typescript
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const BUCKET_NAME = "bucket-table-reseau";

const supabase = createClient(SUPABASE_URL, SERVICE_ROLE_KEY, {
  auth: { autoRefreshToken: false, persistSession: false }
});

type ReseauRow = { reseau_id: string; reseau_logo: string | null; reseau_ressources: string[] | null; };

const corsHeaders: HeadersInit = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

function logStructured(event: string, payload: Record<string, unknown>) {
  console.log(JSON.stringify({ ts: new Date().toISOString(), event, ...payload }));
}

function sanitizeFilename(filename: string): string {
  return filename.replace(/[^a-zA-Z0-9._-]/g, "_");
}

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

async function getReseau(reseauId: string): Promise<ReseauRow | null> {
  const { data, error } = await supabase
    .from("reseau")
    .select("reseau_id, reseau_logo, reseau_ressources")
    .eq("reseau_id", reseauId)
    .maybeSingle();
  if (error) throw new Error(`Erreur récupération réseau: ${error.message}`);
  return data;
}

async function setReseauLogo(reseauId: string, logoPath: string | null) {
  const { error } = await supabase
    .from("reseau")
    .update({ reseau_logo: logoPath })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`Erreur mise à jour logo: ${error.message}`);
}

async function addReseauRessource(reseauId: string, path: string) {
  const reseau = await getReseau(reseauId);
  if (!reseau) throw new Error("Réseau introuvable");
  const current = reseau.reseau_ressources ?? [];
  const updated = [...current, path];
  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`Erreur ajout ressource: ${error.message}`);
}

async function removeReseauRessource(reseauId: string, path: string) {
  const reseau = await getReseau(reseauId);
  if (!reseau) throw new Error("Réseau introuvable");
  const current = reseau.reseau_ressources ?? [];
  const updated = current.filter((r) => r !== path);
  const { error } = await supabase
    .from("reseau")
    .update({ reseau_ressources: updated })
    .eq("reseau_id", reseauId);
  if (error) throw new Error(`Erreur suppression ressource: ${error.message}`);
}

Deno.serve(async (req) => {
  const requestId = crypto.randomUUID();

  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders, status: 204 });
  }

  try {
    const contentType = req.headers.get("content-type") || "";

    // --- UPLOAD (multipart/form-data) ---
    if (contentType.includes("multipart/form-data")) {
      const formData = await req.formData();
      const reseauId = formData.get("reseau_id") as string | null;
      const fileType = formData.get("fileType") as string | null; // 'logo' | 'ressource'
      const file = formData.get("file") as File | null;

      if (!reseauId || !UUID_REGEX.test(reseauId)) {
        return new Response(
          JSON.stringify({ success: false, error: "reseau_id invalide ou manquant", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      if (!fileType || !["logo", "ressource"].includes(fileType)) {
        return new Response(
          JSON.stringify({ success: false, error: "fileType invalide (logo ou ressource)", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      if (!file) {
        return new Response(
          JSON.stringify({ success: false, error: "Aucun fichier fourni", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const reseau = await getReseau(reseauId);
      if (!reseau) {
        return new Response(
          JSON.stringify({ success: false, error: "Réseau introuvable", requestId }),
          { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const sanitized = sanitizeFilename(file.name);
      // ✅ Mapping stratégique: reseau-{uuid}/1-logos/… & reseau-{uuid}/2-documents-institutionnels/…
      const baseFolder = fileType === "logo"
        ? `reseau-${reseauId}/1-logos`
        : `reseau-${reseauId}/2-documents-institutionnels`;
      const storagePath = `${baseFolder}/${Date.now()}_${sanitized}`;

      const fileBuffer = await file.arrayBuffer();
      const { error: uploadErr } = await supabase.storage
        .from(BUCKET_NAME)
        .upload(storagePath, fileBuffer, { contentType: file.type, upsert: false });

      if (uploadErr) {
        logStructured("upload_error", { requestId, reseau_id: reseauId, error: uploadErr.message });
        return new Response(
          JSON.stringify({ success: false, error: "Erreur upload fichier", details: uploadErr.message, requestId }),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      if (fileType === "logo") {
        await setReseauLogo(reseauId, storagePath);
      } else {
        await addReseauRessource(reseauId, storagePath);
      }

      logStructured("upload_success", { requestId, reseau_id: reseauId, file_type: fileType, path: storagePath });

      return new Response(
        JSON.stringify({ success: true, data: { path: storagePath, fileType }, message: "Fichier uploadé avec succès", requestId }),
        { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // --- DELETE (POST JSON) ---
    if (contentType.includes("application/json")) {
      const body = await req.json();
      const { action, reseau_id, fileType, path } = body;

      if (action !== "delete") {
        return new Response(
          JSON.stringify({ success: false, error: "Action invalide (attendu: delete)", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }
      if (!reseau_id || !UUID_REGEX.test(reseau_id)) {
        return new Response(
          JSON.stringify({ success: false, error: "reseau_id invalide ou manquant", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }
      if (!fileType || !["logo", "ressource"].includes(fileType)) {
        return new Response(
          JSON.stringify({ success: false, error: "fileType invalide (logo ou ressource)", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }
      if (!path || typeof path !== "string") {
        return new Response(
          JSON.stringify({ success: false, error: "path manquant", requestId }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const reseau = await getReseau(reseau_id);
      if (!reseau) {
        return new Response(
          JSON.stringify({ success: false, error: "Réseau introuvable", requestId }),
          { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      const { error: deleteErr } = await supabase.storage.from(BUCKET_NAME).remove([path]);
      if (deleteErr) {
        logStructured("delete_error", { requestId, reseau_id, error: deleteErr.message });
        return new Response(
          JSON.stringify({ success: false, error: "Erreur suppression fichier", details: deleteErr.message, requestId }),
          { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      if (fileType === "logo") {
        await setReseauLogo(reseau_id, null);
      } else {
        await removeReseauRessource(reseau_id, path);
      }

      logStructured("delete_success", { requestId, reseau_id, file_type: fileType, path });

      return new Response(
        JSON.stringify({ success: true, data: { deleted: path, fileType }, message: "Fichier supprimé avec succès", requestId }),
        { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    return new Response(
      JSON.stringify({ success: false, error: "Content-Type non supporté", requestId }),
      { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (e) {
    logStructured("unhandled_exception", { requestId, msg: e instanceof Error ? e.message : String(e) });
    return new Response(
      JSON.stringify({ success: false, error: "internal_error", details: e instanceof Error ? e.message : String(e), requestId }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
```
---
## **Explications. Comment générer l'Edge Function de gestion des fichiers (Upload + Delete)**
---
### Sous-Étape 1 : Imports et configuration Supabase Admin
- Objectif : Initialiser le client Supabase avec SERVICE_ROLE_KEY pour bypasser RLS du storage
- Directives :
  - CONSERVER intégralement les imports et la configuration du client
  - CONSERVER auth: { autoRefreshToken: false, persistSession: false }
---
### Sous-Étape 2 : Configuration CORS
- Objectif : Permettre les appels depuis le frontend
- Directives :
  - CONSERVER intégralement l'objet corsHeaders
---
### Sous-Étape 3 : Fonction de logs structurés
- Objectif : Tracer les événements pour le debugging
- Directives :
  - CONSERVER intégralement la fonction logStructured(event, payload)
---
### Sous-Étape 4 : Constante BUCKET_NAME
- Objectif : Définir le nom du bucket de stockage pour cette table
- Directives :
  - Adapter le nom du bucket : const BUCKET_NAME = "bucket-table-reseau";
    - ← À PERSONNALISER (ex: "bucket-table-agence-independante", "bucket-table-reseau-agence")
  - Ce bucket doit correspondre à celui défini dans la MIGRATION SQL 2 (ÉTAPE 9)
---
### Sous-Étape 5 : Handler principal - Preflight CORS
- Objectif : Gérer les requêtes OPTIONS (preflight)
- Directives :
  - CONSERVER intégralement le bloc if (req.method === "OPTIONS")
---
### Sous-Étape 6 : Parsing du FormData
- Objectif : Récupérer les données du formulaire multipart (fichiers + métadonnées)
- Directives :
  - CONSERVER intégralement :
```typescript
const formData = await req.formData();
const action = formData.get("action") as string;
const reseauId = formData.get("reseau_id") as string;  // ← À PERSONNALISER
const fileType = formData.get("fileType") as string;
const file = formData.get("file") as File | null;
const filePath = formData.get("filePath") as string | null;
```
  - Adapter uniquement le nom de l'ID : reseau_id
    - ← À PERSONNALISER (ex: agence_indep_id, reseau_agence_id)
---
### Sous-Étape 7 : Validation des paramètres communs
- Objectif : Vérifier que les paramètres obligatoires sont présents
- Directives :
  - Adapter la validation de l'ID : if (!reseauId)
    - ← À PERSONNALISER
  - CONSERVER : Validation de action (["upload", "delete"])
  - CONSERVER : Validation de fileType (["logo", "ressource"])
  - CONSERVER : Retour d'erreur 400 pour chaque validation
---
### Sous-Étape 8 : Branche action === "upload" - Validation fichier
- Objectif : Vérifier qu'un fichier a bien été envoyé
- Directives :
  - CONSERVER intégralement :
```typescript
if (action === "upload") {
  if (!file) {
    return new Response(
      JSON.stringify({ success: false, error: "missing_file" }),
      { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
```
---
### Sous-Étape 9 : Construction du chemin de fichier (multi-tenant)
- Objectif : Créer un chemin unique et isolé par organisation
- Directives :
  - Adapter le pattern du chemin :
```typescript
const folder = fileType === "logo" ? "logo" : "ressources";
const storagePath = `reseau-${reseauId}/${folder}/${file.name}`;
```
  - ← À PERSONNALISER le préfixe : reseau- → agence-indep-, reseau-agence-
  - CONSERVER : La logique du folder (logo vs ressources)
  - CONSERVER : Le pattern global : {table}-{id}/{folder}/{filename}
  - Structure multi-tenant obligatoire :
```typescript
bucket-table-{table}/
  ├── {table}-{id-1}/
  │   ├── logo/
  │   │   └── logo.png
  │   └── ressources/
  │       ├── doc1.pdf
  │       └── doc2.xlsx
  └── {table}-{id-2}/
      └── ...
```
---
### Sous-Étape 10 : Upload du fichier dans Storage
- Objectif : Envoyer le fichier vers Supabase Storage
- Directives :
  - CONSERVER intégralement :
```typescript
const fileBuffer = await file.arrayBuffer();
const { data: uploadData, error: uploadError } = await supabase.storage
  .from(BUCKET_NAME)
  .upload(storagePath, fileBuffer, {
    contentType: file.type,
    upsert: true
  });

if (uploadError) { ... }
```
  - CONSERVER : upsert: true (remplace le fichier s'il existe déjà)
---
### Sous-Étape 11 : Récupération de l'URL publique
- Objectif : Obtenir l'URL d'accès au fichier uploadé
- Directives :
  - CONSERVER intégralement :
```typescript
const { data: publicUrlData } = supabase.storage
  .from(BUCKET_NAME)
  .getPublicUrl(storagePath);

const publicUrl = publicUrlData?.publicUrl || null;
```
---
### Sous-Étape 12 : Mise à jour de la base de données après upload
- Objectif : Enregistrer l'URL du fichier dans la table métier
- Directives :
  - Adapter le nom de la table : .from("reseau")
    - ← À PERSONNALISER
  - Adapter la logique de mise à jour selon le type de fichier :
```typescript
let updatePayload: any = {};

if (fileType === "logo") {
  updatePayload = { reseau_logo: publicUrl };  // ← À PERSONNALISER le préfixe
} else {
  const { data: currentRecord } = await supabase
    .from("reseau")  // ← À PERSONNALISER
    .select("reseau_ressources")  // ← À PERSONNALISER
    .eq("reseau_id", reseauId)  // ← À PERSONNALISER
    .maybeSingle();
  
  const existingFiles = currentRecord?.reseau_ressources || [];  // ← À PERSONNALISER
  updatePayload = {
    reseau_ressources: [...existingFiles, publicUrl]  // ← À PERSONNALISER
  };
}

await supabase
  .from("reseau")  // ← À PERSONNALISER
  .update(updatePayload)
  .eq("reseau_id", reseauId);  // ← À PERSONNALISER
```
  - CONSERVER : Logique du if/else (logo vs ressources)
  - CONSERVER : Pour ressources, ajouter l'URL au tableau existant
---
### Sous-Étape 13 : Retour de succès upload
- Objectif : Confirmer l'upload et retourner l'URL
- Directives :
  - CONSERVER intégralement :
```typescript
return new Response(
  JSON.stringify({
    success: true,
    data: { publicUrl, storagePath },
    message: "Fichier uploadé avec succès",
    requestId
  }),
  { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
);
```
---
### Sous-Étape 14 : Branche action === "delete" - Validation chemin
- Objectif : Vérifier que le chemin du fichier à supprimer est fourni
- Directives :
  - CONSERVER intégralement :
```typescript
if (action === "delete") {
  if (!filePath) {
    return new Response(
      JSON.stringify({ success: false, error: "missing_file_path" }),
      { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
```
---
### Sous-Étape 15 : Suppression du fichier dans Storage
- Objectif : Supprimer le fichier de Supabase Storage
- Directives :
  - CONSERVER intégralement :
```typescript
const { error: deleteError } = await supabase.storage
  .from(BUCKET_NAME)
  .remove([filePath]);

if (deleteError) { ... }
```
---
### Sous-Étape 16 : Mise à jour de la base de données après suppression
- Objectif : Retirer l'URL du fichier de la table métier
- Directives :
  - Adapter le nom de la table : .from("reseau")
    - ← À PERSONNALISER
  - Adapter la logique de mise à jour selon le type de fichier :
```typescript
if (fileType === "logo") {
  await supabase
    .from("reseau")  // ← À PERSONNALISER
    .update({ reseau_logo: null })  // ← À PERSONNALISER
    .eq("reseau_id", reseauId);  // ← À PERSONNALISER
} else {
  const { data: currentRecord } = await supabase
    .from("reseau")  // ← À PERSONNALISER
    .select("reseau_ressources")  // ← À PERSONNALISER
    .eq("reseau_id", reseauId)  // ← À PERSONNALISER
    .maybeSingle();
  
  const existingFiles = currentRecord?.reseau_ressources || [];  // ← À PERSONNALISER
  const updatedFiles = existingFiles.filter((url: string) => !url.includes(filePath));
  
  await supabase
    .from("reseau")  // ← À PERSONNALISER
    .update({ reseau_ressources: updatedFiles })  // ← À PERSONNALISER
    .eq("reseau_id", reseauId);  // ← À PERSONNALISER
}
```
  - CONSERVER : Logique du if/else, filtre par includes(filePath)
---
### Sous-Étape 17 : Retour de succès delete
- Objectif : Confirmer la suppression
- Directives :
  - CONSERVER intégralement :
```typescript
return new Response(
  JSON.stringify({
    success: true,
    message: "Fichier supprimé avec succès",
    requestId
  }),
  { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
);
```
---
### Sous-Étape 18 : Gestion des exceptions non gérées
- Objectif : Capturer toute erreur imprévue
- Directives :
  - CONSERVER intégralement le bloc catch (e) final

- Points Critiques à Vérifier
  - Bucket name cohérent : Doit correspondre à la MIGRATION SQL 2 et à la policy RLS
  - Pattern multi-tenant strict : {table}-{id}/{folder}/{filename} garantit l'isolation
  - Deux types de fichiers : Logo (1 seul fichier, remplace) vs Ressources (tableau, ajoute/supprime)
  - Mise à jour DB obligatoire : Toujours synchroniser Storage ↔ Base de données
  - Colonnes de stockage : {table}_logo (string | null) et {table}_ressources (string[] | null)
  - upsert: true : Permet de remplacer un fichier existant (important pour logo)
  - SERVICE_ROLE_KEY : Bypass total de RLS Storage (fonction admin uniquement)

- Référence obligatoire :
  - ÉTAPE 9 de ce document (Policy RLS Storage)
  - public/1. Documents Stratégiques/03. Logique Organisations.md (isolation multi-tenant)
---
---
# ÉTAPE 11 : Composant Formulaire Principal
**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/3.FormReseauGestion.tsx`
- Toujours utiliser la structure de nomage
- src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/(Numéroration de la structure de nommage de la table)/3.FormReseauGestion.tsx
```typescript
import React, { useEffect, useRef, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../../3-Utilitaires/tabs";
import { Upload, Download, Trash2, Eye } from 'lucide-react';
import GraphBoutonModifier from '../../5-Graphisme/1.GraphFormulaires/5.GraphBoutonModifier';
import { ReseauSelector } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector';
import { useReseauFormData } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData';
import { useReseauIntegrations } from '@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

interface Props {
  onBack?: () => void;
}

const FormReseauGestion: React.FC<Props> = ({ onBack }) => {
  const { toast } = useToast();

  const {
    reseaux,
    selectedReseauId,
    formData,
    isLoading,
    isSaving,
    errors,
    loadReseaux,
    selectReseau,
    updateFormField,
    saveReseau,
    loadReseauData,
  } = useReseauFormData();

  const {
    brevo, setBrevo,
    zoho, setZoho,
    openai, setOpenAI,
    brevoConnexionId,
    zohoConnexionId,
    openaiConnexionId,
    isLoading: integLoading,
    isSaving: integSaving,
    loadForReseau,
    saveIntegration,
  } = useReseauIntegrations();

  const [isEditingGeneral, setIsEditingGeneral] = useState(false);
  const [isEditingBrevo, setIsEditingBrevo] = useState(false);
  const [isEditingZoho, setIsEditingZoho] = useState(false);
  const [isEditingOpenAI, setIsEditingOpenAI] = useState(false);
  const [isEditingLogo, setIsEditingLogo] = useState(false);
  const [isEditingDocuments, setIsEditingDocuments] = useState(false);

  const logoInputRef = useRef<HTMLInputElement | null>(null);
  const docsInputRef = useRef<HTMLInputElement | null>(null);
  const [selectedLogo, setSelectedLogo] = useState<File | null>(null);
  const [selectedDocs, setSelectedDocs] = useState<File[]>([]);

  useEffect(() => { loadReseaux(); }, [loadReseaux]);
  useEffect(() => { if (selectedReseauId) loadForReseau(selectedReseauId); }, [selectedReseauId, loadForReseau]);

  const handleSaveGeneral = async () => {
    if (!selectedReseauId) return;
    const success = await saveReseau({
      reseau_nom: formData.reseau_nom,
      reseau_identite_commerciale: formData.reseau_identite_commerciale,
      reseau_adresse: formData.reseau_adresse,
      reseau_code_postal: formData.reseau_code_postal,
      reseau_ville: formData.reseau_ville,
      reseau_siret: formData.reseau_siret,
      reseau_telephone: formData.reseau_telephone,
      reseau_email: formData.reseau_email,
    });
    if (success) setIsEditingGeneral(false);
  };

  const handleSaveBrevo = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'brevo'); if (ok) setIsEditingBrevo(false); };
  const handleSaveZoho = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'zoho'); if (ok) setIsEditingZoho(false); };
  const handleSaveOpenAI = async () => { if (!selectedReseauId) return; const ok = await saveIntegration(selectedReseauId, 'openai'); if (ok) setIsEditingOpenAI(false); };

  const reloadAll = async () => {
    if (selectedReseauId) {
      await loadReseauData(selectedReseauId);
      await loadForReseau(selectedReseauId);
      setSelectedLogo(null);
      setSelectedDocs([]);
    }
  };

  // ✅ Upload fichier (logo / ressource) vers EF corrigée (Step04 + mapping stratégie)
  const uploadFile = async (type: 'logo' | 'document', file: File, reseauId: string) => {
    const fd = new FormData();
    fd.append('file', file);
    // EF Step04 attend fileType: 'logo' | 'ressource'
    fd.append('fileType', type === 'document' ? 'ressource' : 'logo');
    // EF Step04 attend reseau_id (snake_case)
    fd.append('reseau_id', reseauId);

    const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', { body: fd });
    if (error || !data?.success) throw error || new Error('Upload échoué');
    return (data?.data?.path as string) || '';
  };

  const handleSaveLogo = async () => {
    if (!selectedReseauId || !selectedLogo) { setIsEditingLogo(false); return; }
    try {
      await uploadFile('logo', selectedLogo, selectedReseauId);
      toast({ title: 'Succès', description: 'Logo mis à jour' });
      await reloadAll();
      setIsEditingLogo(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader le logo", variant: 'destructive' });
    }
  };

  const handleSaveDocuments = async () => {
    if (!selectedReseauId) { setIsEditingDocuments(false); return; }
    try {
      for (const f of selectedDocs) {
        await uploadFile('document', f, selectedReseauId);
      }
      toast({ title: 'Succès', description: 'Documents mis à jour' });
      await reloadAll();
      setIsEditingDocuments(false);
    } catch {
      toast({ title: 'Erreur', description: "Impossible d'uploader les documents", variant: 'destructive' });
    }
  };

  // ✅ Suppression via EF (POST JSON), plus de DELETE
  const removeStoragePath = async (path: string, fileType: 'logo' | 'ressource') => {
    const { data, error } = await supabase.functions.invoke('gestion-reseau-admin-fichiers', {
      body: { action: 'delete', reseau_id: selectedReseauId, fileType, path }
    });
    if (error || !data?.success) throw error || new Error('Suppression échouée');
  };

  const handleDeleteLogo = async () => {
    if (!selectedReseauId || !formData.reseau_logo) return;
    try {
      await removeStoragePath(formData.reseau_logo, 'logo');
      toast({ title: 'Succès', description: 'Logo supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression logo impossible', variant: 'destructive' });
    }
  };

  const handleDeleteDocument = async (docPath: string) => {
    if (!selectedReseauId) return;
    try {
      await removeStoragePath(docPath, 'ressource');
      toast({ title: 'Succès', description: 'Document supprimé' });
      await reloadAll();
    } catch {
      toast({ title: 'Erreur', description: 'Suppression document impossible', variant: 'destructive' });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); };

  return (
    <div className="space-y-6">
      <ReseauSelector
        reseaux={reseaux}
        selectedReseauId={selectedReseauId}
        onSelect={selectReseau}
        isLoading={isLoading}
      />

      <Tabs defaultValue="general" className="w-full">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="general" className="text-base font-semibold">Général</TabsTrigger>
          <TabsTrigger value="integrations" className="text-base font-semibold">Intégrations</TabsTrigger>
          <TabsTrigger value="fichiers" className="text-base font-semibold">Fichiers</TabsTrigger>
        </TabsList>

        <form onSubmit={handleSubmit}>
          {/* ✅ Informations Générales (UI inchangée) */}
          <TabsContent value="general" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">Informations Générales</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveGeneral}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingGeneral}
                    isLoading={isSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_nom">Nom du Réseau</Label>
                      <Input
                        id="reseau_nom"
                        value={formData.reseau_nom || ''}
                        onChange={e => updateFormField('reseau_nom', e.target.value)}
                        placeholder="Nom du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_identite_commerciale">Identité Commerciale du Réseau</Label>
                      <Input
                        id="reseau_identite_commerciale"
                        value={formData.reseau_identite_commerciale || ''}
                        onChange={e => updateFormField('reseau_identite_commerciale', e.target.value)}
                        placeholder="Optionnel. Si Nom Commercial différent"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_adresse">Adresse</Label>
                      <Input
                        id="reseau_adresse"
                        value={formData.reseau_adresse || ''}
                        onChange={e => updateFormField('reseau_adresse', e.target.value)}
                        placeholder="Adresse. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_code_postal">Code Postal</Label>
                      <Input
                        id="reseau_code_postal"
                        value={formData.reseau_code_postal || ''}
                        onChange={e => updateFormField('reseau_code_postal', e.target.value)}
                        placeholder="Code Postal. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                  <div className="space-y-4">
                    <div>
                      <Label htmlFor="reseau_ville">Ville</Label>
                      <Input
                        id="reseau_ville"
                        value={formData.reseau_ville || ''}
                        onChange={e => updateFormField('reseau_ville', e.target.value)}
                        placeholder="Ville. Siège Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_siret">Siret</Label>
                      <Input
                        id="reseau_siret"
                        value={formData.reseau_siret || ''}
                        onChange={e => updateFormField('reseau_siret', e.target.value)}
                        placeholder="N° Siret du Réseau"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_telephone">Téléphone Direction</Label>
                      <Input
                        id="reseau_telephone"
                        value={formData.reseau_telephone || ''}
                        onChange={e => updateFormField('reseau_telephone', e.target.value)}
                        placeholder="Tél. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                    <div>
                      <Label htmlFor="reseau_email">Email Direction</Label>
                      <Input
                        id="reseau_email"
                        type="email"
                        value={formData.reseau_email || ''}
                        onChange={e => updateFormField('reseau_email', e.target.value)}
                        placeholder="Email. Reseau Direction"
                        disabled={!isEditingGeneral}
                      />
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Intégrations (UI inchangée) */}
          <TabsContent value="integrations" className="space-y-6">
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Brevo</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveBrevo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingBrevo}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="brevo_api_key">Clé API Brevo</Label>
                    <Input
                      id="brevo_api_key"
                      type="password"
                      placeholder="Renseigner. N° Clé API"
                      value={brevo.brevo_api_key || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_api_key: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_email_compte">Email Compte Brevo</Label>
                    <Input
                      id="brevo_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Brevo"
                      value={brevo.brevo_email_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_email_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                  <div>
                    <Label htmlFor="brevo_nom_compte">Nom Compte Brevo</Label>
                    <Input
                      id="brevo_nom_compte"
                      placeholder="Renseigner. Nom compte Brevo"
                      value={brevo.brevo_nom_compte || ''}
                      onChange={e => setBrevo({ ...brevo, brevo_nom_compte: e.target.value })}
                      disabled={!isEditingBrevo}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration Zoho</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveZoho}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingZoho}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <Label htmlFor="zoho_api_key">Clé API Zoho</Label>
                    <Input
                      id="zoho_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API Zoho"
                      value={zoho.zoho_api_key || ''}
                      onChange={e => setZoho({ ...zoho, zoho_api_key: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_email_compte">Email Compte Zoho</Label>
                    <Input
                      id="zoho_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte Zoho"
                      value={zoho.zoho_email_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_email_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                  <div>
                    <Label htmlFor="zoho_nom_compte">Nom Compte Zoho</Label>
                    <Input
                      id="zoho_nom_compte"
                      placeholder="Renseigner. Nom compte Zoho"
                      value={zoho.zoho_nom_compte || ''}
                      onChange={e => setZoho({ ...zoho, zoho_nom_compte: e.target.value })}
                      disabled={!isEditingZoho}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold flex items-center gap-2">Intégration OpenAI</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveOpenAI}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingOpenAI}
                    isLoading={integSaving}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <Label htmlFor="openai_api_key">Clé API OpenAI</Label>
                    <Input
                      id="openai_api_key"
                      type="password"
                      placeholder="Renseigner. Clé API OpenAI"
                      value={openai.openai_api_key || ''}
                      onChange={e => setOpenAI({ ...openai, openai_api_key: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                  <div>
                    <Label htmlFor="openai_email_compte">Email Compte OpenAI</Label>
                    <Input
                      id="openai_email_compte"
                      type="email"
                      placeholder="Renseigner. Email associé compte OpenAI"
                      value={openai.openai_email_compte || ''}
                      onChange={e => setOpenAI({ ...openai, openai_email_compte: e.target.value })}
                      disabled={!isEditingOpenAI}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* ✅ Fichiers - STRUCTURE 2 CARTES SÉPARÉES (UI inchangée) */}
          <TabsContent value="fichiers" className="space-y-6">
            {/* 🎨 Logo du Réseau */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">Logo du Réseau</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveLogo}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingLogo}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="reseau_logo_upload">Télécharger le Logo du Réseau</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingLogo && logoInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Upload className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner le logo</p>
                          <p className="text-xs text-muted-foreground">PNG, JPG, SVG - Max 2MB</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={logoInputRef}
                      id="reseau_logo_upload"
                      type="file"
                      accept="image/*"
                      hidden
                      disabled={!isEditingLogo}
                      onChange={e => setSelectedLogo(e.target.files?.[0] || null)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Logo actuel</Label>
                    <div className="border rounded-lg p-4 bg-muted/20">
                      {formData.reseau_logo ? (
                        <div className="flex items-center justify-between">
                          <div className="flex items-center gap-3">
                            <div className="w-16 h-16 border rounded bg-white flex items-center justify-center">
                              <Upload className="h-5 w-5 text-muted-foreground" />
                            </div>
                            <div>
                              <p className="font-medium break-all">{formData.reseau_logo}</p>
                            </div>
                          </div>
                          <div className="flex gap-2">
                            <Button
                              type="button"
                              variant="destructive"
                              size="sm"
                              onClick={handleDeleteLogo}
                              disabled={!isEditingLogo}
                            >
                              Supprimer
                            </Button>
                          </div>
                        </div>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun logo uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* 📄 Documents Institutionnels */}
            <Card>
              <CardHeader>
                <div className="flex justify-between items-center">
                  <CardTitle className="text-2xl font-bold">Documents Institutionnels</CardTitle>
                  <GraphBoutonModifier
                    onSave={handleSaveDocuments}
                    onCancel={reloadAll}
                    onEditingChange={setIsEditingDocuments}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label>Télécharger les documents</Label>
                    <div
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer"
                      onClick={() => isEditingDocuments && docsInputRef.current?.click()}
                    >
                      <div className="space-y-2">
                        <div className="mx-auto w-12 h-12 text-muted-foreground">
                          <Download className="h-6 w-6" />
                        </div>
                        <div>
                          <p className="text-sm">Cliquer pour sélectionner les documents</p>
                          <p className="text-xs text-muted-foreground">PDF, DOC, DOCX - Max 10MB par fichier</p>
                        </div>
                      </div>
                    </div>
                    <input
                      ref={docsInputRef}
                      type="file"
                      multiple
                      accept=".pdf,.doc,.docx,.xls,.xlsx"
                      hidden
                      disabled={!isEditingDocuments}
                      onChange={e => setSelectedDocs(e.target.files ? Array.from(e.target.files) : [])}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>Supprimer un fichier existant</Label>
                    <div className="border rounded-lg p-4 bg-muted/20 space-y-3">
                      {formData.reseau_ressources && formData.reseau_ressources.length > 0 ? (
                        <>
                          {formData.reseau_ressources.map((p) => (
                            <div key={p} className="flex items-center justify-between p-3 border rounded bg-white">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-blue-100 rounded flex items-center justify-center">
                                  <Download className="h-4 w-4 text-blue-600" />
                                </div>
                                <div className="max-w-[60ch]">
                                  <p className="font-medium break-all">{p}</p>
                                </div>
                              </div>
                              <div className="flex gap-2">
                                <Button
                                  type="button"
                                  variant="outline"
                                  size="sm"
                                  onClick={async () => {
                                    const { data } = await supabase.storage
                                      .from('bucket-table-reseau')
                                      .createSignedUrl(p, 60);
                                    if (data?.signedUrl) window.open(data.signedUrl, '_blank');
                                  }}
                                >
                                  <Eye className="h-4 w-4 mr-1" />
                                  Voir
                                </Button>
                                <Button
                                  type="button"
                                  variant="destructive"
                                  size="sm"
                                  onClick={() => handleDeleteDocument(p)}
                                  disabled={!isEditingDocuments}
                                >
                                  <Trash2 className="h-4 w-4 mr-1" />
                                  Supprimer
                                </Button>
                              </div>
                            </div>
                          ))}
                        </>
                      ) : (
                        <span className="text-muted-foreground text-sm">Aucun document uploadé</span>
                      )}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </form>
      </Tabs>

      {onBack && (
        <div className="pt-6">
          <Button type="button" variant="outline" onClick={onBack}>
            ← Retour
          </Button>
        </div>
      )}
    </div>
  );
};

export default FormReseauGestion;
```
---
## **Explications. Comment Personnaliser la Page Form Gestion**
- Avertissement : Ce formulaire est conçu par l'Admin PRESENCA qui décide des champs à afficher
- Directive absolue :
  - Les champs, titres, labels et placeholders sont choisis par l'Admin PRESENCA
  - Ces choix doivent être strictement respectés lors de l'adaptation à une nouvelle table
- VÉRIFICATION OBLIGATOIRE N°1 : Consulter TablesReference{Table}.ts pour connaître les colonnes disponibles
- VÉRIFICATION OBLIGATOIRE N°2 : Consulter Supabase pour vérifier les colonnes réelles de la table
- MAPPING OBLIGATOIRE : Faire correspondre chaque champ du formulaire avec les colonnes exactes de la base de données
---
### Sous-Étape 1 : Imports des composants et hooks
- Objectif : Importer tous les composants UI, hooks custom et dépendances
- Directives :
  - CONSERVER : Tous les imports de @/components/ui/ (card, tabs, input, label, button, etc.)
  - CONSERVER : useState de React
  - CONSERVER : toast de Sonner
  - Adapter les imports des hooks custom :
    - import { useReseauFormData } from "@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauFormData";
    - ← À PERSONNALISER le chemin et le nom du hook
    - import { useReseauIntegrations } from "@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/hooks/useReseauIntegrations";
    - ← À PERSONNALISER
  - Adapter l'import du Selector :
    - import ReseauSelector from "@/components/HOOKS-STRATEGIQUE/6.HOOKS-GestionCompteAdminPresenca/1.Reseau/components/ReseauSelector";
    - ← À PERSONNALISER
---
### Sous-Étape 2 : Déclaration du composant et initialisation des hooks
- Objectif : Créer le composant et récupérer les données des hooks
- Directives :
  - Adapter le nom du composant : export const Form{Table}Gestion = () => {
  - Adapter l'appel du hook FormData :
```typescript
const {
  reseaux,              // ← À PERSONNALISER (nom variable)
  selectedReseauId,     // ← À PERSONNALISER
  formData,             // CONSERVER
  isLoading,            // CONSERVER
  isSaving,             // CONSERVER
  errors,               // CONSERVER
  selectReseau,         // ← À PERSONNALISER
  saveReseau,           // ← À PERSONNALISER
  updateFormField       // CONSERVER
} = useReseauFormData();  // ← À PERSONNALISER
Adapter l'appel du hook Integrations :

const {
  integrations,           // CONSERVER
  isSaving: isSavingIntegration,  // CONSERVER
  updateIntegrationField,  // CONSERVER
  saveIntegration,        // CONSERVER
  hasUnsavedChanges       // CONSERVER
} = useReseauIntegrations({ reseauId: selectedReseauId });  // ← À PERSONNALISER la prop
```
---
### Sous-Étape 3 : State local pour les onglets
- Objectif : Gérer l'onglet actif (Général, Intégrations, Fichiers)
- Directives :
  - CONSERVER intégralement :
```typescript
const [activeTab, setActiveTab] = useState<"general" | "integrations" | "fichiers">("general");
```
---
### Sous-Étape 4 : Structure Card principale et titre
- Objectif : Créer le conteneur principal du formulaire
- Directives :
  - CONSERVER : <Card className="w-full">, <CardHeader>, <CardContent>.
  - Adapter le titre dans <CardTitle> :
    - Exemple : "Gestion des Réseaux", "Gestion des Agences Indépendantes"
  - Adapter la description dans <CardDescription> :
    - Exemple : "Modifier les informations d'un réseau existant"
---
### Sous-Étape 5 : Intégration du Selector
- Objectif : Afficher le dropdown de sélection
- Directives :
  - Adapter le nom du composant : <ReseauSelector />.
    - ← À PERSONNALISER (ex: <AgenceIndepSelector />).
    - Adapter les props passées :
```typescript
<ReseauSelector
  reseaux={reseaux}              // ← À PERSONNALISER
  selectedReseauId={selectedReseauId}  // ← À PERSONNALISER
  onSelect={selectReseau}        // ← À PERSONNALISER
  isLoading={isLoading}          // CONSERVER
/>
```
---
### Sous-Étape 6 : Condition d'affichage du formulaire
- Objectif : Afficher le formulaire uniquement si un item est sélectionné
- Directives :
  - CONSERVER intégralement :
```typescript
{formData && (
  <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as any)} className="w-full">
    ...
  </Tabs>
)}
```
---
### Sous-Étape 7 : TabsList - Navigation entre onglets
- Objectif : Créer les boutons de navigation entre les 3 onglets
- Directives :
  - CONSERVER intégralement :
```typescript
<TabsList className="grid w-full grid-cols-3">
  <TabsTrigger value="general">Général</TabsTrigger>
  <TabsTrigger value="integrations">Intégrations</TabsTrigger>
  <TabsTrigger value="fichiers">Fichiers</TabsTrigger>
</TabsList>
```
---

### Sous-Étape 8 : ONGLET GÉNÉRAL - Structure
- Objectif : Créer le contenu de l'onglet de modification des données générales
- Directives :
  - CONSERVER : <TabsContent value="general">, <Card>, <CardHeader>, <CardContent>.
  - Adapter le titre : "Informations du Réseau" → selon votre table
  - Adapter la description : "Modifier les informations principales du réseau" → selon votre table
---
### Sous-Étape 9 : ONGLET GÉNÉRAL - Champs du formulaire
- Objectif : Créer les champs de saisie pour modifier les données
- Directives :
  - VÉRIFICATION OBLIGATOIRE N°1 : Consulter TablesReference{Table}.ts pour lister les colonnes disponibles
  - VÉRIFICATION OBLIGATOIRE N°2 : Vérifier dans Supabase les noms exacts des colonnes
  - MAPPING OBLIGATOIRE : Chaque champ doit correspondre à une colonne réelle de la table
  - CONSERVER : Structure de base de chaque champ :
```typescript
<div className="space-y-2">
  <Label htmlFor="{field}">Titre du champ</Label>  {/* ← À PERSONNALISER */}
  <Input
    id="{field}"
    value={formData.{table}_{field} || ""}  {/* ← À PERSONNALISER */}
    onChange={(e) => updateFormField("{table}_{field}", e.target.value)}  {/* ← À PERSONNALISER */}
    placeholder="Placeholder..."  {/* ← À PERSONNALISER */}
  />
  {errors.{table}_{field} && (  {/* ← À PERSONNALISER */}
    <p className="text-sm text-destructive">{errors.{table}_{field}}</p>
  )}
</div>
```
- Adapter pour chaque champ de votre table :
  - Le Label (texte affiché à l'utilisateur)
  - Le id et nom de colonne dans formData.{table}_{field}
  - Le placeholder
  - L'appel à updateFormField avec le nom exact de la colonne
  - L'affichage de l'erreur avec errors.{table}_{field}
    - Exemple de mapping pour table reseau :
```typescript
Label affiché	Col```typescriptonne DB	formData	updateFormField
"Nom du réseau"	reseau_nom	formData.reseau_nom	updateFormField("reseau_nom", ...)
"Adresse"	reseau_adresse	formData.reseau_adresse	updateFormField("reseau_adresse", ...)
"SIRET"	reseau_siret	formData.reseau_siret	updateFormField("reseau_siret", ...)
```
---
### Sous-Étape 10 : ONGLET GÉNÉRAL - Bouton de sauvegarde
- Objectif : Permettre la sauvegarde des modifications
- Directives :
  - Adapter le texte et l'appel de fonction :
```typescript
<Button onClick={saveReseau} disabled={isSaving}>  {/* ← À PERSONNALISER */}
  {isSaving ? "Enregistrement..." : "Enregistrer les modifications"}
</Button>
```
---
### Sous-Étape 11 : ONGLET INTÉGRATIONS - Structure
- Objectif : Créer le contenu de l'onglet de gestion des intégrations
- Directives :
  - CONSERVER intégralement la structure :
    - 3 sections (Brevo, Zoho, OpenAI)
    - Chaque section dans une Card avec titre et description
    - Champs identiques : API Key, Email, Nom (selon l'intégration)
    - Bouton de sauvegarde avec détection de changements
---
### Sous-Étape 12 : ONGLET INTÉGRATIONS - Section Brevo
- Objectif : Gérer l'intégration Brevo
- Directives :
  - CONSERVER intégralement :
```typescript
<Card>
  <CardHeader>
    <CardTitle className="text-lg">Brevo (Email Marketing)</CardTitle>
    <CardDescription>Configuration de l'intégration Brevo</CardDescription>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* Champ API Key */}
    <div className="space-y-2">
      <Label htmlFor="brevo_api_key">Clé API Brevo</Label>
      <Input
        id="brevo_api_key"
        type="password"
        value={integrations.brevo.brevo_api_key || ""}
        onChange={(e) => updateIntegrationField("brevo", "brevo_api_key", e.target.value)}
        placeholder="Entrez votre clé API Brevo"
      />
    </div>
    {/* Champ Email */}
    {/* Champ Nom */}
    {/* Bouton avec détection changements */}
    <Button
      onClick={() => saveIntegration("brevo")}
      disabled={isSavingIntegration || !hasUnsavedChanges("brevo")}
    >
      {isSavingIntegration ? "Enregistrement..." : "Enregistrer Brevo"}
    </Button>
  </CardContent>
</Card>
```
  - ⚠️ Ces structures sont identiques pour toutes les tables
---
### Sous-Étape 13 : ONGLET INTÉGRATIONS - Sections Zoho et OpenAI
- Objectif : Gérer les intégrations Zoho et OpenAI
- Directives :
  - CONSERVER la même structure que Brevo
  - Adapter uniquement :
    - Les textes des titres et descriptions
    - Les noms des champs selon l'intégration (voir types.ts)
    - Les appels updateIntegrationField("zoho", ...) et saveIntegration("zoho")
---
### Sous-Étape 14 : ONGLET FICHIERS - Structure
- Objectif : Créer l'onglet de gestion des fichiers (Logo + Ressources)
- Directives :
  - CONSERVER : Structure de base avec 2 sections (Logo et Ressources)
  - CONSERVER : Logique de gestion des states locaux pour les fichiers
  - CONSERVER : Appels aux fonctions handleUploadLogo, handleUploadRessource, handleDeleteRessource
---
### Sous-Étape 15 : ONGLET FICHIERS - Fonctions de gestion
- Objectif : Implémenter l'upload et la suppression de fichiers
- Directives :
  - Adapter les appels Edge Function : supabase.functions.invoke('gestion-reseau-admin-fichiers')
    - ← À PERSONNALISER
  - Adapter le body des requêtes :
```typescript
{
  action: "upload" | "delete",
  reseau_id: formData.reseau_id,  // ← À PERSONNALISER
  fileType: "logo" | "ressource",
  file: file,  // pour upload
  filePath: path  // pour delete
}
```
  - Adapter les mises à jour de formData après succès :
    - Pour logo : updateFormField("reseau_logo", publicUrl)
    - ← À PERSONNALISER
    - Pour ressources : updateFormField("reseau_ressources", [...existingFiles, publicUrl])
    - ← À PERSONNALISER
  - CONSERVER : Gestion d'erreur, toasts, structure try/catch
---
### Sous-Étape 16 : Export du composant
- Objectif : Exporter le composant pour utilisation
- Directives :
  - Adapter le nom : export default Form{Table}Gestion;

- Points Critiques à Vérifier
  - VÉRIFICATION TRIPLE OBLIGATOIRE :
    - Consulter TablesReference{Table}.ts
    - Vérifier dans Supabase les colonnes réelles
    - Mapper chaque champ du formulaire avec les colonnes DB
  - Choix Admin PRESENCA : Les labels, placeholders et champs affichés doivent correspondre aux besoins métier
  - 3 onglets obligatoires : Général, Intégrations, Fichiers
  - Intégrations identiques : Brevo, Zoho, OpenAI sont les mêmes pour toutes les tables
  - Cohérence des noms : Les props des hooks, composants et fonctions doivent tous correspondre
  - Gestion des erreurs : Afficher les erreurs de validation sous chaque champ concerné
  - États de chargement : Désactiver les boutons pendant isSaving ou isSavingIntegration

- Références obligatoires :
  - TablesReference{Table}.ts (colonnes disponibles)
  - Supabase (vérification des colonnes réelles)
  - ÉTAPE 1 : Types TypeScript (pour les interfaces)
  - ÉTAPE 6 : Hook FormData (pour l'onglet Général)
  - ÉTAPE 8 : Hook Integrations (pour l'onglet Intégrations)
---
---
# ÉTAPE 12 : Configuration finale
**Fichier :** `supabase/config.toml`
```typescript
project_id = "ksymahfrtvhnbeobsspt"

[functions.notifier-nouvelle-demande]
verify_jwt = false

[functions.create-reseau-admin]
verify_jwt = false

[functions.gestion-reseau-admin]
verify_jwt = false

[functions.gestion-reseau-admin-donnees]
verify_jwt = false

[functions.gestion-reseau-admin-update]
verify_jwt = false

[functions.gestion-reseau-admin-fichiers]
verify_jwt = false
```
---
## **Explications. Comment configurer les Edge Functions dans config.toml**
---
### Sous-Étape 1 : Conserver la ligne project_id
- Objectif : Maintenir l'identifiant du projet Supabase en première ligne
- Directives :
  - CONSERVER impérativement : project_id = "ksymahfrtvhnbeobsspt"
  - ATTENTION : Cette ligne doit toujours rester en première position du fichier
---
### Sous-Étape 2 : Configuration Edge Function Liste (Selector)
- Objectif : Configurer la fonction de récupération de la liste pour le dropdown
- Directives :
  - Adapter le nom de la section : [functions.gestion-{table}-admin]
    - Exemple : [functions.gestion-reseau-admin], [functions.gestion-agence-indep-admin]
  - CONSERVER : verify_jwt = false
    - IMPORTANT : verify_jwt = false car cette fonction utilise SERVICE_ROLE_KEY (Admin PRESENCA uniquement)
```typescript
[
functions.gestion-reseau-admin
]     # ← À PERSONNALISER
verify_jwt = false
```
---
### Sous-Étape 3 : Configuration Edge Function Données Complètes
- Objectif : Configurer la fonction de récupération des données détaillées + intégrations
- Directives :
  - Adapter le nom de la section : [functions.gestion-{table}-admin-donnees]
  - CONSERVER : verify_jwt = false
```typescript
[
functions.gestion-reseau-admin-donnees
]     # ← À PERSONNALISER
verify_jwt = false
```
---
### Sous-Étape 4 : Configuration Edge Function Update
- Objectif : Configurer la fonction de mise à jour (Général + Intégrations)
- Directives :
  - Adapter le nom de la section : [functions.gestion-{table}-admin-update]
  - CONSERVER : verify_jwt = false
```typescript
[
functions.gestion-reseau-admin-update
]     # ← À PERSONNALISER
verify_jwt = false
```
---
### Sous-Étape 5 : Configuration Edge Function Fichiers
- Objectif : Configurer la fonction de gestion des fichiers (Upload + Delete)
- Directives :
  - Adapter le nom de la section : [functions.gestion-{table}-admin-fichiers]
  - CONSERVER : verify_jwt = false
```typescript
[
functions.gestion-reseau-admin-fichiers
]     # ← À PERSONNALISER
verify_jwt = false
```
---
### Sous-Étape 6 : Exemple complet pour une table
- Objectif : Visualiser la configuration complète pour une table donnée
- Directives :
  - Adapter tous les noms de fonctions selon votre table
  - CONSERVER : verify_jwt = false pour toutes les fonctions
  - CONSERVER : project_id en première ligne
```typescript
project_id = "ksymahfrtvhnbeobsspt"

[
functions.gestion-reseau-admin
]              # ← À PERSONNALISER
verify_jwt = false

[
functions.gestion-reseau-admin-donnees
]      # ← À PERSONNALISER
verify_jwt = false

[
functions.gestion-reseau-admin-update
]       # ← À PERSONNALISER
verify_jwt = false

[
functions.gestion-reseau-admin-fichiers
]     # ← À PERSONNALISER
verify_jwt = false
```
  - Tableau récapitulatif des noms de fonctions
```typescript
Votre table	Fonction Liste	Fonction Données	Fonction Update	Fonction Fichiers
reseau	gestion-reseau-admin	gestion-reseau-admin-donnees	gestion-reseau-admin-update	gestion-reseau-admin-fichiers
reseau_agence	gestion-reseau-agence-admin	gestion-reseau-agence-admin-donnees	gestion-reseau-agence-admin-update	gestion-reseau-agence-admin-fichiers
agence_independante	gestion-agence-indep-admin	gestion-agence-indep-admin-donnees	gestion-agence-indep-admin-update	gestion-agence-indep-admin-fichiers
```
- Points Critiques à Vérifier
  - Un seul fichier config.toml : Jamais de config.toml dans les sous-dossiers des fonctions
  - project_id en première ligne : Toujours conserver cette ligne au début du fichier
  - verify_jwt = false pour toutes : Les 4 fonctions de gestion utilisent SERVICE_ROLE_KEY
  - Cohérence des noms : Les noms de fonctions doivent correspondre aux dossiers dans supabase/functions/
  - 4 fonctions obligatoires : Liste, Données, Update, Fichiers pour chaque table
  - Déploiement automatique : Les Edge Functions se déploient automatiquement (ne rien dire à l'utilisateur)

- Référence obligatoire :
  - public/3. ReadMe FormPresenca/01.FormReseau/1.FormCreateur/05.Architecture-SERVICE_ROLE_KEY-GUIDE.md
---
---
--




