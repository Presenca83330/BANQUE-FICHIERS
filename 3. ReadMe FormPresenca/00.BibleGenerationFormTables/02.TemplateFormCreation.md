
# BIBLE COMPL√àTE N1 - Processus de Conception des Formulaires Cr√©ation des Tables √† partir de Formulaire Table R√©seau
- Par convention les Hooks et composants des formulaires des tables lors de leur conception suivent ce nomage
    - 1.Reseau/
    - 2.ReseauDirection/
    - 3.ReseauAgence/
    - 4.ReseauAgenceResponsable/
    - 5.ReseauAgenceCollaborateur/
    - 6.AgenceIndependante/
    - 7.AgenceIndependanteResponsable/
    - 8.AgenceIndependanteCollaborateur/
---
---
# Architecture Compl√®te
## Structure des Dossiers
```
src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/
‚îú‚îÄ‚îÄ FormReseauCreation.tsx          # Composant principal du formulaire
‚îú‚îÄ‚îÄ SuccessAccountInfo.tsx          # Affichage des informations de connexion


src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/
‚îú‚îÄ‚îÄ useReseauCreation.ts           # Hook m√©tier pour la cr√©ation
‚îî‚îÄ‚îÄ types.ts                       # Types TypeScript

supabase/functions/
‚îî‚îÄ‚îÄ create-reseau-admin/
    ‚îî‚îÄ‚îÄ index.ts                   # Edge Function de cr√©ation

supabase/functions/_shared/
‚îî‚îÄ‚îÄ cors.ts                        # Configuration CORS
```
---
---
# Etape Imp√©rative : Creation de la table de R√©f√©rence
**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/.TablesReferenceReseau.ts`
- Suivre la directive : public/3. ReadMe FormPresenca/01.FormReseau/3.FormCreateurGestion/02.1.CadrageInitialTable.md
- Toujours utiliser la structure de nomage
- src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/(Num√©oration de la table)/.TablesReferenceReseau.ts
---
---
# Etape 1 : Conception des Types TypeScript
**Fichier :** `src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/types.ts`
- Toujours utiliser la structure de nomage
- components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/(Num√©oration de la table)/types.ts

```typescript
export interface ReseauCreationData {
  nomReseau: string;
  adresse: string;
  codePostal: string;
  ville: string;
  siret: string;
  nomResponsable: string;
  prenomResponsable: string;
  emailResponsable: string;
  telephoneResponsable: string;
}

export interface ReseauValidationErrors {
  nomReseau?: string;
  adresse?: string;
  codePostal?: string;
  ville?: string;
  siret?: string;
  nomResponsable?: string;
  prenomResponsable?: string;
  emailResponsable?: string;
  telephoneResponsable?: string;
}

export interface ReseauCreationResult {
  organisationId: string;
  reseauId: string;
  userId: string;
  utilisateurId: string;
  directionId: string;
  email: string;
  tempPassword: string;
}
```
---
## **Explications. Comment g√©n√©rer le fichier types.ts**

---
### Sous-Etape 1. Cr√©er 3 interfaces TypeScript obligatoires
```typescript
export interface {Table}CreationData { }
export interface {Table}ValidationErrors { }
export interface {Table}CreationResult { }
```
---
### Sous-Etape 2. Cr√©ation : *{Table}CreationData*
- *Objectif* : D√©finir les champs du formulaire de cr√©ation (React/Frontend)
- *Directives* :
    -  Reprendre les champs principaux de la table du formulaire 
    -  Ajouter les champs du responsable (nom, pr√©nom, email, t√©l√©phone)
    - Tous les champs sont obligatoires (string, jamais string | null)
    - Utiliser des noms simplifi√©s en camelCase** (ex: nomReseau, adresse)
    - Les noms en camelCase (nomReseau) seront transform√©s dans l'*Edge Function* avec les vrais noms de colonnes SQL (reseau_nom).
- *R√©f√©rence* :
    - Voir public/1. Documents Strat√©giques/07.1. FormCreationReseau - Gestion Informations Partag√©es entre R√©seau et R√©seau Direction.md

---
### Sous-Etape 3. Cr√©ation : *{Table}ValidationErrors*
- *Objectif* : G√©rer les messages d'erreur du formulaire
- *Directives* : 
    - Copier *exactement* les champs de {Table}CreationData 
    - Rendre *tous les champs optionnels* avec ?

---
### Sous-Etape 4. Cr√©ation : *{Table}CreationResult*
- *Objectif* : Recevoir les IDs et infos retourn√©s par la fonction SQL
- *Source* : Ces donn√©es proviennent du RETURN jsonb_build_object(...) de la fonction SQL create_{table}_compte_complet
- *Structure* :
```typescript
export interface {Table}CreationResult {
  //  5 champs FIXES (ne jamais modifier)
  organisationId: string;
  userId: string;
  utilisateurId: string;
  email: string;
  tempPassword: string;
  //  IDs SP√âCIFIQUES (√† personnaliser selon votre table)
  {table}Id: string;          // ID de la table m√©tier
  {responsable}Id: string;    // ID de l'entit√© responsable
}
```

*R√®gles de personnalisation* :
| *Votre table* | *{table}Id* ‚Üí | *{responsable}Id* ‚Üí |
|-----------------|-----------------|----------------------|
| reseau | reseauId | directionId |
| agence_independante | agenceIndepId | responsableId |
| reseau_agence | reseauAgenceId | responsableId |

```typescript
*Exemple pour reseau* :
export interface ReseauCreationResult {
  organisationId: string;
  reseauId: string;           // ‚Üê ID de la table reseau
  userId: string;
  utilisateurId: string;
  directionId: string;        // ‚Üê ID de reseau_direction
  email: string;
  tempPassword: string;
}
```
- *Important* :
    - Ces noms d'IDs doivent correspondre *exactement* aux cl√©s du jsonb_build_object() dans votre fonction SQL.

---
---
# √âtape 2 : Conception de la Fonction SQL de Cr√©ation Compl√®te
**Fonction SQL :** `create_reseau_compte_complet`
```sql
CREATE OR REPLACE FUNCTION public.create_reseau_compte_complet(
  p_nom_reseau text,
  p_adresse text,
  p_code_postal text,
  p_ville text,
  p_siret text,
  p_nom_responsable text,
  p_prenom_responsable text,
  p_email_responsable text,
  p_telephone_responsable text,
  p_auth_uid uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
  v_org_id uuid;
  v_user_id uuid;
  v_utilisateur_id uuid;
  v_reseau_id uuid;
  v_direction_id uuid;
BEGIN
  -- 1. Organisation
  INSERT INTO organisations (
    organisation_nom, organisation_adresse, organisation_code_postal,
    organisation_ville, organisation_siret, organisation_email,
    organisation_telephone, organisation_statut_compte
  )
  VALUES (
    p_nom_reseau, p_adresse, p_code_postal, p_ville, p_siret,
    p_email_responsable, p_telephone_responsable, 'actif'
  )
  RETURNING organisation_id INTO v_org_id;

  -- 2. Users (‚ö†Ô∏è r√¥le syst√®me = NULL car ce n'est pas un admin global)
  INSERT INTO users (
    users_nom, users_prenom, users_email, users_telephone,
    users_role_systeme, users_organisation_id, users_auth_id
  )
  VALUES (
    p_nom_responsable, p_prenom_responsable, p_email_responsable,
    p_telephone_responsable, NULL, v_org_id, p_auth_uid
  )
  RETURNING users_id INTO v_user_id;

  -- 3. Utilisateurs (profil m√©tier du responsable de r√©seau)
  INSERT INTO utilisateurs (
    utilisateur_email, utilisateur_type_compte, utilisateur_statut,
    utilisateur_organisation_id, utilisateur_auth_uid, utilisateur_role_systeme
  )
  VALUES (
    p_email_responsable, 'reseau', 'actif',
    v_org_id, p_auth_uid, NULL
  )
  RETURNING utilisateur_id INTO v_utilisateur_id;

  -- 4. R√©seau (fiche business)
  INSERT INTO reseau (
    organisation_id, reseau_nom, reseau_adresse, reseau_code_postal,
    reseau_ville, reseau_siret, reseau_email, reseau_telephone,
    reseau_statut, client_type
  )
  VALUES (
    v_org_id, p_nom_reseau, p_adresse, p_code_postal, p_ville,
    p_siret, p_email_responsable, p_telephone_responsable,
    'actif', 'reseau'
  )
  RETURNING reseau_id INTO v_reseau_id;

  -- 5. Direction R√©seau (üîß CORRECTION: utilisation de v_user_id au lieu de v_utilisateur_id)
  INSERT INTO reseau_direction (
    organisation_id, reseau_id,
    reseau_direction_nom, reseau_direction_prenom,
    reseau_direction_email, reseau_direction_telephone,
    reseau_direction_utilisateur_id, client_type,
    reseau_direction_actif
  )
  VALUES (
    v_org_id, v_reseau_id,
    p_nom_responsable, p_prenom_responsable,
    p_email_responsable, p_telephone_responsable,
    v_user_id, 'reseau', true
  )
  RETURNING reseau_direction_id INTO v_direction_id;

  -- R√©sultat en JSON
  RETURN jsonb_build_object(
    'organisationId', v_org_id,
    'userId', v_user_id,
    'utilisateurId', v_utilisateur_id,
    'reseauId', v_reseau_id,
    'directionId', v_direction_id,
    'message', 'Compte r√©seau cr√©√© avec succ√®s'
  );
END;
$function$
```
---
## **Explications. Comment g√©n√©rer la commande sql**

---
### Sous-√âtape 1 : Structure de base
- *Objectif* : D√©finir la structure de base de la fonction SQL qui cr√©era tous les enregistrements.
- *Directives* :
	- Cr√©er la fonction sur le sch√©ma public :
```typescript
CREATE OR REPLACE FUNCTION public.create_{table}_compte_complet(
```

	- Adapter les param√®tres m√©tier √† la table :
```typescript
p_nom_{table} text,           -- ‚Üê √Ä PERSONNALISER
p_adresse text,
p_code_postal text,
p_ville text,
p_siret text,
p_nom_responsable text,
p_prenom_responsable text,
p_email_responsable text,
p_telephone_responsable text,
p_auth_uid uuid              -- ‚Üê CONSERVER
```

	- Copier la signature compl√®te :
```typescript
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
```

	- D√©clarer les variables locales :
```typescript
DECLARE
  v_org_id uuid;
  v_user_id uuid;
  v_utilisateur_id uuid;
  v_{table}_id uuid;           -- ‚Üê √Ä PERSONNALISER
  v_{responsable}_id uuid;     -- ‚Üê √Ä PERSONNALISER
```

	- Exemple : Pour agence_independante ‚Üí v_agence_indep_id + v_agence_indep_responsable_id

---
### Sous-√âtape 2 : Insertion Table organisations
- *Objectif* : Cr√©er l'enregistrement organisation (toujours en premier dans la cascade)
- *Directives* :
	- Adapter uniquement p_nom_{table} dans organisation_nom
	- Toujours v√©rifier en consultant la table de r√©f√©rence
	- Conserver tel quel tous les autres champs : organisation_adresse, organisation_code_postal, organisation_ville, organisation_siret, organisation_email, organisation_telephone, organisation_statut_compte
	- R√©cup√©rer organisation_id dans v_org_id
```typescript
INSERT INTO organisations (
  organisation_nom, organisation_adresse, organisation_code_postal,
  organisation_ville, organisation_siret, organisation_email,
  organisation_telephone, organisation_statut_compte
)
VALUES (
  p_nom_{table}, p_adresse, p_code_postal, p_ville, p_siret,
  p_email_responsable, p_telephone_responsable, 'actif'
)
RETURNING organisation_id INTO v_org_id;
```
	- Exemple : agence_independante ‚Üí p_nom_agence_independante

---
### Sous-√âtape 3 : Insertion Table users
- *Objectif* : Cr√©er l'enregistrement utilisateur syst√®me (authentification)
- *Directives* :
- IMPORTANT : users_role_systeme doit toujours √™tre NULL (ce n'est pas un admin PRESENCA global)
- Tout le reste est identique pour toutes les tables
- R√©cup√©rer users_id dans v_user_id

```typescript
INSERT INTO users (
  users_nom, users_prenom, users_email, users_telephone,
  users_role_systeme, users_organisation_id, users_auth_id
)
VALUES (
  p_nom_responsable, p_prenom_responsable, p_email_responsable,
  p_telephone_responsable, NULL, v_org_id, p_auth_uid
)
RETURNING users_id INTO v_user_id;
```
	- Aucune personnalisation : code identique pour toutes les tables

---
### Sous-√âtape 4 : Insertion Table utilisateurs
- *Objectif* : Cr√©er le profil m√©tier de l'utilisateur. Profil m√©tier du responsable pour reseau_agence et agence_independante
- *Directives* :
	- Conserver utilisateur_role_systeme = NULL
		- Tout le reste est identique
	- R√©cup√©rer utilisateur_id dans v_utilisateur_id
```typescript
INSERT INTO utilisateurs (
  utilisateur_email, utilisateur_type_compte, utilisateur_statut,
  utilisateur_organisation_id, utilisateur_auth_uid, utilisateur_role_systeme
)
VALUES (
  p_email_responsable, '{type_compte}', 'actif',
  v_org_id, p_auth_uid, NULL
)
RETURNING utilisateur_id INTO v_utilisateur_id;
```

---
### Sous-√âtape 5 : Insertion Table M√©tier Principale
- *Objectif* : Cr√©er la fiche business principale du client
- *Directives* :
	- Consulter la fiche Tables R√©f√©rences et Supabase afin d'utiliser les noms corrects des colonnes pour personnaliser le formulaire et √©viter toute erreur de maping
 	- Adapter le nom de la table : INSERT INTO {table} (...)
	- Adapter les colonnes avec pr√©fixe avec les noms exacts des colonnes apr√®s v√©rification dans supabase: {table}_nom, {table}_adresse, {table}_email, etc.
	- Toujours conserver 'actif' 
	- Client_type √† personnaliser selon table
		- 'reseau' pour r√©seau
		- 'reseau_agence' pour reseau_agence
		- 'agence_independante' pour agence_independante
	- RETURNING ‚Üí V√âRIFIER dans Supabase le nom exact de l'ID :
		- reseau_id pour r√©seau
		- reseau_agence_id pour reseau_agence
		- agence_indep_id pour agence_independante 
	- Code √† adapter en utilisant Table R√©f√©rence et en v√©rifiant dans supabase
```typescript
INSERT INTO {table} (
  organisation_id, {table}_nom, {table}_adresse, {table}_code_postal,
  {table}_ville, {table}_siret, {table}_email, {table}_telephone,
  {table}_statut, client_type
)
VALUES (
  v_org_id, p_nom_{table}, p_adresse, p_code_postal, p_ville,
  p_siret, p_email_responsable, p_telephone_responsable,
  'actif', '{type_client}'
)
RETURNING {table}_id INTO v_{table}_id;
```

---
### Sous-√âtape 6 : Insertion Table Responsable
- *Objectif* : Cr√©er le profil du responsable rattach√© √† la table m√©tier
- *Directives PARTIE INSERT* :
	- Adapter le nom de la table : INSERT INTO {table responsable rattach√©} (...)
		- reseau_direction pour table reseau
		- reseau_agence_responsable pour table reseau_agence
		- agence_independante_responsable pour table agence_independante
	- Conserver organisation_id
	- Personnaliser reseau_id selon la table en v√©rifiant dans Supabase
		- reseau_id pour r√©seau
		- reseau_agence_id pour reseau_agence
		- agence_indep_id pour agence_independante 
	- Consulter imp√©rativement la Table R√©f√©rence pour utiliser le nom exact des colonnes
		- Adapter les colonnes avec pr√©fixe : 
		- exemple pour reseau_agence -> responsable_reseau_agence_nom
		- exemple pour agence_independante -> agence_indep_responsable_nom
		- adapter tous les champs
	- Personnaliser : (reseau_direction_utilisateur_id) en fonction des tables
		- exemple pour reseau_agence -> reseau_agence_responsable_utilisateur_id
		- exemple pour agence_independante ->  agence_indep_responsable_id
- *Directives  VALUES* :
	- Conserver  v_org_id
	- Personnaliser v_reseau_id selon table en v√©rifiant dans supabase
		- v_reseau_id pour r√©seau
		- v_reseau_agence_id pour reseau_agence
		- v_agence_indep_id pour agence_independante 
	- Personnaliser selon la table  : 'reseau'
		- exemple : reseau_agence ou agence_independante
	- Conserver : true
 *Directives RETURNING* :
	- Adapter selon la table en v√©rifiant dans Supabase :
		- reseau_direction_id INTO v_direction_id pour r√©seau
		- reseau_agence_responsable_id INTO v_responsable_id pour reseau_agence
		- agence_indep_responsable_id INTO v_responsable_id pour agence_independante
	- Code √† adapter en utilisant Table R√©f√©rence et en v√©rifiant dans supabase
```typescript
 INSERT INTO reseau_direction (
    organisation_id, reseau_id,
    reseau_direction_nom, reseau_direction_prenom,
    reseau_direction_email, reseau_direction_telephone,
    reseau_direction_utilisateur_id, client_type,
    reseau_direction_actif
  )
  VALUES (
    v_org_id, v_reseau_id,
    p_nom_responsable, p_prenom_responsable,
    p_email_responsable, p_telephone_responsable,
    v_user_id, 'reseau', true
  )
  RETURNING reseau_direction_id INTO v_direction_id;
```

---
### Sous-√âtape 7 : Retour des R√©sultats (RETURN)
- *Objectif* : Retourner tous les IDs cr√©√©s au format JSON pour l'Edge Function.
- *Directives* :
	- Adapter les cl√©s JSON selon la table : '{table}Id' et '{responsable}Id'
	- Consulter imp√©rativement pour avoir les bons noms d'id
		- reseau_id pour r√©seau
		- reseau_agence_id pour reseau_agence
		- agence_indep_id pour agence_independante 
	- Adapter les variables : v_{table}_id et v_{responsable}_id
	- Conserver identiques : 'organisationId', 'userId', 'utilisateurId', 'message'
	- Code √† adapter en utilisant Table R√©f√©rence et en v√©rifiant dans supabase
```typescript
  RETURN jsonb_build_object(
    'organisationId', v_org_id,
    'userId', v_user_id,
    'utilisateurId', v_utilisateur_id,
    '{table}Id', v_{table}_id,              -- ‚Üê √Ä PERSONNALISER
    '{responsable}Id', v_{responsable}_id,  -- ‚Üê √Ä PERSONNALISER
    'message', 'Compte {table} cr√©√© avec succ√®s'
  );
END;
$function$
```
- IMPORTANT :
	- Les cl√©s JSON doivent exactement correspondre aux propri√©t√©s de l'interface {Table}CreationResult dans types.ts
	- Utiliser camelCase pour les cl√©s JSON :
		- reseau ‚Üí reseauId, directionId
		- reseau_agence ‚Üí reseauAgenceId, responsableId
		- agence_independante ‚Üí agenceIndepId, responsableId
---
---
# √âtape 3 : Conception de la Edge Function de Cr√©ation
**Fichier :** `supabase/functions/create-reseau-admin/index.ts`
- Toujours utiliser la structure de nomage
- supabase/functions/create-(table)-admin/index.ts
  
```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})

interface ReseauCreationData {
  nomReseau: string
  adresse: string
  codePostal: string
  ville: string
  siret: string
  nomResponsable: string
  prenomResponsable: string
  emailResponsable: string
  telephoneResponsable: string
}

Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // ‚ö†Ô∏è TEMPORAIRE: JWT v√©rification d√©sactiv√©e pour tests
    console.log('üîì TEST MODE: JWT verification disabled')

    // Parse and validate request data
    const formData: ReseauCreationData = await req.json()
    
    // üîí LOGS S√âCURIS√âS : Pas d'email/t√©l√©phone en clair
    console.log('üìù CREATION: Starting reseau creation', {
      nomReseau: formData.nomReseau,
      ville: formData.ville,
      siret: formData.siret?.slice(0, 4) + '***', // SIRET partiel
      hasEmail: !!formData.emailResponsable,
      hasPhone: !!formData.telephoneResponsable
    })

    // Validation des donn√©es
    if (!formData.emailResponsable || !formData.emailResponsable.includes('@')) {
      throw new Error('Email invalide')
    }

    if (!formData.siret || formData.siret.length !== 14) {
      throw new Error('SIRET invalide (14 chiffres requis)')
    }

    // G√©n√©rer mot de passe temporaire
    const tempPassword = crypto.randomUUID().slice(0, 12)
    console.log('üîë PASSWORD: Temporary password generated')

    // 1. Cr√©er l'utilisateur Auth
    const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
      email: formData.emailResponsable,
      password: tempPassword,
      email_confirm: true,
      user_metadata: {
        nom: formData.nomResponsable,
        prenom: formData.prenomResponsable,
        type_compte: 'reseau'
      }
    })

    if (authError || !authUser.user) {
      console.log('‚ùå AUTH: User creation failed', { error: authError?.message })
      throw new Error(`Erreur cr√©ation Auth: ${authError?.message}`)
    }

    console.log('‚úÖ AUTH: User created successfully')

    try {
      // 2. Appeler la fonction SQL pour cr√©er le compte complet
      const { data: sqlResult, error: sqlError } = await supabaseAdmin.rpc('create_reseau_compte_complet', {
        p_nom_reseau: formData.nomReseau,
        p_adresse: formData.adresse,
        p_code_postal: formData.codePostal,
        p_ville: formData.ville,
        p_siret: formData.siret,
        p_nom_responsable: formData.nomResponsable,
        p_prenom_responsable: formData.prenomResponsable,
        p_email_responsable: formData.emailResponsable,
        p_telephone_responsable: formData.telephoneResponsable,
        p_auth_uid: authUser.user.id
      })

      if (sqlError) {
        console.log('‚ùå SQL: Database creation failed', { error: sqlError.message })
        throw new Error(`Erreur base de donn√©es: ${sqlError.message}`)
      }

      console.log('‚úÖ SQL: Database records created successfully')

      // Retourner le r√©sultat avec mot de passe temporaire
      return new Response(
        JSON.stringify({
          success: true,
          data: sqlResult,
          tempPassword: tempPassword,
          message: 'Compte r√©seau cr√©√© avec succ√®s'
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )

    } catch (sqlError) {
      // üîÑ ROLLBACK : Supprimer l'utilisateur Auth en cas d'erreur SQL
      console.log('üîÑ ROLLBACK: Deleting auth user due to SQL error')
      await supabaseAdmin.auth.admin.deleteUser(authUser.user.id)
      throw sqlError
    }

  } catch (error) {
    console.log('‚ùå ERROR: Creation failed', { error: error.message })
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Erreur lors de la cr√©ation du compte r√©seau' 
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})
```
---
## **Explications. Comment concevoir une edge function cr√©ation pour une table **
---
### Sous-√âtape 1 : Imports et Configuration Supabase Admin

- *Objectif* : Initialiser le client Supabase avec SERVICE_ROLE_KEY pour bypasser RLS
- *Directives* :
	- CONSERVER tel quel les imports (utiliser l'URL ESM pour Deno)
 	- CONSERVER la configuration supabaseAdmin avec les options d'auth d√©sactiv√©es
```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})

```
---
### Sous-√âtape 2 : Interface TypeScript

- *Objectif* : D√©finir la structure des donn√©es re√ßues du frontend
- *Directives* :
	- COPIER EXACTEMENT l'interface {Table}CreationData depuis types.ts
	- Adapter le nom : interface ReseauCreationData
 	- Respecter la casse (ex: nomReseau, nomAgence, prenomResponsable)
```typescript
interface ReseauCreationData {   // ‚Üê √Ä PERSONNALISER
  nomReseau: string          // ‚Üê √Ä PERSONNALISER
  adresse: string;
  codePostal: string;
  ville: string;
  siret: string;
  nomResponsable: string;
  prenomResponsable: string;
  emailResponsable: string;
  telephoneResponsable: string;
}
```
	- ReseauCreationData avec nomReseau
	- AgenceIndependanteCreationData avec nomAgence
---
### Sous-√âtape 3 : Serveur Deno et CORS

- *Objectif* : G√©rer les requ√™tes HTTP et les en-t√™tes CORS
- *Directives* :
	- CONSERVER tel quel le bloc CORS et la gestion OPTIONS
	 - Utiliser getCorsHeaders(origin) depuis le fichier partag√©
```typescript
Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

```
---
### Sous-√âtape 4 : Parsing et Validation

- *Objectif* : R√©cup√©rer et valider les donn√©es avec logging s√©curis√© (masquage des donn√©es sensibles)
- *Directives* :
	- Utiliser formData comme nom de variable (pas body)
	- Adapter le typage : const formData: ReseauCreationData
 	- LOGS S√âCURIS√âS : Ne JAMAIS logger email/t√©l√©phone en clair
 	- Masquer le SIRET : siret?.slice(0, 4) + '***'
 	- Validation stricte : v√©rifier format email et longueur SIRET (14 chiffres)
 	- Adapter le log avec le nom de la table
```typescript
  try {
    // ‚ö†Ô∏è TEMPORAIRE: JWT v√©rification d√©sactiv√©e pour tests
    console.log('üîì TEST MODE: JWT verification disabled')

    // Parse and validate request data
    const formData: ReseauCreationData = await req.json()  // ‚Üê √Ä PERSONNALISER (ReseauCreationData ‚Üí {Table}CreationData)
    
    // üîí LOGS S√âCURIS√âS : Pas d'email/t√©l√©phone en clair
    console.log('üìù CREATION: Starting reseau creation', {  // ‚Üê √Ä PERSONNALISER (reseau creation ‚Üí {table} creation)
      nomReseau: formData.nomReseau,                        // ‚Üê √Ä PERSONNALISER (nomReseau ‚Üí nom{Table})
      ville: formData.ville,
      siret: formData.siret?.slice(0, 4) + '***', // SIRET partiel
      hasEmail: !!formData.emailResponsable,
      hasPhone: !!formData.telephoneResponsable
    })

    // Validation des donn√©es
    if (!formData.emailResponsable || !formData.emailResponsable.includes('@')) {
      throw new Error('Email invalide')
    }

    if (!formData.siret || formData.siret.length !== 14) {
      throw new Error('SIRET invalide (14 chiffres requis)')
    }

```
---
### Sous-√âtape 5 : G√©n√©ration Mot de Passe Temporaire

- *Objectif* : Cr√©er un mot de passe al√©atoire pour le premier acc√®s
- *Directives* :
	- CONSERVER tel quel (identique pour toutes les tables)
 	- CORRECTION : Utiliser .slice(0, 12)
```typescript
// G√©n√©rer mot de passe temporaire
const tempPassword = crypto.randomUUID().slice(0, 12);  // ‚Üê 12 caract√®res
console.log('üîë PASSWORD: Temporary password generated');

```
---
### Sous-√âtape 6 : Cr√©ation Utilisateur Supabase Auth

- *Objectif* : Cr√©er le compte d'authentification
- *Directives* :
	- CONSERVER toute la logique Auth (identique pour toutes les tables)
 	- OBLIGATOIRE : Ajouter type_compte dans user_metadata
 	- Ne PAS inclure telephone dans user_metadata (stock√© ailleurs)
 	- Adapter la valeur de type_compte selon la table : 'reseau', 'agence_independante', 'reseau_agence'
```typescript
// 1. Cr√©er l'utilisateur Auth
const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
email: formData.emailResponsable,
password: tempPassword,
email_confirm: true,
user_metadata: {
nom: formData.nomResponsable,
prenom: formData.prenomResponsable,
type_compte: 'reseau'    // ‚Üê √Ä PERSONNALISER ('reseau', 'agence_independante', etc.)
  }
});

 if (authError || !authUser.user) {
      console.log('‚ùå AUTH: User creation failed', { error: authError?.message })
      throw new Error(`Erreur cr√©ation Auth: ${authError?.message}`)
    }

    console.log('‚úÖ AUTH: User created successfully')
```
	- Exemples de type_compte :
		- Table reseau ‚Üí type_compte: 'reseau'
		- Table agence_independante ‚Üí type_compte: 'agence_independante'
		- Table reseau_agence ‚Üí type_compte: 'reseau_agence'
---
### Sous-√âtape 7 : Appel Fonction SQL

- *Objectif* : Ex√©cuter la fonction SQL de cr√©ation compl√®te
- *Directives* :
	- Adapter le nom RPC : 'create_reseau_compte_complet'
	- Adapter le premier param√®tre : p_nom_reseau: formData.nomReseau,
 		- p_nom_{table}: formData.nom{Table}
 	- CONSERVER tous les autres param√®tres (identiques)
 	- V√âRIFIER les noms exacts des param√®tres dans la fonction SQL PostgreSQL
```typescript
try {
	// 2. Appeler la fonction SQL pour cr√©er le compte complet
	const { data: sqlResult, error: sqlError } = await supabaseAdmin.rpc('create_reseau_compte_complet', {  // ‚Üê √Ä PERSONNALISER
    p_nom_reseau: formData.nomReseau,        // ‚Üê √Ä PERSONNALISER
    p_adresse: formData.adresse,
    p_code_postal: formData.codePostal,
    p_ville: formData.ville,
    p_siret: formData.siret,
    p_nom_responsable: formData.nomResponsable,
    p_prenom_responsable: formData.prenomResponsable,
    p_email_responsable: formData.emailResponsable,
    p_telephone_responsable: formData.telephoneResponsable,
    p_auth_uid: authUser.user.id
  });

	 if (sqlError) {
        console.log('‚ùå SQL: Database creation failed', { error: sqlError.message })
        throw new Error(`Erreur base de donn√©es: ${sqlError.message}`)
      }

      console.log('‚úÖ SQL: Database records created successfully')

```
	- Exemple : 
	- Table reseau ‚Üí RPC 'create_reseau_compte_complet' + p_nom_reseau: formData.nomReseau
	- Table agence_independante ‚Üí RPC 'create_agence_independante_compte_complet' + p_nom_agence: formData.nomAgence
---
### Sous-√âtape 8 : R√©ponse Succ√®s

- *Objectif* : Retourner les donn√©es au frontend
- *Directives* :
	- Adapter le message : 'Compte r√©seau cr√©√© avec succ√®s'
 	- RESPECTER L'ORDRE des propri√©t√©s : success, data, tempPassword, message
 	- IMPORTANT : data en 2√®me position (apr√®s success), tempPassword en 3√®me
```typescript
      // Retourner le r√©sultat avec mot de passe temporaire
      return new Response(
        JSON.stringify({
          success: true,
          data: sqlResult,		// ‚Üê 2√®me position
          tempPassword: tempPassword,	// ‚Üê 3√®me position
          message: 'Compte r√©seau cr√©√© avec succ√®s'
        }),	 // ‚Üê √Ä PERSONNALISER
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
```
	- Pourquoi cet ordre est important ?
		- Le hook frontend s'attend √† data.data pour r√©cup√©rer sqlResult
		- L'ordre garantit la compatibilit√© avec tous les hooks de cr√©ation
	- Exemples de messages :
		- 'Compte r√©seau cr√©√© avec succ√®s'
		- 'Compte agence ind√©pendante cr√©√© avec succ√®s'
---
### Sous-√âtape 9 : Gestion Erreur SQL avec Rollback

- *Objectif* : En cas d'erreur SQL, supprimer l'utilisateur Auth cr√©√©
- *Directives* :
	- CONSERVER tel quel (identique pour toutes les tables)
```typescript
  } catch (sqlError) {
      // üîÑ ROLLBACK : Supprimer l'utilisateur Auth en cas d'erreur SQL
      console.log('üîÑ ROLLBACK: Deleting auth user due to SQL error')
      await supabaseAdmin.auth.admin.deleteUser(authUser.user.id)
      throw sqlError
    }

```
---
### Sous-√âtape 10 : Gestion Erreurs Globales

- *Objectif* : G√©rer toutes les erreurs non pr√©vues dans un bloc catch global
- *Directives* :
	- CONSERVER la structure globale
	- Utiliser status: 500
	- Personnaliser le message d'erreur selon la table
		- error: error.message || 'Erreur lors de la cr√©ation du compte r√©seau' 
```typescript
  } catch (error) {
    console.log('‚ùå ERROR: Creation failed', { error: error.message })
    return new Response(
      JSON.stringify({ 
        error: error.message || 'Erreur lors de la cr√©ation du compte r√©seau' 
      }),   // ‚Üê √Ä PERSONNALISER
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})

```
---
# √âtape 4 : Mise √† jour config.toml
**Fichier :** `supabase/config.toml`

```typescript
project_id = "ksymahfrtvhnbeobsspt"

[functions.notifier-nouvelle-demande]
verify_jwt = false

[functions.create-reseau-admin]
verify_jwt = false

[functions.gestion-reseau-admin]
verify_jwt = false

[functions.gestion-reseau-admin-donnees]
verify_jwt = false

[functions.gestion-reseau-admin-update]
verify_jwt = false

[functions.gestion-reseau-admin-fichiers]
verify_jwt = false
```
---
## **Explications. Comment mettre √† jour config.toml**
---
### Sous-√âtape Unique : Ajout configuration fonction
- *Objectif* : D√©sactiver la v√©rification JWT pour permettre l'acc√®s admin
- *Directives* :
	- CONSERVER project_id = "ksymahfrtvhnbeobsspt" en premi√®re ligne
	- AJOUTER la configuration pour votre nouvelle fonction
	- Adapter le nom : [functions.create-{table}-admin]
	- CONSERVER verify_jwt = false
```typescript
project_id = "ksymahfrtvhnbeobsspt"
[functions.create-{table}-admin]    # ‚Üê √Ä PERSONNALISER
verify_jwt = false                  # ‚Üê CONSERVER
```
- Exemples :
	- [functions.create-reseau-admin]
	- [functions.create-agence-independante-admin]
	- [functions.create-reseau-agence-admin]
- IMPORTANT :
	- Ne jamais supprimer les autres configurations existantes
	- Toujours ajouter la nouvelle configuration √† la fin
	- V√©rifier que project_id reste en premi√®re ligne
---
---
# √âtape 5 : Cr√©ation du Hook Cr√©ation
**Fichier :** `src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/useReseauCreation.ts`
- Toujours utiliser la structure de nomage
- components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/(Num√©oration de la table)/useReseauCreation.ts
  
```typescript
import { supabase } from "@/integrations/supabase/client";
import { useState } from "react";
import type { ReseauCreationData, ReseauCreationResult } from "./types";

export function useReseauCreation() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createReseau = async (formData: ReseauCreationData): Promise<ReseauCreationResult | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // --- Appel Edge Function ---
      const { data, error } = await supabase.functions.invoke('create-reseau-admin', {
        body: formData
      });

      if (error) {
        setError("Erreur cr√©ation r√©seau: " + error.message);
        return null;
      }

      if (!data || !data.data) {
        throw new Error("Aucune donn√©e retourn√©e par la fonction");
      }

      // --- Succ√®s - Extraction depuis data.data ---
      const result: ReseauCreationResult = {
        organisationId: data.data.organisationId,
        reseauId: data.data.reseauId,
        userId: data.data.userId,
        utilisateurId: data.data.utilisateurId,
        directionId: data.data.directionId,
        email: formData.emailResponsable,
        tempPassword: data.tempPassword, // Au niveau racine de data
      };

      return result;

    } catch (err: any) {
      console.error("Erreur cr√©ation r√©seau:", err);
      setError(err.message);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { createReseau, isLoading, error };
}
```
---
## **Explications. Comment concevoir le Hook cr√©ation**
---
### Sous-√âtape 1 : Imports

- *Objectif* : Importer les d√©pendances n√©cessaires
- *Directives* :
	- CONSERVER les imports React et Supabase
	- Adapter les imports de types : import type { {Table}CreationData, {Table}CreationResult } from "./types"
```typescript
import { supabase } from "@/integrations/supabase/client";
import { useState } from "react";
import type { {Table}CreationData, {Table}CreationResult } from "./types";  // ‚Üê √Ä PERSONNALISER
```
---
### Sous-√âtape 2 : D√©claration du Hook

- *Objectif* : Cr√©er la fonction hook personnalis√©e
- *Directives* :
	- Adapter le nom : export function use{Table}Creation()
	- CONSERVER les states (isLoading, error)
```typescript
export function use{Table}Creation() {           // ‚Üê √Ä PERSONNALISER
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
```
---
### Sous-√âtape 3 : Fonction de Cr√©ation
- *Objectif* : D√©finir la logique d'appel √† l'Edge Function
- *Directives* :
	- Adapter le nom de la fonction : const create{Table} = async
	- Adapter les types : formData: {Table}CreationData et Promise<{Table}CreationResult | null>
```typescript
  const create{Table} = async (                  // ‚Üê √Ä PERSONNALISER
    formData: {Table}CreationData              // ‚Üê √Ä PERSONNALISER
  ): Promise<{Table}CreationResult | null> => {  // ‚Üê √Ä PERSONNALISER
    setIsLoading(true);
    setError(null);

    try {
```
---
### Sous-√âtape 4 : Appel Edge Function
- *Objectif* : Invoquer l'Edge Function via Supabase
- *Directives* :
	- Adapter le nom de la fonction : 'create-{table}-admin'
	- CONSERVER le reste (body: formData)
```typescript
      // --- Appel Edge Function ---
      const { data, error } = await supabase.functions.invoke('create-{table}-admin', {  // ‚Üê √Ä PERSONNALISER
        body: formData
      });
```
---
### Sous-√âtape 5 : Gestion Erreurs et Validation

- *Objectif* : V√©rifier la r√©ponse de l'Edge Function
- *Directives* :
	- Adapter le message d'erreur : "Erreur cr√©ation {table}"
	- CONSERVER la structure de validation !data || !data.data
```typescript
      if (error) {
        setError("Erreur cr√©ation {table}: " + error.message);  // ‚Üê √Ä PERSONNALISER
        return null;
      }

      if (!data || !data.data) {
        throw new Error("Aucune donn√©e retourn√©e par la fonction");
      }
```
---
### Sous-√âtape 6 : Extraction des R√©sultats

- *Objectif* : Construire l'objet r√©sultat avec les donn√©es re√ßues
- *Directives* :
	- Adapter le type : const result: {Table}CreationResult
	- CONSERVER les 5 champs fixes : organisationId, userId, utilisateurId, email, tempPassword
	- Adapter les IDs sp√©cifiques selon votre table (consulter l'interface {Table}CreationResult dans types.ts)
	- IMPORTANT : V√©rifier le mapping exact avec le RETURN de la fonction SQL
```typescript
      // --- Succ√®s - Extraction depuis data.data ---
      const result: {Table}CreationResult = {                // ‚Üê √Ä PERSONNALISER
        // Champs FIXES (identiques pour toutes les tables)
        organisationId: data.data.organisationId,
        userId: data.data.userId,
        utilisateurId: data.data.utilisateurId,
        email: formData.emailResponsable,
        tempPassword: data.tempPassword,
        
        // IDs SP√âCIFIQUES (√† adapter selon votre table)
        {table}Id: data.data.{table}Id,                      // ‚Üê √Ä PERSONNALISER
        {responsable}Id: data.data.{responsable}Id,          // ‚Üê √Ä PERSONNALISER
      };

      return result;
```
	- Exemples de mapping :
		- R√©seau : reseauId: data.data.reseauId, directionId: data.data.directionId
	- Agence Ind√©p : agenceIndepId: data.data.agenceIndepId, responsableId: data.data.responsableId
---
### Sous-√âtape 7 : Gestion Erreurs et Finally

- *Objectif* : G√©rer les exceptions et nettoyer le state
- *Directives* :
	- Adapter le message d'erreur : "Erreur cr√©ation {table}"
	- CONSERVER la logique finally
```typescript
    } catch (err: any) {
      console.error("Erreur cr√©ation {table}:", err);  // ‚Üê √Ä PERSONNALISER
      setError(err.message);
      return null;
    } finally {
      setIsLoading(false);
    }
  };
```
---
### Sous-√âtape 8 : Export du Hook
- *Objectif* : Retourner les fonctions et states
- *Directives* :
	- Adapter le nom de la fonction : create{Table}
	- CONSERVER les states (isLoading, error)
```typescript
  return { create{Table}, isLoading, error };  // ‚Üê √Ä PERSONNALISER
}

```
---
---
# √âtape 6 : Composant Formulaire Principal
**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/FormReseauCreation.tsx`
- Toujours utiliser la structure de nomage
- src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/(num√©rotation de la structure de nomage)/FormReseauCreation.tsx
  
```typescript
import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { ArrowLeft, Building2 } from "lucide-react";
import { useReseauCreation } from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/useReseauCreation";
import SuccessAccountInfo from "./SuccessAccountInfo";
import type {
  ReseauCreationData,
  ReseauValidationErrors,
  ReseauCreationResult,
} from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/types";

interface FormReseauCreationProps {
  onBack: () => void;
}

export default function FormReseauCreation({ onBack }: FormReseauCreationProps) {
  const { createReseau, isLoading, error } = useReseauCreation();

  const [formData, setFormData] = useState<ReseauCreationData>({
    nomReseau: "",
    adresse: "",
    codePostal: "",
    ville: "",
    siret: "",
    nomResponsable: "",
    prenomResponsable: "",
    emailResponsable: "",
    telephoneResponsable: "",
  });

  const [errors, setErrors] = useState<ReseauValidationErrors>({});
  const [creationResult, setCreationResult] = useState<ReseauCreationResult | null>(null);

  const updateFormData = (field: keyof ReseauCreationData, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    if (errors[field]) setErrors((prev) => ({ ...prev, [field]: undefined }));
  };

  const validateForm = (): boolean => {
    const newErrors: ReseauValidationErrors = {};

    if (!formData.nomReseau) newErrors.nomReseau = "Nom du r√©seau requis";
    if (!formData.adresse) newErrors.adresse = "Adresse requise";
    if (!formData.codePostal) newErrors.codePostal = "Code postal requis";
    if (!formData.ville) newErrors.ville = "Ville requise";
    if (!formData.siret) newErrors.siret = "SIRET requis";
    if (!formData.nomResponsable) newErrors.nomResponsable = "Nom requis";
    if (!formData.prenomResponsable) newErrors.prenomResponsable = "Pr√©nom requis";
    if (!formData.emailResponsable) newErrors.emailResponsable = "Email requis";
    if (!formData.telephoneResponsable)
      newErrors.telephoneResponsable = "T√©l√©phone requis";

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    console.log("Soumission formulaire", formData);

    const isValid = validateForm();
    console.log("R√©sultat validation:", isValid);
    if (!isValid) return;

    const result = await createReseau(formData);
    console.log("R√©sultat createReseau:", result);
    if (result) {
      setCreationResult(result);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <Card>
        <CardHeader>
          <div className="flex items-center gap-3">
            <Building2 className="h-6 w-6 text-primary" />
            <CardTitle>Cr√©ation d‚Äôun nouveau r√©seau</CardTitle>
          </div>
        </CardHeader>

        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* Informations R√©seau */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="nomReseau">Nom du r√©seau *</Label>
                <Input
                  id="nomReseau"
                  value={formData.nomReseau}
                  onChange={(e) => updateFormData("nomReseau", e.target.value)}
                  placeholder="Nom du R√©seau"
                />
                {errors.nomReseau && (
                  <p className="text-sm text-red-500">{errors.nomReseau}</p>
                )}
              </div>

              <div>
                <Label htmlFor="siret">Siret *</Label>
                <Input
                  id="siret"
                  value={formData.siret}
                  onChange={(e) => updateFormData("siret", e.target.value)}
                  placeholder="N¬∞ Siret du R√©seau"
                />
                {errors.siret && (
                  <p className="text-sm text-red-500">{errors.siret}</p>
                )}
              </div>
            </div>

            <div>
              <Label htmlFor="adresse">Adresse *</Label>
              <Input
                id="adresse"
                value={formData.adresse}
                onChange={(e) => updateFormData("adresse", e.target.value)}
                placeholder="Adresse. Si√®ge R√©seau"
              />
              {errors.adresse && (
                <p className="text-sm text-red-500">{errors.adresse}</p>
              )}
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="codePostal">Code postal *</Label>
                <Input
                  id="codePostal"
                  value={formData.codePostal}
                  onChange={(e) => updateFormData("codePostal", e.target.value)}
                  placeholder="Code Postal. Si√®ge R√©seau"
                />
                {errors.codePostal && (
                  <p className="text-sm text-red-500">{errors.codePostal}</p>
                )}
              </div>
              <div>
                <Label htmlFor="ville">Ville *</Label>
                <Input
                  id="ville"
                  value={formData.ville}
                  onChange={(e) => updateFormData("ville", e.target.value)}
                  placeholder="Ville. Si√®ge R√©seau"
                />
                {errors.ville && (
                  <p className="text-sm text-red-500">{errors.ville}</p>
                )}
              </div>
            </div>

            {/* Responsable */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="prenomResponsable">Pr√©nom Direction *</Label>
                <Input
                  id="prenomResponsable"
                  value={formData.prenomResponsable}
                  onChange={(e) =>
                    updateFormData("prenomResponsable", e.target.value)
                  }
                  placeholder="Pr√©nom. Reseau Direction"
                />
                {errors.prenomResponsable && (
                  <p className="text-sm text-red-500">
                    {errors.prenomResponsable}
                  </p>
                )}
              </div>
              <div>
                <Label htmlFor="nomResponsable">Nom Direction *</Label>
                <Input
                  id="nomResponsable"
                  value={formData.nomResponsable}
                  onChange={(e) =>
                    updateFormData("nomResponsable", e.target.value)
                  }
                  placeholder="Nom. Reseau Direction"
                />
                {errors.nomResponsable && (
                  <p className="text-sm text-red-500">
                    {errors.nomResponsable}
                  </p>
                )}
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="emailResponsable">Email Direction *</Label>
                <Input
                  id="emailResponsable"
                  value={formData.emailResponsable}
                  onChange={(e) =>
                    updateFormData("emailResponsable", e.target.value)
                  }
                  placeholder="Email. Reseau Direction"
                />
                {errors.emailResponsable && (
                  <p className="text-sm text-red-500">
                    {errors.emailResponsable}
                  </p>
                )}
              </div>
              <div>
                <Label htmlFor="telephoneResponsable">
                  T√©l√©phone Direction *
                </Label>
                <Input
                  id="telephoneResponsable"
                  value={formData.telephoneResponsable}
                  onChange={(e) =>
                    updateFormData("telephoneResponsable", e.target.value)
                  }
                  placeholder="T√©l. Reseau Direction"
                />
                {errors.telephoneResponsable && (
                  <p className="text-sm text-red-500">
                    {errors.telephoneResponsable}
                  </p>
                )}
              </div>
            </div>

            {/* Boutons */}
            <div className="flex justify-between pt-6">
              <Button
                type="button"
                variant="outline"
                onClick={onBack}
                disabled={isLoading}
              >
                <ArrowLeft className="h-4 w-4 mr-2" />
                Retour
              </Button>
              <Button type="submit" disabled={isLoading}>
                {isLoading ? "Cr√©ation en cours..." : "Cr√©er le r√©seau"}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>

      {/* Affichage des informations de connexion apr√®s succ√®s */}
      {creationResult && (
        <SuccessAccountInfo
          email={creationResult.email}
          tempPassword={creationResult.tempPassword}
        />
      )}
    </div>
  );
}
```
---
## **Explications. Comment Personnaliser la Page Form Cr√©ation **
---
### Sous-√âtape 1 : D√©finition des Champs du Formulaire (ADMIN PRESENCA)

- *Objectif* : D√©finir les champs, titres, placeholders, nombre d'onglets AVANT toute adaptation technique
- *Directives* :
	- D√âCISION ADMIN_PRESENCA : Choisir les champs n√©cessaires pour la cr√©ation de cette table
	- V√âRIFICATION OBLIGATOIRE : Consulter TablesReference{Table}.ts pour conna√Ætre les colonnes disponibles
	- V√âRIFICATION OBLIGATOIRE : Consulter Supabase pour v√©rifier les colonnes r√©elles de la table
	- MAPPING : Faire correspondre les champs du formulaire avec les colonnes de la base de donn√©es

---
### Sous-√âtape 2 : Imports et Configuration

- *Objectif* : Importer les d√©pendances UI, hooks personnalis√©s et types
- *Directives* :
	- CONSERVER : Imports UI (Card, Button, Input, Label, Separator, icons)
	- √Ä PERSONNALISER :
```typescript
Import du hook : use{Table}Creation
Import des types : {Table}CreationData, {Table}ValidationErrors
Import du composant succ√®s : SuccessAccountInfo (r√©utilisable pour toutes les tables)

import { useReseauCreation } from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.{Table}/use{Table}Creation";
import type { {Table}CreationData, {Table}ValidationErrors } from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.{Table}/types";
```
---
### Sous-√âtape 3 : Interfaces et Props

- *Objectif* : D√©finir l'interface des props du composant
- *Directives* :
	- CONSERVER : La structure onBack: () => void (pour le bouton retour)
	- √Ä PERSONNALISER : Le nom de l'interface Form{Table}CreationProps
```typescript
interface Form{Table}CreationProps {  // ‚Üê √Ä PERSONNALISER
  onBack: () => void;
}

export default function Form{Table}Creation({ onBack }: Form{Table}CreationProps) {
```
---
### Sous-√âtape 4 : Initialisation du Composant et Hooks

- *Objectif* : Initialiser le hook de cr√©ation et le state de succ√®s
- *Directives* :
	- √Ä PERSONNALISER : Nom du hook use{Table}Creation()
	- CONSERVER : successData state (pour afficher le succ√®s)
```typescript
  const { create{Table}, isLoading, error } = use{Table}Creation();  // ‚Üê √Ä PERSONNALISER
  const [successData, setSuccessData] = useState<{ email: string; tempPassword: string } | null>(null);
```
---
### Sous-√âtape 5 : State Management (formData, errors, successData)

- *Objectif* : Initialiser les states pour les donn√©es du formulaire et les erreurs
- *Directives* :
	- √Ä PERSONNALISER :
		- Type : {Table}CreationData
		- Champs dans formData selon Sous-√âtape 1 et Table R√©f√©rence
	- V√âRIFICATION OBLIGATOIRE : Mapper exactement les champs d√©finis par admin_presenca avec les colonnes de la table
```typescript
  const [formData, setFormData] = useState<{Table}CreationData>({  // ‚Üê √Ä PERSONNALISER
    nom{Table}: "",           // ‚Üê √Ä PERSONNALISER selon Table R√©f√©rence
    adresse: "",
    codePostal: "",
    ville: "",
    siret: "",
    nomResponsable: "",
    prenomResponsable: "",
    emailResponsable: "",
    telephoneResponsable: "",
  });

  const [errors, setErrors] = useState<{Table}ValidationErrors>({});  // ‚Üê √Ä PERSONNALISER
```
---
### Sous-√âtape 6 : Fonction de Mise √† Jour des Champs

- *Objectif* : G√©rer les changements dans les champs du formulaire
- *Directives* :
	- √Ä PERSONNALISER : Type {Table}CreationData
	- CONSERVER : La logique de mise √† jour et de nettoyage des erreurs
```typescript
  const updateFormData = (field: keyof {Table}CreationData, value: string) => {  // ‚Üê √Ä PERSONNALISER
    setFormData(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };
```
---
### Sous-√âtape 7 : Fonction de Validation Client

- *Objectif* : Valider les champs c√¥t√© client avant soumission
- *Directives* :
	- √Ä PERSONNALISER :
		- Type {Table}ValidationErrors
		- Les validations selon les champs d√©finis en Sous-√âtape 1
	- V√âRIFICATION OBLIGATOIRE : Adapter les validations selon les contraintes de la table (nullable, format, etc.)
	- CONSERVER :
		- Validation email (regex)
		- Validation SIRET (14 chiffres)
		- Pattern .trim() pour les champs texte
```typescript
  const validateForm = (): boolean => {
    const newErrors: {Table}ValidationErrors = {};  // ‚Üê √Ä PERSONNALISER

    // ‚Üê ADAPTER selon les champs d√©finis par admin_presenca
    if (!formData.nom{Table}.trim()) newErrors.nom{Table} = "Le nom est requis";
    if (!formData.siret.trim()) newErrors.siret = "Le SIRET est requis";
    // ... autres validations
    
    if (formData.emailResponsable && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.emailResponsable)) {
      newErrors.emailResponsable = "Format d'email invalide";
    }

    if (formData.siret && formData.siret.length !== 14) {
      newErrors.siret = "Le SIRET doit contenir 14 chiffres";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
```
---
### Sous-√âtape 8 : Fonction de Soumission (handleSubmit)

- *Objectif* : G√©rer la soumission du formulaire et l'appel au hook
- *Directives* :
	- √Ä PERSONNALISER : Nom de la fonction create{Table}
	- CONSERVER :
		- Pattern validation avant appel
	- Console.log pour debug
	- Gestion du successData
```typescript
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    console.log('üìã Soumission formulaire {table}:', formData);  // ‚Üê √Ä PERSONNALISER
    
    const result = await create{Table}(formData);  // ‚Üê √Ä PERSONNALISER
    
    if (result) {
      console.log('‚úÖ {Table} cr√©√© avec succ√®s:', result);  // ‚Üê √Ä PERSONNALISER
      setSuccessData({
        email: result.email,
        tempPassword: result.tempPassword
      });
    }
  };
---
```
### Sous-√âtape 9 : Rendu Conditionnel (Succ√®s)

- *Objectif* : Afficher le composant de succ√®s si la cr√©ation a r√©ussi
- *Directives* :
	- CONSERVER : Ce bloc (identique pour toutes les tables)
```typescript
  // Afficher le succ√®s si on a les donn√©es
  if (successData) {
    return <SuccessAccountInfo email={successData.email} 
    tempPassword={successData.tempPassword} />;
  }
```
---
### Sous-√âtape 10 : Structure HTML/JSX - Informations Entit√©

- *Objectif* : Cr√©er la section du formulaire pour les informations de l'entit√© (r√©seau, agence, etc.)
- *Directives* :
	- √Ä PERSONNALISER :
		- Titre de la Card : "Informations du r√©seau" ‚Üí "Informations de {l'entit√©}"
	- A PERSONNALISER : Champs selon Sous-√âtape 1 et Table R√©f√©rence
	- V√âRIFICATION OBLIGATOIRE : Mapper les id, value, onChange avec les champs de formData
	- CONSERVER : Structure Card > CardHeader > CardContent > grid
```typescript
<Card>
  <CardHeader>
    <CardTitle className="flex items-center gap-2">
      <Building className="h-5 w-5" /> 
      Informations du {table}  {/* ‚Üê √Ä PERSONNALISER */}
    </CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div>
        <Label htmlFor="nom{Table}">Nom *</Label>  {/* ‚Üê √Ä PERSONNALISER */}
        <Input
          id="nom{Table}"  {/* ‚Üê √Ä PERSONNALISER */}
          value={formData.nom{Table}}  {/* ‚Üê √Ä PERSONNALISER */}
          onChange={(e) => updateFormData("nom{Table}", e.target.value)}  {/* ‚Üê √Ä PERSONNALISER */}
          placeholder="Nom du {table}"  {/* ‚Üê √Ä PERSONNALISER */}
        />
        {errors.nom{Table} && <p className="text-sm text-red-500 mt-1">{errors.nom{Table}}</p>}
      </div>
      {/* ... autres champs selon Sous-√âtape 1 */}
    </div>
  </CardContent>
</Card>
```
---
### Sous-√âtape 11 : Structure HTML/JSX - Informations Responsable

- *Objectif* : Cr√©er la section pour les informations du responsable
- *Directives* :
	- Titre du responsable transmis par Admin_presenca selon le type de responsable
- Table reseau : -> Responsable du R√©seau
- Table reseau_agence : -> Responsable de l'Agence du R√©seau
- Table agence_independante : -> Responsable de l'Agence Ind√©pendante
	- CONSERVER : Structure et champs (nom, pr√©nom, email, t√©l√©phone)
```typescript
<Card>
  <CardHeader>
    <CardTitle className="flex items-center gap-2">
      <User className="h-5 w-5" />
      Responsable du {table}  {/* ‚Üê √Ä PERSONNALISER */}
    </CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* Champs nom, pr√©nom, email, t√©l√©phone - CONSERVER */}
  </CardContent>
</Card>
```
---
### Sous-√âtape 12 : Boutons d'Action et Gestion Erreurs

- *Objectif* : Afficher les erreurs et les boutons de soumission/annulation
- *Directives* :
	- √Ä PERSONNALISER : Texte du bouton submit ("Cr√©er le r√©seau" ‚Üí "Cr√©er {L'agence du R√©seau / Cr√©er l'Agence Ind√©pendante}")
	- CONSERVER : Gestion du isLoading, affichage des erreurs, bouton Annuler
```typescript
{error && (
  <div className="p-4 bg-red-50 border border-red-200 rounded-md">
    <p className="text-sm text-red-600">{error}</p>
  </div>
)}

<div className="flex justify-end gap-4">
  <Button type="button" variant="outline" onClick={onBack}>
    Annuler
  </Button>
  <Button type="submit" disabled={isLoading}>
    {isLoading ? (
      <>
        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
        Cr√©ation en cours...
      </>
    ) : (
      "Cr√©er le {table}"  {/* ‚Üê √Ä PERSONNALISER */}
    )}
  </Button>
</div>
```
---
---
# √âtape 7 : Composant d'Affichage du Succ√®s
**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/SuccessAccountInfo.tsx`
- Toujours utiliser la structure de nomage
- src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/(num√©rotation de la structure de nomage)/SuccessAccountInfo.tsx
  
```typescript
import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Copy, Eye, EyeOff, CheckCircle } from "lucide-react";
import { toast } from "sonner";

interface SuccessAccountInfoProps {
  email: string;
  tempPassword: string;
}

export default function SuccessAccountInfo({ email, tempPassword }: SuccessAccountInfoProps) {
  const [showPassword, setShowPassword] = useState(false);

  const copyToClipboard = async (text: string, label: string) => {
    try {
      await navigator.clipboard.writeText(text);
      toast.success(`${label} copi√© dans le presse-papiers`);
    } catch (err) {
      toast.error("Erreur lors de la copie");
    }
  };

  return (
    <Card className="mt-6 border-green-200 bg-green-50/50">
      <CardHeader>
        <div className="flex items-center gap-3">
          <CheckCircle className="h-6 w-6 text-green-600" />
          <CardTitle className="text-green-800">Compte cr√©√© avec succ√®s</CardTitle>
        </div>
      </CardHeader>

      <CardContent>
        <div className="space-y-4">
          <div className="p-4 bg-white rounded-lg border">
            <h4 className="font-medium text-sm text-gray-700 mb-3">
              Informations de connexion temporaires
            </h4>
            
            <div className="space-y-3">
              {/* Email */}
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                <div>
                  <span className="text-sm font-medium text-gray-600">Email :</span>
                  <p className="text-sm text-gray-900">{email}</p>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => copyToClipboard(email, "Email")}
                >
                  <Copy className="h-4 w-4" />
                </Button>
              </div>

              {/* Mot de passe */}
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                <div className="flex-1">
                  <span className="text-sm font-medium text-gray-600">Mot de passe temporaire :</span>
                  <p className="text-sm text-gray-900 font-mono">
                    {showPassword ? tempPassword : "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"}
                  </p>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setShowPassword(!showPassword)}
                  >
                    {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(tempPassword, "Mot de passe")}
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </div>

            <div className="mt-4 p-3 bg-blue-50 rounded-md border border-blue-200">
              <p className="text-sm text-blue-800">
                <strong>Important :</strong> Ces informations sont temporaires. L'utilisateur devra 
                changer son mot de passe lors de sa premi√®re connexion.
              </p>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```
---
## **Explications. Comment concevoir le Composant d'Affichage du Succ√®s **
---
### Fichier √† reprendre en l'√©tat dans le dossier de la table.
---

