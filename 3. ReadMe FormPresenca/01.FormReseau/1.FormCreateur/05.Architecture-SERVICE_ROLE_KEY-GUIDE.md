# üîê Architecture SERVICE_ROLE_KEY - Guide Reproductible

## üìä Tableau R√©capitulatif

| Aspect | Cr√©ation (‚úÖ) |
|--------|---------------|
| **V√©rification token client** | ‚ùå Aucune |
| **Cl√© utilis√©e pour Supabase** | SERVICE_ROLE_KEY (interne) |
| **Token accept√© du frontend** | N'importe lequel (ANON_KEY OK) |
| **Architecture** | "Proxy transparent" |

---

## üéØ Concept Central

**L'Edge Function agit comme un PROXY S√âCURIS√â** :
- Elle re√ßoit une requ√™te du frontend (avec ANON_KEY)
- Elle NE V√âRIFIE PAS le token client
- Elle utilise SA PROPRE cl√© admin (SERVICE_ROLE_KEY) pour toutes les op√©rations

**Flux complet** :
```
Frontend (ANON_KEY)
  ‚Üí Edge function (ignore le token re√ßu)
  ‚Üí Edge function utilise SERVICE_ROLE_KEY en interne
  ‚Üí Supabase (bypass RLS avec SERVICE_ROLE_KEY)
```

---

## üìù Analyse D√©taill√©e du Code

### **1/ Imports et Configuration CORS**
```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'
import { getCorsHeaders } from '../_shared/cors.ts'
```

**Explication** :
- `createClient` : Fonction Supabase pour cr√©er un client
- `getCorsHeaders` : Fonction partag√©e pour g√©rer les origines autoris√©es (Lovable.app, domaines production, etc.)

---

### **2/ Cr√©ation du Client Admin Supabase**
```typescript
const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

const supabaseAdmin = createClient(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})
```

**Explication** :
- ‚úÖ **SERVICE_ROLE_KEY** : Cl√© secr√®te qui bypass RLS et donne acc√®s admin total
- ‚úÖ **autoRefreshToken: false** : Pas besoin de rafra√Æchir, c'est une cl√© permanente
- ‚úÖ **persistSession: false** : Pas de session c√¥t√© serveur, chaque requ√™te est ind√©pendante
- ‚ö†Ô∏è **Ce client reste c√¥t√© serveur uniquement** : Le frontend n'y a jamais acc√®s

---

### **3/ D√©marrage du Serveur Deno**
```typescript
Deno.serve(async (req) => {
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)
```

**Explication** :
- `Deno.serve` : D√©marre l'Edge Function (√©quivalent Express.js mais pour Deno)
- `origin` : D'o√π vient la requ√™te (lovable.app, domaine production, etc.)
- `getCorsHeaders(origin)` : V√©rifie si l'origine est autoris√©e et retourne les headers CORS appropri√©s

---

### **4/ Gestion du Preflight CORS**
```typescript
if (req.method === 'OPTIONS') {
  return new Response(null, { headers: corsHeaders })
}
```

**Explication** :
- Le navigateur envoie une requ√™te OPTIONS **AVANT** la vraie requ√™te POST
- C'est le "preflight" CORS : v√©rification de s√©curit√© du navigateur
- On r√©pond imm√©diatement avec les headers CORS pour autoriser la requ√™te

---

### **5/ D√©but du Traitement - Parsing des Donn√©es**
```typescript
try {
  // ‚ö†Ô∏è TEMPORAIRE: JWT v√©rification d√©sactiv√©e pour tests
  console.log('üîì TEST MODE: JWT verification disabled')

  const formData: ReseauCreationData = await req.json()
```

**Explication** :
- ‚ùå **PAS de v√©rification JWT** : C'est le point cl√© !
- Le commentaire indique que c'est temporaire, mais c'est en fait la strat√©gie choisie
- `req.json()` : Parse le body de la requ√™te en objet TypeScript
- Le frontend envoie ANON_KEY mais l'Edge Function l'IGNORE compl√®tement

---

### **6/ Logs S√©curis√©s (Pas de Donn√©es Sensibles)**
```typescript
console.log('üìù CREATION: Starting reseau creation', {
  nomReseau: formData.nomReseau,
  ville: formData.ville,
  siret: formData.siret?.slice(0, 4) + '***', // SIRET partiel
  hasEmail: !!formData.emailResponsable,
  hasPhone: !!formData.telephoneResponsable
})
```

**Explication** :
- ‚úÖ **Logs s√©curis√©s** : On ne log JAMAIS les emails/t√©l√©phones en clair
- `siret.slice(0, 4) + '***'` : Masquage partiel du SIRET
- `!!formData.emailResponsable` : Juste un bool√©en (true/false), pas la valeur
- Ces logs sont visibles dans Supabase Dashboard ‚Üí Edge Functions ‚Üí Logs

---

### **7/ Validation C√¥t√© Serveur**
```typescript
if (!formData.emailResponsable || !formData.emailResponsable.includes('@')) {
  throw new Error('Email invalide')
}

if (!formData.siret || formData.siret.length !== 14) {
  throw new Error('SIRET invalide (14 chiffres requis)')
}
```

**Explication** :
- ‚úÖ **Double validation** : Client (UX) + Serveur (s√©curit√©)
- **Pourquoi ?** M√™me si le frontend valide, un attaquant peut envoyer n'importe quoi via curl/Postman
- Ces v√©rifications c√¥t√© serveur sont **obligatoires** pour la s√©curit√©

---

### **8/ Utilisation du Client Admin pour Cr√©er l'Utilisateur**
```typescript
const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
  email: formData.emailResponsable,
  password: tempPassword,
  email_confirm: true,
  user_metadata: {
    nom: formData.nomResponsable,
    prenom: formData.prenomResponsable,
    type_compte: 'reseau'
  }
})
```

**Explication** :
- ‚úÖ **supabaseAdmin.auth.admin** : API r√©serv√©e aux administrateurs
- Cette m√©thode n√©cessite **SERVICE_ROLE_KEY**
- `email_confirm: true` : Pas besoin d'email de confirmation
- Le frontend avec ANON_KEY ne pourrait **JAMAIS** faire cette op√©ration

---

### **9/ Appel de la Fonction SQL avec Privil√®ges Admin**
```typescript
const { data: sqlResult, error: sqlError } = await supabaseAdmin.rpc('create_reseau_compte_complet', {
  p_nom_reseau: formData.nomReseau,
  p_auth_uid: authUser.user.id,
  // ... autres param√®tres
})
```

**Explication** :
- ‚úÖ **supabaseAdmin.rpc()** : Appel de fonction SQL avec SERVICE_ROLE_KEY
- La fonction SQL est en `SECURITY DEFINER` : elle s'ex√©cute avec les droits du cr√©ateur
- Elle bypass **tous les RLS** et peut √©crire dans toutes les tables
- Le frontend avec ANON_KEY ne pourrait **JAMAIS** appeler cette fonction RPC

---

## üîí S√©curit√© de l'Architecture

### ‚úÖ **Points Forts**
1. **SERVICE_ROLE_KEY reste c√¥t√© serveur** : Jamais expos√©e au frontend
2. **Op√©rations atomiques** : Tout se fait en transaction (rollback si erreur)
3. **Validation double** : Client + Serveur
4. **Logs s√©curis√©s** : Pas de donn√©es sensibles

### ‚ö†Ô∏è **Points d'Attention**
1. **Pas de v√©rification du r√¥le de l'appelant** : N'importe qui avec l'URL peut appeler
2. **Solution** : Protection c√¥t√© frontend (v√©rifier `isAdminPresenca` avant d'afficher le formulaire)
3. **Alternative** : Ajouter une v√©rification JWT dans l'Edge Function pour contr√¥ler qui peut appeler

---

## üöÄ Configuration N√©cessaire

### **1/ Fichier `supabase/config.toml`**
```toml
[functions.create-reseau-admin]
verify_jwt = false  # ‚ö†Ô∏è Cl√© de l'architecture : pas de v√©rification JWT
```

**Effet** :
- L'Edge Function accepte **n'importe quel token** (ou aucun)
- Elle ne d√©code pas le JWT du client
- Elle utilise uniquement son SERVICE_ROLE_KEY interne

### **2/ Variables d'Environnement (Auto-configur√©es)**
- `SUPABASE_URL` : URL du projet Supabase
- `SUPABASE_SERVICE_ROLE_KEY` : Cl√© admin secr√®te

---

## üì¶ Pour Reproduire sur un Autre Formulaire

### **Checklist Compl√®te**

1. ‚úÖ **Cr√©er l'Edge Function**
   ```typescript
   const supabaseAdmin = createClient(
     Deno.env.get('SUPABASE_URL')!,
     Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
   )
   ```

2. ‚úÖ **Configurer `config.toml`**
   ```toml
   [functions.ma-nouvelle-fonction]
   verify_jwt = false
   ```

3. ‚úÖ **G√©rer CORS**
   ```typescript
   import { getCorsHeaders } from '../_shared/cors.ts'
   if (req.method === 'OPTIONS') {
     return new Response(null, { headers: corsHeaders })
   }
   ```

4. ‚úÖ **Valider c√¥t√© serveur**
   ```typescript
   if (!data.email || !data.email.includes('@')) {
     throw new Error('Email invalide')
   }
   ```

5. ‚úÖ **Utiliser le client admin**
   ```typescript
   await supabaseAdmin.auth.admin.createUser({...})
   await supabaseAdmin.rpc('ma_fonction_sql', {...})
   ```

6. ‚úÖ **Logs s√©curis√©s**
   ```typescript
   console.log('Operation', { 
     hasEmail: !!data.email,  // Pas l'email en clair
     id: data.id.slice(0, 8) + '***'  // ID partiel
   })
   ```

---

## üéØ R√©sum√© en 3 Points

1. **Frontend envoie requ√™te avec ANON_KEY** ‚Üí L'Edge Function l'ignore
2. **Edge Function utilise SERVICE_ROLE_KEY** ‚Üí Privil√®ges admin complets
3. **Op√©rations bypass RLS** ‚Üí Cr√©ation/modification directe en base

**Architecture = "Proxy Transparent avec √âl√©vation de Privil√®ges"**
