# BIBLE COMPLÈTE - Processus de Création des Formulaires de Réseau

## 📋 Vue d'ensemble
- Ce document historise le processus complet de création des formulaires de compte utilisateur pour les réseaux, avec tous les codes exacts et les corrections apportées. Il sert de référence absolue pour éviter les erreurs futures.
---

## 📋 Processus de création :
- Organisation : Créée en premier avec les infos du réseau
- Utilisateur Auth : Créé avec l'email du responsable
- Users + Utilisateurs : Profil de la personne responsable
- Réseau : Entité business avec reseau_email et reseau_telephone
- Reseau_direction : Rattachement du responsable avec reseau_direction_email et reseau_direction_telephone
---
## 📋 Ce qui se passe quand on crée un réseau avec Email Direction et Téléphone Direction
Formulaire de création :
- L’admin admin_presenca saisit les informations dans le formulaire de création (nom réseau, adresse, siret, etc.) ainsi que :
- Téléphone Direction
- Email Direction

Tables concernées lors de l’insertion :
- Ces deux champs sont insérés dans la table reseau en tant que :
- reseau_telephone
- reseau_email

Ils sont ensuite synchronisés automatiquement dans la table reseau_direction pour que l’utilisateur directeur ait les mêmes coordonnées.
- reseau_direction_telephone
- reseau_direction_email

IDs impliqués dans l’opération : 
- reseau_id (clé primaire du réseau) → utilisé pour créer le réseau et comme pivot de toutes les relations.
- organisation_id (FK dans reseau) → rattache le réseau à l’organisation déjà existante.
- reseau_direction_id (FK lié à l’utilisateur directeur) → utilisé pour propager l’email et téléphone dans la table reseau_direction.

Donc :
- Point de vérité : reseau.reseau_telephone et reseau.reseau_email.
- Synchronisation automatique → reseau_direction.reseau_direction_telephone et reseau_direction.reseau_direction_email.
- IDs pivots utilisés : reseau_id (principal), organisation_id (lien organisation), reseau_direction_id (synchronisation).
---
## 🏗️ Architecture Complète

### Structure des Dossiers

```
src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/
├── FormReseauCreation.tsx          # Composant principal du formulaire
├── SuccessAccountInfo.tsx          # Affichage des informations de connexion
├── DETAIL-ETAPES.md               # Historique des étapes et corrections
└── TOUSLESFICHIERS.md             # Documentation complète

src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/
├── useReseauCreation.ts           # Hook métier pour la création
└── types.ts                       # Types TypeScript

supabase/functions/
└── create-reseau-admin/
    └── index.ts                   # Edge Function de création

supabase/functions/_shared/
└── cors.ts                        # Configuration CORS
```

## 🔄 Processus Complet Étape par Étape

### Étape 1 : Définition des Types TypeScript

**Fichier :** `src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/types.ts`

```typescript
export interface ReseauCreationData {
  nomReseau: string;
  adresse: string;
  codePostal: string;
  ville: string;
  siret: string;
  nomResponsable: string;
  prenomResponsable: string;
  emailResponsable: string;
  telephoneResponsable: string;
}

export interface ReseauValidationErrors {
  nomReseau?: string;
  adresse?: string;
  codePostal?: string;
  ville?: string;
  siret?: string;
  nomResponsable?: string;
  prenomResponsable?: string;
  emailResponsable?: string;
  telephoneResponsable?: string;
}

export interface ReseauCreationResult {
  organisationId: string;
  reseauId: string;
  userId: string;
  utilisateurId: string;
  directionId: string;
  email: string;
  tempPassword: string;
}
```

### Étape 2 : Hook Métier de Création

**Fichier :** `src/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/useReseauCreation.ts`

```typescript
import { supabase } from "@/integrations/supabase/client";
import { useState } from "react";
import type { ReseauCreationData, ReseauCreationResult } from "./types";

export function useReseauCreation() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createReseau = async (formData: ReseauCreationData): Promise<ReseauCreationResult | null> => {
    setIsLoading(true);
    setError(null);

    try {
      // --- Appel Edge Function ---
      const { data, error } = await supabase.functions.invoke('create-reseau-admin', {
        body: formData
      });

      if (error) {
        setError("Erreur création réseau: " + error.message);
        return null;
      }

      if (!data || !data.data) {
        throw new Error("Aucune donnée retournée par la fonction");
      }

      // --- Succès - Extraction depuis data.data ---
      const result: ReseauCreationResult = {
        organisationId: data.data.organisationId,
        reseauId: data.data.reseauId,
        userId: data.data.userId,
        utilisateurId: data.data.utilisateurId,
        directionId: data.data.directionId,
        email: formData.emailResponsable,
        tempPassword: data.tempPassword, // Au niveau racine de data
      };

      return result;

    } catch (err: any) {
      console.error("Erreur création réseau:", err);
      setError(err.message);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { createReseau, isLoading, error };
}
```

### Étape 3 : Edge Function de Création

**Fichier :** `supabase/functions/create-reseau-admin/index.ts`

```typescript
import { createClient } from '@supabase/supabase-js'
import { getCorsHeaders } from '../_shared/cors.ts'

const supabaseAdmin = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
)

interface ReseauCreationData {
  nomReseau: string;
  adresse: string;
  codePostal: string;
  ville: string;
  siret: string;
  nomResponsable: string;
  prenomResponsable: string;
  emailResponsable: string;
  telephoneResponsable: string;
}

Deno.serve(async (req: Request) => {
  // --- CORS Headers ---
  const origin = req.headers.get('origin')
  const corsHeaders = getCorsHeaders(origin)

  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('🚀 Edge Function create-reseau-admin démarrée');
    
    // --- Parsing & Validation ---
    const body: ReseauCreationData = await req.json();
    console.log('📋 Données reçues:', { email: body.emailResponsable, reseau: body.nomReseau });

    if (!body.emailResponsable || !body.nomReseau) {
      throw new Error('Email et nom du réseau requis');
    }

    // --- Génération mot de passe temporaire ---
    const tempPassword = crypto.randomUUID().substring(0, 16);
    console.log('🔑 Mot de passe temporaire généré');

    // --- Création utilisateur Supabase Auth ---
    const { data: authUser, error: authError } = await supabaseAdmin.auth.admin.createUser({
      email: body.emailResponsable,
      password: tempPassword,
      email_confirm: true,
      user_metadata: {
        nom: body.nomResponsable,
        prenom: body.prenomResponsable,
        telephone: body.telephoneResponsable
      }
    });

    if (authError) {
      console.error('❌ Erreur création auth:', authError);
      throw new Error(`Erreur création utilisateur: ${authError.message}`);
    }

    console.log('✅ Utilisateur Auth créé:', authUser.user?.id);

    // --- Appel fonction SQL ---
    const { data: sqlResult, error: sqlError } = await supabaseAdmin.rpc('create_reseau_compte_complet', {
      p_nom_reseau: body.nomReseau,
      p_adresse: body.adresse,
      p_code_postal: body.codePostal,
      p_ville: body.ville,
      p_siret: body.siret,
      p_nom_responsable: body.nomResponsable,
      p_prenom_responsable: body.prenomResponsable,
      p_email_responsable: body.emailResponsable,
      p_telephone_responsable: body.telephoneResponsable,
      p_auth_uid: authUser.user!.id
    });

    if (sqlError) {
      console.error('❌ Erreur SQL:', sqlError);
      
      // --- Rollback : suppression utilisateur Auth ---
      console.log('🔄 Rollback: suppression utilisateur auth...');
      await supabaseAdmin.auth.admin.deleteUser(authUser.user!.id);
      
      throw new Error(`Erreur création données: ${sqlError.message}`);
    }

    console.log('✅ Fonction SQL réussie:', sqlResult);

    // --- Réponse succès ---
    return new Response(
      JSON.stringify({
        success: true,
        tempPassword,
        data: sqlResult,
        message: 'Compte réseau créé avec succès'
      }),
      {
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json' 
        }
      }
    );

  } catch (error: any) {
    console.error('💥 Erreur Edge Function:', error);
    
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message
      }),
      {
        status: 400,
        headers: { 
          ...corsHeaders,
          'Content-Type': 'application/json' 
        }
      }
    );
  }
});
```

### Étape 4 : Configuration CORS

**Fichier :** `supabase/functions/_shared/cors.ts`
- Ajout : modification du CORS avec le pattern lovableproject.com le 18.9.2025

```typescript
const allowedOrigins = [
  // 🏢 PRODUCTION
  'https://www.leadgenai-adbuilder.com',
  'https://leadgenai-adbuilder.com',

  // 🧪 TEST LOVABLE
  'https://appli-v7-leadgenai.lovable.app',

  // 🛠️ DÉVELOPPEMENT LOVABLE
  'https://lovable.dev',
  'https://lovable.app',
  /^https:\/\/.*\.lovable\.app$/,
  /^https:\/\/.*\.lovable\.dev$/,
  /^https:\/\/.*\.lovableproject\.com$/,

  // 🔧 DÉVELOPPEMENT LOCAL (si besoin)
  'http://localhost:3000',
  'http://localhost:5173',
]

export const getCorsHeaders = (origin: string | null) => {
  const isAllowed = allowedOrigins.some(allowed => {
    if (typeof allowed === 'string') return allowed === origin
    if (allowed instanceof RegExp) return allowed.test(origin || '')
    return false
  })
  
  return {
    'Access-Control-Allow-Origin': isAllowed ? (origin || '*') : 'null',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  }
}
```

### Étape 5 : Fonction SQL de Création Complète

**Fonction SQL :** `create_reseau_compte_complet`

```sql
CREATE OR REPLACE FUNCTION public.create_reseau_compte_complet(
  p_nom_reseau text,
  p_adresse text,
  p_code_postal text,
  p_ville text,
  p_siret text,
  p_nom_responsable text,
  p_prenom_responsable text,
  p_email_responsable text,
  p_telephone_responsable text,
  p_auth_uid uuid
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
  v_org_id uuid;
  v_user_id uuid;
  v_utilisateur_id uuid;
  v_reseau_id uuid;
  v_direction_id uuid;
BEGIN
  -- 1. Organisation
  INSERT INTO organisations (
    organisation_nom, organisation_adresse, organisation_code_postal,
    organisation_ville, organisation_siret, organisation_email,
    organisation_telephone, organisation_statut_compte
  )
  VALUES (
    p_nom_reseau, p_adresse, p_code_postal, p_ville, p_siret,
    p_email_responsable, p_telephone_responsable, 'actif'
  )
  RETURNING organisation_id INTO v_org_id;

  -- 2. Users (⚠️ rôle système = NULL car ce n'est pas un admin global)
  INSERT INTO users (
    users_nom, users_prenom, users_email, users_telephone,
    users_role_systeme, users_organisation_id, users_auth_id
  )
  VALUES (
    p_nom_responsable, p_prenom_responsable, p_email_responsable,
    p_telephone_responsable, NULL, v_org_id, p_auth_uid
  )
  RETURNING users_id INTO v_user_id;

  -- 3. Utilisateurs (profil métier du responsable de réseau)
  INSERT INTO utilisateurs (
    utilisateur_email, utilisateur_type_compte, utilisateur_statut,
    utilisateur_organisation_id, utilisateur_auth_uid, utilisateur_role_systeme
  )
  VALUES (
    p_email_responsable, 'reseau', 'actif',
    v_org_id, p_auth_uid, NULL
  )
  RETURNING utilisateur_id INTO v_utilisateur_id;

  -- 4. Réseau (fiche business)
  INSERT INTO reseau (
    organisation_id, reseau_nom, reseau_adresse, reseau_code_postal,
    reseau_ville, reseau_siret, reseau_email, reseau_telephone,
    reseau_statut, client_type
  )
  VALUES (
    v_org_id, p_nom_reseau, p_adresse, p_code_postal, p_ville,
    p_siret, p_email_responsable, p_telephone_responsable,
    'actif', 'reseau'
  )
  RETURNING reseau_id INTO v_reseau_id;

  -- 5. Direction Réseau (🔧 CORRECTION: utilisation de v_user_id au lieu de v_utilisateur_id)
  INSERT INTO reseau_direction (
    organisation_id, reseau_id,
    reseau_direction_nom, reseau_direction_prenom,
    reseau_direction_email, reseau_direction_telephone,
    reseau_direction_utilisateur_id, client_type,
    reseau_direction_actif
  )
  VALUES (
    v_org_id, v_reseau_id,
    p_nom_responsable, p_prenom_responsable,
    p_email_responsable, p_telephone_responsable,
    v_user_id, 'reseau', true
  )
  RETURNING reseau_direction_id INTO v_direction_id;

  -- Résultat en JSON
  RETURN jsonb_build_object(
    'organisationId', v_org_id,
    'userId', v_user_id,
    'utilisateurId', v_utilisateur_id,
    'reseauId', v_reseau_id,
    'directionId', v_direction_id,
    'message', 'Compte réseau créé avec succès'
  );
END;
$function$
```

### Étape 6 : Composant Formulaire Principal

**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/FormReseauCreation.tsx`

```typescript
import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { ArrowLeft, Building, User, Loader2 } from "lucide-react";
import { useReseauCreation } from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/useReseauCreation";
import type { ReseauCreationData, ReseauValidationErrors } from "@/components/HOOKS-STRATEGIQUE/5.HOOKS-CreationCompteAdminPresenca/1.Reseau/types";
import SuccessAccountInfo from "./SuccessAccountInfo";

interface FormReseauCreationProps {
  onBack: () => void;
}

export default function FormReseauCreation({ onBack }: FormReseauCreationProps) {
  const { createReseau, isLoading, error } = useReseauCreation();
  const [successData, setSuccessData] = useState<{ email: string; tempPassword: string } | null>(null);

  const [formData, setFormData] = useState<ReseauCreationData>({
    nomReseau: "",
    adresse: "",
    codePostal: "",
    ville: "",
    siret: "",
    nomResponsable: "",
    prenomResponsable: "",
    emailResponsable: "",
    telephoneResponsable: "",
  });

  const [errors, setErrors] = useState<ReseauValidationErrors>({});

  const updateFormData = (field: keyof ReseauCreationData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  const validateForm = (): boolean => {
    const newErrors: ReseauValidationErrors = {};

    if (!formData.nomReseau.trim()) newErrors.nomReseau = "Le nom du réseau est requis";
    if (!formData.adresse.trim()) newErrors.adresse = "L'adresse est requise";
    if (!formData.codePostal.trim()) newErrors.codePostal = "Le code postal est requis";
    if (!formData.ville.trim()) newErrors.ville = "La ville est requise";
    if (!formData.siret.trim()) newErrors.siret = "Le SIRET est requis";
    if (!formData.nomResponsable.trim()) newErrors.nomResponsable = "Le nom du responsable est requis";
    if (!formData.prenomResponsable.trim()) newErrors.prenomResponsable = "Le prénom du responsable est requis";
    if (!formData.emailResponsable.trim()) newErrors.emailResponsable = "L'email du responsable est requis";
    if (!formData.telephoneResponsable.trim()) newErrors.telephoneResponsable = "Le téléphone du responsable est requis";

    if (formData.emailResponsable && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.emailResponsable)) {
      newErrors.emailResponsable = "Format d'email invalide";
    }

    if (formData.siret && formData.siret.length !== 14) {
      newErrors.siret = "Le SIRET doit contenir 14 chiffres";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    console.log('📋 Soumission formulaire réseau:', formData);
    
    const result = await createReseau(formData);
    
    if (result) {
      console.log('✅ Réseau créé avec succès:', result);
      setSuccessData({
        email: result.email,
        tempPassword: result.tempPassword
      });
    }
  };

  // Afficher le succès si on a les données
  if (successData) {
    return <SuccessAccountInfo email={successData.email} tempPassword={successData.tempPassword} />;
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="mb-6">
        <Button variant="outline" onClick={onBack} className="mb-4">
          <ArrowLeft className="h-4 w-4 mr-2" />
          Retour
        </Button>
        
        <div className="flex items-center gap-3 mb-6">
          <Building className="h-6 w-6 text-primary" />
          <h1 className="text-2xl font-bold">Création d'un compte Réseau</h1>
        </div>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Informations du réseau */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Building className="h-5 w-5" />
              Informations du réseau
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="nomReseau">Nom du réseau *</Label>
                <Input
                  id="nomReseau"
                  value={formData.nomReseau}
                  onChange={(e) => updateFormData("nomReseau", e.target.value)}
                  placeholder="Nom du réseau"
                />
                {errors.nomReseau && <p className="text-sm text-red-500 mt-1">{errors.nomReseau}</p>}
              </div>
              
              <div>
                <Label htmlFor="siret">SIRET *</Label>
                <Input
                  id="siret"
                  value={formData.siret}
                  onChange={(e) => updateFormData("siret", e.target.value)}
                  placeholder="12345678901234"
                  maxLength={14}
                />
                {errors.siret && <p className="text-sm text-red-500 mt-1">{errors.siret}</p>}
              </div>
            </div>

            <div>
              <Label htmlFor="adresse">Adresse *</Label>
              <Input
                id="adresse"
                value={formData.adresse}
                onChange={(e) => updateFormData("adresse", e.target.value)}
                placeholder="Adresse complète"
              />
              {errors.adresse && <p className="text-sm text-red-500 mt-1">{errors.adresse}</p>}
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="ville">Ville *</Label>
                <Input
                  id="ville"
                  value={formData.ville}
                  onChange={(e) => updateFormData("ville", e.target.value)}
                  placeholder="Ville"
                />
                {errors.ville && <p className="text-sm text-red-500 mt-1">{errors.ville}</p>}
              </div>
              
              <div>
                <Label htmlFor="codePostal">Code postal *</Label>
                <Input
                  id="codePostal"
                  value={formData.codePostal}
                  onChange={(e) => updateFormData("codePostal", e.target.value)}
                  placeholder="12345"
                  maxLength={5}
                />
                {errors.codePostal && <p className="text-sm text-red-500 mt-1">{errors.codePostal}</p>}
              </div>
            </div>
          </CardContent>
        </Card>

        <Separator />

        {/* Informations du responsable */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <User className="h-5 w-5" />
              Responsable du réseau
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="nomResponsable">Nom *</Label>
                <Input
                  id="nomResponsable"
                  value={formData.nomResponsable}
                  onChange={(e) => updateFormData("nomResponsable", e.target.value)}
                  placeholder="Nom du responsable"
                />
                {errors.nomResponsable && <p className="text-sm text-red-500 mt-1">{errors.nomResponsable}</p>}
              </div>
              
              <div>
                <Label htmlFor="prenomResponsable">Prénom *</Label>
                <Input
                  id="prenomResponsable"
                  value={formData.prenomResponsable}
                  onChange={(e) => updateFormData("prenomResponsable", e.target.value)}
                  placeholder="Prénom du responsable"
                />
                {errors.prenomResponsable && <p className="text-sm text-red-500 mt-1">{errors.prenomResponsable}</p>}
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="emailResponsable">Email *</Label>
                <Input
                  id="emailResponsable"
                  type="email"
                  value={formData.emailResponsable}
                  onChange={(e) => updateFormData("emailResponsable", e.target.value)}
                  placeholder="email@exemple.fr"
                />
                {errors.emailResponsable && <p className="text-sm text-red-500 mt-1">{errors.emailResponsable}</p>}
              </div>
              
              <div>
                <Label htmlFor="telephoneResponsable">Téléphone *</Label>
                <Input
                  id="telephoneResponsable"
                  value={formData.telephoneResponsable}
                  onChange={(e) => updateFormData("telephoneResponsable", e.target.value)}
                  placeholder="0123456789"
                />
                {errors.telephoneResponsable && <p className="text-sm text-red-500 mt-1">{errors.telephoneResponsable}</p>}
              </div>
            </div>
          </CardContent>
        </Card>

        {error && (
          <div className="p-4 bg-red-50 border border-red-200 rounded-md">
            <p className="text-sm text-red-600">{error}</p>
          </div>
        )}

        <div className="flex justify-end gap-4">
          <Button type="button" variant="outline" onClick={onBack}>
            Annuler
          </Button>
          <Button type="submit" disabled={isLoading}>
            {isLoading ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Création en cours...
              </>
            ) : (
              "Créer le réseau"
            )}
          </Button>
        </div>
      </form>
    </div>
  );
}
```

### Étape 7 : Composant d'Affichage du Succès

**Fichier :** `src/components/ADMIN-PRESENCA/9-CreationComptesUtilisateurs/1-Formulaires/1.Reseau/SuccessAccountInfo.tsx`

```typescript
import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Copy, Eye, EyeOff, CheckCircle } from "lucide-react";
import { toast } from "sonner";

interface SuccessAccountInfoProps {
  email: string;
  tempPassword: string;
}

export default function SuccessAccountInfo({ email, tempPassword }: SuccessAccountInfoProps) {
  const [showPassword, setShowPassword] = useState(false);

  const copyToClipboard = async (text: string, label: string) => {
    try {
      await navigator.clipboard.writeText(text);
      toast.success(`${label} copié dans le presse-papiers`);
    } catch (err) {
      toast.error("Erreur lors de la copie");
    }
  };

  return (
    <Card className="mt-6 border-green-200 bg-green-50/50">
      <CardHeader>
        <div className="flex items-center gap-3">
          <CheckCircle className="h-6 w-6 text-green-600" />
          <CardTitle className="text-green-800">Compte créé avec succès</CardTitle>
        </div>
      </CardHeader>

      <CardContent>
        <div className="space-y-4">
          <div className="p-4 bg-white rounded-lg border">
            <h4 className="font-medium text-sm text-gray-700 mb-3">
              Informations de connexion temporaires
            </h4>
            
            <div className="space-y-3">
              {/* Email */}
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                <div>
                  <span className="text-sm font-medium text-gray-600">Email :</span>
                  <p className="text-sm text-gray-900">{email}</p>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => copyToClipboard(email, "Email")}
                >
                  <Copy className="h-4 w-4" />
                </Button>
              </div>

              {/* Mot de passe */}
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                <div className="flex-1">
                  <span className="text-sm font-medium text-gray-600">Mot de passe temporaire :</span>
                  <p className="text-sm text-gray-900 font-mono">
                    {showPassword ? tempPassword : "••••••••••••••••"}
                  </p>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setShowPassword(!showPassword)}
                  >
                    {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => copyToClipboard(tempPassword, "Mot de passe")}
                  >
                    <Copy className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </div>

            <div className="mt-4 p-3 bg-blue-50 rounded-md border border-blue-200">
              <p className="text-sm text-blue-800">
                <strong>Important :</strong> Ces informations sont temporaires. L'utilisateur devra 
                changer son mot de passe lors de sa première connexion.
              </p>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```
---
## 🔧 Solutions trouvées | Instructives si des pbls semblables apparaissent sur d'autres formulaires
---

### 1 : Mapping SQL
- Si Email admin mappé incorrectement vers `users.users_email`
- Solution : Correction dans la fonction SQL pour mapper `p_admin_email` vers `users.users_email`
---
### 2 : Erreur CORS .lovable.dev
- Si erreur : "Failed to fetch" sur les domaines `.lovable.dev`
- Solution : Ajout du regex `/^https:\/\/.*\.lovable\.dev$/` dans `cors.ts`
---
### 3 : Foreign Key Constraint
- Si Référence incorrecte `v_utilisateur_id` au lieu de `v_user_id`
- Solution : Correction de `reseau_direction_utilisateur_id` pour utiliser `v_user_id`
---
### 4 : Mapping Edge Function
- Si Hook attendait `data.sqlResult` au lieu de `data.data`
- Solution : Alignement de la structure de données entre Edge Function et Hook
---
---
---
## ✅ Points Importants à Retenir
---
1. **Autonomie des Composants :** Chaque module doit être autonome
2. **Mapping de Données :** Vérifier soigneusement les correspondances
3. **Gestion d'Erreurs :** Rollback automatique en cas d'échec
4. **CORS :** Support complet des domaines Lovable
5. **Types TypeScript :** Cohérence entre tous les fichiers
6. **Validation :** Double validation côté client et serveur
---
## 📋 Checklist de Validation
--
- [ ] Types TypeScript définis et exportés
- [ ] Hook métier autonome et testé
- [ ] Edge Function avec gestion d'erreurs
- [ ] Fonction SQL avec rollback
- [ ] Configuration CORS complète
- [ ] Composants UI avec validation
- [ ] Tests de bout en bout réussis

Cette architecture garantit la modularité, la réutilisabilité et la maintenance pour tous les futurs formulaires de création de comptes.
