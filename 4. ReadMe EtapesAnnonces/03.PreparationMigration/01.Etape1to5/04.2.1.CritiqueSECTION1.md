Je vais te pr√©senter uniquement les **3 erreurs r√©elles** identifi√©es dans le document `SECTION 1 - FONDATIONS SQL.md` sous forme de tableau structur√©.

# üìã TABLEAU DES ERREURS R√âELLES IDENTIFI√âES

| **ERREUR** | **EMPLACEMENT** | **POURQUOI C'EST UNE ERREUR** | **JUSTIFICATION PAR √âL√âMENTS DE L'APPLICATION** | **SOLUTION PROPOS√âE** |
|------------|-----------------|-------------------------------|------------------------------------------------|----------------------|
| **1. Erreur de syntaxe SQL dans le trigger** | Ligne 129-141 du documentTrigger `populate_analytical_fields_etapes1to5` | La syntaxe `CASE WHEN 'reseau', 'reseau_direction' THEN` est **invalide en PostgreSQL**.PostgreSQL attend soit:- `WHEN condition THEN`- `WHEN value IN (list) THEN` | - Le trigger doit identifier le `utilisateur_type_compte` pour peupler `is_reseau`, `is_reseau_agence`, `is_agence_indep`- La table `utilisateurs` contient le champ `utilisateur_type_compte` (cf. `3.utilisateurs.md`)- Les valeurs possibles sont d√©finies dans le CHECK constraint: `'reseau', 'reseau_direction', 'reseau_agence', ...` | Remplacer:`CASE WHEN 'reseau', 'reseau_direction' THEN`Par:`CASE WHEN NEW.utilisateur_type_compte IN ('reseau', 'reseau_direction') THEN` |
| **2. Fonction `get_user_reseau_agence_id()` incompl√®te** | Ligne 90-94 du document<br>Fonction SQL | La fonction cherche uniquement dans `reseau_agence` et `reseau_agence_responsable`, mais **omet `reseau_agence_collaborateur`**.<br>Or un collaborateur appartient aussi √† une agence r√©seau.<br>‚ö†Ô∏è **Nuance valid√©e par OpenAI**: Le `LIMIT 1` est essentiel pour √©viter tout doublon[^1]. | - La table `reseau_agence_collaborateur` existe (visible dans schema Supabase)<br>- Elle contient le champ `reseau_agence_id` (FK vers `reseau_agence`)<br>- Un utilisateur de type `reseau_agence_collaborateur` doit pouvoir √™tre associ√© √† son agence<br>- La fonction `user_belongs_to_reseau_agence()` (lignes 109-120) inclut correctement les 3 tables<br>- Un utilisateur ne peut avoir qu'un seul `utilisateur_type_compte` (exclusivit√© garantie) | **Fonction SQL compl√®te corrig√©e:**<br>```sql<br>CREATE OR REPLACE FUNCTION get_user_reseau_agence_id(user_uuid UUID)<br>RETURNS UUID<br>LANGUAGE sql<br>STABLE<br>SECURITY DEFINER<br>SET search_path TO 'public'<br>AS $$<br>  SELECT reseau_agence_id FROM (<br>    SELECT ra.reseau_agence_id<br>    FROM reseau_agence ra<br>    JOIN users u ON u.users_id = ra.reseau_agence_utilisateur_id<br>    WHERE u.users_auth_id = user_uuid<br><br>    UNION ALL<br><br>    SELECT rar.reseau_agence_id<br>    FROM reseau_agence_responsable rar<br>    JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id<br>    WHERE u.users_auth_id = user_uuid<br><br>    UNION ALL<br><br>    SELECT rac.reseau_agence_id<br>    FROM reseau_agence_collaborateur rac<br>    JOIN users u ON u.users_id = rac.reseau_agence_collaborateur_utilisateur_id<br>    WHERE u.users_auth_id = user_uuid<br>  ) AS combined<br>  LIMIT 1;<br>$$;<br>``` |
| **3. RLS policies incompl√®tes pour visibilit√© hi√©rarchique** | Ligne 175-194 du document<br>Policies `etapes1to5_select_own_organisation` et `etapes1to5_collaborator_own_data` | Les policies actuelles ne permettent **PAS** aux responsables de voir les projets des collaborateurs.<br><br>Violation des r√®gles m√©tier:<br>- `reseau_agence_responsable` ne peut pas voir les projets de `reseau_agence_collaborateur`<br>- `agence_independante_responsable` ne peut pas voir les projets de `agence_independante_collaborateur` | - Document `02.1.GestionStrategieMultiTenant.md` (lignes 13-29) d√©finit clairement:<br>  * `reseau_agence_responsable` ‚Üí voit `reseau_agence` + `responsable` + `collaborateur`<br>  * `agence_independante_responsable` ‚Üí voit `agence_independante` + `responsable` + `collaborateur`<br>- Les collaborateurs voient uniquement leurs propres projets<br>- La policy actuelle isole strictement par `user_id`, sans logique hi√©rarchique | **‚ùå Solution initiale erron√©e** : acc√®s √† toute l'organisation (trop large)<br><br>**‚úÖ Solution correcte[^2]** : Visibilit√© strictement limit√©e √† l'agence + hi√©rarchie interne<br><br>```sql<br>CREATE POLICY "etapes1to5_hierarchical_visibility"<br>ON etapes_1to5<br>FOR SELECT<br>USING (<br>  CASE get_user_type_compte(auth.uid())<br><br>    -- R√©seau et direction : projets internes uniquement<br>    WHEN 'reseau', 'reseau_direction' THEN<br>      utilisateur_type_compte IN ('reseau', 'reseau_direction')<br><br>    -- Agence r√©seau (et responsable) : agence + collaborateurs<br>    WHEN 'reseau_agence', 'reseau_agence_responsable' THEN<br>      reseau_agence_id = get_user_reseau_agence_id(auth.uid())<br>      AND utilisateur_type_compte IN (<br>        'reseau_agence',<br>        'reseau_agence_responsable',<br>        'reseau_agence_collaborateur'<br>      )<br><br>    -- Collaborateur agence r√©seau : uniquement ses projets<br>    WHEN 'reseau_agence_collaborateur' THEN<br>      user_id = (<br>        SELECT users_id FROM users WHERE users_auth_id = auth.uid()<br>      )<br><br>    -- Agence ind√©p. (et responsable) : agence + collaborateurs<br>    WHEN 'agence_independante', 'agence_independante_responsable' THEN<br>      agence_indep_id = get_user_agence_indep_id(auth.uid())<br>      AND utilisateur_type_compte IN (<br>        'agence_independante',<br>        'agence_independante_responsable',<br>        'agence_independante_collaborateur'<br>      )<br><br>    -- Collaborateur agence ind√©p. : uniquement ses projets<br>    WHEN 'agence_independante_collaborateur' THEN<br>      user_id = (<br>        SELECT users_id FROM users WHERE users_auth_id = auth.uid()<br>      )<br><br>    ELSE false<br>  END<br>);<br>``` |
---

# üìå NOTES IMPORTANTES

## CRITIQUE 2
**¬π LIMIT 1 dans `get_user_reseau_agence_id()`** : 
- S√©curit√© d√©fensive contre d'√©ventuelles incoh√©rences de donn√©es (ex: un utilisateur inscrit dans 2 tables par erreur)
- Bien que `utilisateur_type_compte` garantisse l'exclusivit√© des r√¥les, le `LIMIT 1` assure qu'une seule valeur sera toujours retourn√©e
- Align√© sur la fonction similaire `get_user_agence_indep_id()` qui suit le m√™me pattern
- Valid√© par OpenAI comme bonne pratique de programmation d√©fensive ‚úÖ

**Pourquoi `LIMIT 1` est n√©cessaire** : 
- Bien que le syst√®me garantisse qu'un utilisateur ne peut avoir qu'un seul `utilisateur_type_compte` (donc √™tre pr√©sent dans une seule des 3 tables),
- le `LIMIT 1` est une **s√©curit√© d√©fensive** contre d'√©ventuelles incoh√©rences de donn√©es
- (ex: utilisateur cr√©√© deux fois par erreur, migration partielle, etc.).
- Cette pr√©caution √©vite qu'une requ√™te √©choue ou renvoie plusieurs lignes en cas d'anomalie dans les donn√©es.

Remplacer la fonction par cette version compl√®te incluant les 3 types d'utilisateurs + s√©curit√© anti-doublon :
```sql
CREATE OR REPLACE FUNCTION get_user_reseau_agence_id(user_uuid UUID)
RETURNS UUID 
LANGUAGE sql 
STABLE 
SECURITY DEFINER
SET search_path TO 'public'
AS $$
  SELECT reseau_agence_id FROM (
    SELECT ra.reseau_agence_id
    FROM reseau_agence ra
    JOIN users u ON u.users_id = ra.reseau_agence_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rar.reseau_agence_id
    FROM reseau_agence_responsable rar
    JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rac.reseau_agence_id
    FROM reseau_agence_collaborateur rac
    JOIN users u ON u.users_id = rac.reseau_agence_collaborateur_utilisateur_id
    WHERE u.users_auth_id = user_uuid
  ) AS combined
  LIMIT 1;
$$;
```
---

## CRITIQUE 3
- **Pourquoi la solution initiale √©tait erron√©e** :
  - La policy propos√©e initialement (`organisation_id = get_user_organisation_id(auth.uid())`) accordait aux responsables une visibilit√© sur **tous les projets de l'organisation**,
  - y compris ceux d'autres agences du m√™me r√©seau. Cela violait l'isolation multi-tenant au niveau agence.
    - **Solution corrig√©e** :
    - La visibilit√© hi√©rarchique s'applique d√©sormais **strictement √† l'√©chelle de l'agence**
      - (`reseau_agence_id` ou `agence_indep_id`),
      - respectant ainsi la r√®gle m√©tier :
    - un responsable d'agence voit les projets de son agence et de ses collaborateurs,
    - mais **pas** ceux des autres agences du r√©seau.
    - Le r√©seau et sa direction ne voient que leurs projets internes, par respect de la confidentialit√© des agences.
---

---

# ‚úÖ NOUVELLES OORRECTIONS 
| Point | Probl√®me identifi√© | Solution valid√©e | Justification m√©tier |
|-------|-------------------|------------------|---------------------|
| **1. Trigger `updated_at`** | `AFTER UPDATE` ‚Üí la valeur n'est pas enregistr√©e dans la m√™me transaction | ‚úÖ `BEFORE UPDATE` | Garantit la coh√©rence temporelle imm√©diate et la fiabilit√© des hooks Supabase |
| **2. FK `user_id`** | Cascade de suppression non d√©finie | ‚úÖ `ON DELETE SET NULL` + champ `deleted_user_email` optionnel | Les projets appartiennent √† l'agence/r√©seau, pas √† la personne. Ils doivent survivre au d√©part d'un collaborateur |
| **3. FK `organisation_id`** | - | ‚úÖ D√©j√† conforme (`ON DELETE CASCADE`) | La suppression d'une organisation supprime toutes ses donn√©es (isolation multi-tenant) |

---

## üìù Corrections √† appliquer dans `04.1.SECTION 1 - FONDATIONS SQL.md`

### üîß **Correction 1 : Trigger `updated_at`** (Ligne ~236)

**‚ùå Version actuelle (incorrecte) :**
```sql
CREATE TRIGGER set_updated_at_etapes1to5
AFTER UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

**‚úÖ Version corrig√©e :**
```sql
CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

---

### üîß **Correction 2 : FK `user_id`** (Ligne ~165)

**‚ùå Version actuelle (manque la clause `ON DELETE`) :**
```sql
user_id UUID NOT NULL
  REFERENCES users(users_id),
```

**‚úÖ Version corrig√©e :**
```sql
user_id UUID NOT NULL
  REFERENCES users(users_id) ON DELETE SET NULL,
```

**‚ö†Ô∏è Ajustement n√©cessaire :** 
- Le champ `user_id` doit √©galement **passer en `NULL` autoris√©** :
```sql
user_id UUID
  REFERENCES users(users_id) ON DELETE SET NULL,
```

**üÜï Ajout optionnel (tra√ßabilit√©) :**
```sql
deleted_user_email TEXT,
```
‚Üí Permet de conserver l'email du cr√©ateur m√™me si son compte est supprim√©.

---

## üìÑ Fichier de critique `041.2.CritiqueSECTION1-Triggers.md`

Je te propose de cr√©er ce fichier pour **documenter ces deux ajustements techniques** et les archiver proprement.

**Contenu propos√© :**

```markdown
# üîç Critique Technique SECTION 1 - Triggers & Contraintes FK

**Document source** : `04.1.SECTION 1 - FONDATIONS SQL.md`  
**Date de critique** : 31/10/2025  
**Valid√© par** : OpenAI + Lovable IA  

---

## üéØ R√©sum√© des corrections valid√©es

| # | √âl√©ment | Probl√®me | Solution | Statut |
|---|---------|----------|----------|--------|
| 1 | Trigger `updated_at` | `AFTER UPDATE` ‚Üí valeur non enregistr√©e dans la transaction | `BEFORE UPDATE` | ‚úÖ Corrig√© |
| 2 | FK `user_id` | Absence de clause `ON DELETE` | `ON DELETE SET NULL` + champ optionnel `deleted_user_email` | ‚úÖ Corrig√© |
| 3 | FK `organisation_id` | - | `ON DELETE CASCADE` (d√©j√† conforme) | ‚úÖ OK |

---

## üîß Correction 1 : Trigger `updated_at`

### Probl√®me
Le trigger √©tait d√©fini en `AFTER UPDATE`, ce qui emp√™chait la mise √† jour imm√©diate de `updated_at` dans la m√™me transaction.

### Cons√©quence
- Perte d'une it√©ration dans les audits de synchronisation
- Incoh√©rence temporelle pour les hooks Supabase

### Solution
```sql
CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

---

## üîß Correction 2 : FK `user_id` - Logique m√©tier

### Probl√®me
En cas de suppression d'un utilisateur, les projets associ√©s seraient orphelins (erreur d'int√©grit√©) ou supprim√©s (perte de donn√©es).

### D√©cision m√©tier
**Les projets appartiennent √† l'agence/r√©seau, pas √† la personne.**  
‚Üí Un collaborateur qui quitte l'agence ne doit pas emporter ses projets avec lui.

### Solution
1. **FK avec `ON DELETE SET NULL`** :
```sql
user_id UUID
  REFERENCES users(users_id) ON DELETE SET NULL,
```

2. **Champ de tra√ßabilit√© optionnel** :
```sql
deleted_user_email TEXT,
```
‚Üí Permet de conserver l'email du cr√©ateur initial m√™me si son compte est supprim√©.

---

## ‚úÖ FK `organisation_id` - D√©j√† conforme

La contrainte existante est correcte :
```sql
organisation_id UUID NOT NULL
  REFERENCES organisations(organisation_id) ON DELETE CASCADE,
```

**Justification** : La suppression d'une organisation doit supprimer toutes ses donn√©es (isolation multi-tenant stricte).

---

## üìå Actions √† r√©aliser

- [x] Valider les corrections avec OpenAI
- [ ] Mettre √† jour `04.1.SECTION 1 - FONDATIONS SQL.md`
- [ ] Tester les contraintes FK en environnement de d√©veloppement
- [ ] V√©rifier la coh√©rence avec les hooks Supabase existants
```

---

---
---
---
---
---
# üß± SECTION 1 - FONDATIONS SQL (VERSION CORRIG√âE)

## üéØ Objectif du document
Document pr√©paratoire de la **Phase 1 Migration LocalStorage ‚Üí Supabase** pour la table `etapes_1to5`.
Ce document n‚Äôest **pas un script SQL ex√©cutif**, mais une **r√©f√©rence structur√©e** pour guider la cr√©ation finale.

---

## üìå Contexte g√©n√©ral
- Migration des **14 champs `propertyData`** collect√©s dans les √©tapes 1 √† 4 vers Supabase.
- Conservation de la logique multi-tenant : chaque enregistrement rattach√© √† `organisation_id` et `user_id`.
- Gestion stricte des conventions :
  - **camelCase** pour les champs m√©tier.
  - **snake_case** pour les champs syst√®me Supabase.

---

## ‚öôÔ∏è Structure g√©n√©rale de la table `etapes_1to5`

| Colonne | Type SQL | Contraintes | Notes |
|----------|-----------|--------------|--------|
| `id` | UUID | PK, DEFAULT gen_random_uuid() | Identifiant unique du projet |
| `organisation_id` | UUID | FK organisations(organisation_id) **ON DELETE CASCADE** | Supprime tous les projets li√©s √† une organisation supprim√©e |
| `user_id` | UUID | FK users(users_id) **ON DELETE SET NULL** | Conserve les projets si un collaborateur quitte l‚Äôagence |
| `utilisateur_type_compte` | TEXT | CHECK (valeurs autoris√©es) | Type de compte actuel |
| `reseau_agence_id` | UUID | FK reseau_agence(reseau_agence_id) ON DELETE SET NULL | Lien analytique agence r√©seau |
| `agence_indep_id` | UUID | FK agence_independante(agence_indep_id) ON DELETE SET NULL | Lien analytique agence ind√©pendante |
| `step_progress` | INTEGER[] | CHECK (array_length ‚â•1 et valeurs ‚àà {1..5}) | Liste cumulative des √©tapes valid√©es |
| `statut` | TEXT | CHECK ('en_cours','archive') | D√©fini automatiquement par trigger |
| `validated_at` | timestamptz | NULL par d√©faut | Renseign√© automatiquement lors de la validation √©tape 5 |
| `created_at` | timestamptz | DEFAULT now() | Cr√©ation du projet |
| `updated_at` | timestamptz | DEFAULT now(), trigger auto | Derni√®re mise √† jour |

---

## üîÑ Triggers

### 1Ô∏è‚É£ `set_updated_at_etapes1to5`
**Correction appliqu√©e : `BEFORE UPDATE` (au lieu de AFTER)**

```sql
CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

üîπ Permet de mettre √† jour `updated_at` dans la m√™me transaction.
üîπ Garantit la coh√©rence temporelle et la fiabilit√© des hooks Supabase.

---

### 2Ô∏è‚É£ `statut_du_projet`
```sql
CREATE TRIGGER statut_du_projet
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
WHEN (NEW.validated_at IS NOT NULL AND 5 = ANY(NEW.step_progress))
EXECUTE FUNCTION set_statut_archive();
```
- Passe automatiquement `statut` √† `'archive'` lors de la validation finale (√©tape 5).

---

## üîç Fonctions Multi-tenant

### ‚úÖ `get_user_reseau_agence_id()` (corrig√©e)
Inclut d√©sormais les **3 types d‚Äôutilisateurs** + protection contre doublons (`LIMIT 1`).

```sql
CREATE OR REPLACE FUNCTION get_user_reseau_agence_id(user_uuid UUID)
RETURNS UUID AS $$
  SELECT reseau_agence_id FROM (
    SELECT ra.reseau_agence_id
    FROM reseau_agence ra
    JOIN users u ON u.users_id = ra.reseau_agence_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rar.reseau_agence_id
    FROM reseau_agence_responsable rar
    JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rac.reseau_agence_id
    FROM reseau_agence_collaborateur rac
    JOIN users u ON u.users_id = rac.reseau_agence_collaborateur_utilisateur_id
    WHERE u.users_auth_id = user_uuid
  ) AS combined
  LIMIT 1;
$$ LANGUAGE sql STABLE SECURITY DEFINER;
```

### ‚úÖ `get_user_agence_indep_id()`
(Structure similaire, inchang√©e ‚Äî d√©j√† correcte.)

---

## üîê RLS Policies ‚Äì Visibilit√© hi√©rarchique corrig√©e

### 1Ô∏è‚É£ SELECT ‚Äì Visibilit√©
```sql
CREATE POLICY etapes_1to5_select_hierarchical
ON public.etapes_1to5
FOR SELECT
TO authenticated
USING (
  CASE get_user_type_compte(auth.uid())

    -- R√©seau / Direction r√©seau : uniquement leurs projets internes
    WHEN 'reseau', 'reseau_direction' THEN
      utilisateur_type_compte IN ('reseau', 'reseau_direction')

    -- Agence r√©seau (et responsable)
    WHEN 'reseau_agence', 'reseau_agence_responsable' THEN
      reseau_agence_id = get_user_reseau_agence_id(auth.uid())
      AND utilisateur_type_compte IN ('reseau_agence', 'reseau_agence_responsable', 'reseau_agence_collaborateur')

    -- Collaborateur agence r√©seau : ses propres projets
    WHEN 'reseau_agence_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    -- Agence ind√©pendante (et responsable)
    WHEN 'agence_independante', 'agence_independante_responsable' THEN
      agence_indep_id = get_user_agence_indep_id(auth.uid())
      AND utilisateur_type_compte IN ('agence_independante', 'agence_independante_responsable', 'agence_independante_collaborateur')

    -- Collaborateur agence ind√©pendante : ses projets uniquement
    WHEN 'agence_independante_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    ELSE false
  END
);
```

### 2Ô∏è‚É£ INSERT
```sql
CREATE POLICY etapes_1to5_insert_own
ON public.etapes_1to5
FOR INSERT
TO authenticated
WITH CHECK (
  organisation_id = get_user_organisation_id(auth.uid())
  AND user_id IN (SELECT users_id FROM users WHERE users_auth_id = auth.uid())
  AND utilisateur_type_compte = get_user_type_compte(auth.uid())
);
```

### 3Ô∏è‚É£ UPDATE
M√™mes conditions hi√©rarchiques que SELECT (ajuster selon r√¥le).

### 4Ô∏è‚É£ DELETE
Conserv√©e telle quelle : suppression r√©serv√©e √† `admin_presenca` ou au cr√©ateur du projet.

---

## ‚öôÔ∏è Contraintes sp√©cifiques

| Champ | Contrainte | Raison |
|--------|-------------|---------|
| `utilisateur_type_compte` | CHECK avec 8 r√¥les d√©finis | Coh√©rence multi-tenant |
| `price` / `rentAmount` | CHECK selon `saleType` | Validation conditionnelle |
| `hasNoDetails` | CHECK coh√©rente avec `details` | Emp√™che les √©tats contradictoires |
| `step_progress` | CHECK non r√©gressif | Garantit une progression s√©quentielle |

---

## ‚úÖ Synth√®se des corrections valid√©es
| √âl√©ment | Ancienne version | Nouvelle version |
|----------|------------------|------------------|
| Trigger `updated_at` | AFTER UPDATE | BEFORE UPDATE ‚úÖ |
| FK `organisation_id` | sans CASCADE | ON DELETE CASCADE ‚úÖ |
| FK `user_id` | CASCADE | ON DELETE SET NULL ‚úÖ |
| get_user_reseau_agence_id() | 2 tables | 3 tables + LIMIT 1 ‚úÖ |
| Policies RLS | hi√©rarchie incompl√®te | hi√©rarchie compl√®te et cloisonn√©e ‚úÖ |
| Fonction Timer | active (ancienne doc) | d√©sactiv√©e üö´ |

---

# üß± SECTION 1 - FONDATIONS SQL (VERSION CORRIG√âE)

## üéØ Objectif du document
Document pr√©paratoire de la **Phase 1 Migration LocalStorage ‚Üí Supabase** pour la table `etapes_1to5`.
Ce document n‚Äôest **pas un script SQL ex√©cutif**, mais une **r√©f√©rence structur√©e** pour guider la cr√©ation finale.

---

## üìå Contexte g√©n√©ral
- Migration des **14 champs `propertyData`** collect√©s dans les √©tapes 1 √† 4 vers Supabase.
- Conservation de la logique multi-tenant : chaque enregistrement rattach√© √† `organisation_id` et `user_id`.
- Gestion stricte des conventions :
  - **camelCase** pour les champs m√©tier.
  - **snake_case** pour les champs syst√®me Supabase.

---

## ‚öôÔ∏è Structure g√©n√©rale de la table `etapes_1to5`

| Colonne | Type SQL | Contraintes | Notes |
|----------|-----------|--------------|--------|
| `id` | UUID | PK, DEFAULT gen_random_uuid() | Identifiant unique du projet |
| `organisation_id` | UUID | FK organisations(organisation_id) **ON DELETE CASCADE** | Supprime tous les projets li√©s √† une organisation supprim√©e |
| `user_id` | UUID | FK users(users_id) **ON DELETE SET NULL** | Conserve les projets si un collaborateur quitte l‚Äôagence |
| `utilisateur_type_compte` | TEXT | CHECK (valeurs autoris√©es) | Type de compte actuel |
| `reseau_agence_id` | UUID | FK reseau_agence(reseau_agence_id) ON DELETE SET NULL | Lien analytique agence r√©seau |
| `agence_indep_id` | UUID | FK agence_independante(agence_indep_id) ON DELETE SET NULL | Lien analytique agence ind√©pendante |
| `step_progress` | INTEGER[] | CHECK (array_length ‚â•1 et valeurs ‚àà {1..5}) | Liste cumulative des √©tapes valid√©es |
| `statut` | TEXT | CHECK ('en_cours','archive') | D√©fini automatiquement par trigger |
| `validated_at` | timestamptz | NULL par d√©faut | Renseign√© automatiquement lors de la validation √©tape 5 |
| `created_at` | timestamptz | DEFAULT now() | Cr√©ation du projet |
| `updated_at` | timestamptz | DEFAULT now(), trigger auto | Derni√®re mise √† jour |

---

## üîÑ Triggers

### 1Ô∏è‚É£ `set_updated_at_etapes1to5`
**Correction appliqu√©e : `BEFORE UPDATE` (au lieu de AFTER)**

```sql
CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
```

üîπ Permet de mettre √† jour `updated_at` dans la m√™me transaction.
üîπ Garantit la coh√©rence temporelle et la fiabilit√© des hooks Supabase.

---

### 2Ô∏è‚É£ `statut_du_projet`
```sql
CREATE TRIGGER statut_du_projet
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
WHEN (NEW.validated_at IS NOT NULL AND 5 = ANY(NEW.step_progress))
EXECUTE FUNCTION set_statut_archive();
```
- Passe automatiquement `statut` √† `'archive'` lors de la validation finale (√©tape 5).

---

## üîç Fonctions Multi-tenant

### ‚úÖ `get_user_reseau_agence_id()` (corrig√©e)
Inclut d√©sormais les **3 types d‚Äôutilisateurs** + protection contre doublons (`LIMIT 1`).

```sql
CREATE OR REPLACE FUNCTION get_user_reseau_agence_id(user_uuid UUID)
RETURNS UUID AS $$
  SELECT reseau_agence_id FROM (
    SELECT ra.reseau_agence_id
    FROM reseau_agence ra
    JOIN users u ON u.users_id = ra.reseau_agence_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rar.reseau_agence_id
    FROM reseau_agence_responsable rar
    JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id
    WHERE u.users_auth_id = user_uuid

    UNION ALL

    SELECT rac.reseau_agence_id
    FROM reseau_agence_collaborateur rac
    JOIN users u ON u.users_id = rac.reseau_agence_collaborateur_utilisateur_id
    WHERE u.users_auth_id = user_uuid
  ) AS combined
  LIMIT 1;
$$ LANGUAGE sql STABLE SECURITY DEFINER;
```

### ‚úÖ `get_user_agence_indep_id()`
(Structure similaire, inchang√©e ‚Äî d√©j√† correcte.)

---

## üîê RLS Policies ‚Äì Visibilit√© hi√©rarchique corrig√©e

### 1Ô∏è‚É£ SELECT ‚Äì Visibilit√©
```sql
CREATE POLICY etapes_1to5_select_hierarchical
ON public.etapes_1to5
FOR SELECT
TO authenticated
USING (
  CASE get_user_type_compte(auth.uid())

    -- R√©seau / Direction r√©seau : uniquement leurs projets internes
    WHEN 'reseau', 'reseau_direction' THEN
      utilisateur_type_compte IN ('reseau', 'reseau_direction')

    -- Agence r√©seau (et responsable)
    WHEN 'reseau_agence', 'reseau_agence_responsable' THEN
      reseau_agence_id = get_user_reseau_agence_id(auth.uid())
      AND utilisateur_type_compte IN ('reseau_agence', 'reseau_agence_responsable', 'reseau_agence_collaborateur')

    -- Collaborateur agence r√©seau : ses propres projets
    WHEN 'reseau_agence_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    -- Agence ind√©pendante (et responsable)
    WHEN 'agence_independante', 'agence_independante_responsable' THEN
      agence_indep_id = get_user_agence_indep_id(auth.uid())
      AND utilisateur_type_compte IN ('agence_independante', 'agence_independante_responsable', 'agence_independante_collaborateur')

    -- Collaborateur agence ind√©pendante : ses projets uniquement
    WHEN 'agence_independante_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    ELSE false
  END
);
```

### 2Ô∏è‚É£ INSERT
```sql
CREATE POLICY etapes_1to5_insert_own
ON public.etapes_1to5
FOR INSERT
TO authenticated
WITH CHECK (
  organisation_id = get_user_organisation_id(auth.uid())
  AND user_id IN (SELECT users_id FROM users WHERE users_auth_id = auth.uid())
  AND utilisateur_type_compte = get_user_type_compte(auth.uid())
);
```

### 3Ô∏è‚É£ UPDATE
M√™mes conditions hi√©rarchiques que SELECT (ajuster selon r√¥le).

### 4Ô∏è‚É£ DELETE
Conserv√©e telle quelle : suppression r√©serv√©e √† `admin_presenca` ou au cr√©ateur du projet.

---

## ‚öôÔ∏è Contraintes sp√©cifiques

| Champ | Contrainte | Raison |
|--------|-------------|---------|
| `utilisateur_type_compte` | CHECK avec 8 r√¥les d√©finis | Coh√©rence multi-tenant |
| `price` / `rentAmount` | CHECK selon `saleType` | Validation conditionnelle |
| `hasNoDetails` | CHECK coh√©rente avec `details` | Emp√™che les √©tats contradictoires |
| `step_progress` | CHECK non r√©gressif | Garantit une progression s√©quentielle |

---

## üö´ Fonction Timer
La fonction timer mentionn√©e dans les documents initiaux est **d√©sactiv√©e** et **non int√©gr√©e** √† la migration. 
Elle reste en veille, conserv√©e uniquement comme trace documentaire.

---

## ‚úÖ Synth√®se des corrections valid√©es
| √âl√©ment | Ancienne version | Nouvelle version |
|----------|------------------|------------------|
| Trigger `updated_at` | AFTER UPDATE | BEFORE UPDATE ‚úÖ |
| FK `organisation_id` | sans CASCADE | ON DELETE CASCADE ‚úÖ |
| FK `user_id` | CASCADE | ON DELETE SET NULL ‚úÖ |
| get_user_reseau_agence_id() | 2 tables | 3 tables + LIMIT 1 ‚úÖ |
| Policies RLS | hi√©rarchie incompl√®te | hi√©rarchie compl√®te et cloisonn√©e ‚úÖ |
| Fonction Timer | active (ancienne doc) | d√©sactiv√©e üö´ |

---

## üìé Statut du document
**Version valid√©e pour int√©gration Phase 1 ‚Äì Fondations SQL**
- Corrig√©e selon les √©changes Admin Presenca / Lovable / OpenAI (Octobre 2025).
- √Ä utiliser comme base de r√©f√©rence avant la r√©daction du script SQL final.


