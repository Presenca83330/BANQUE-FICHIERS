
# Préparation de la Table : etapes_1to5

## Description générale
- Préparation de la Table de stockage des données collectées lors des **Étapes 1 à 5** du parcours de création d'annonce immobilière.
- Cette table capture les 14 champs `propertyData` avant l'envoi des prompts vers OpenAI (Phase 1).

## Rappel de l'architecture avec CONSERVATION DU NOMMAGE camelCase
- Tous les hooks, fonctions, et interactions Supabase créés lors de la migration
  - DOIVENT IMPERATIVEMETN CONSERVER :
    - la structure camelCase existante pour les champs métier (agencyName, propertyType, saleType, price, rentAmount, rentPeriodicity, keyElements, propertyDescription, financials, details, exclusivite, location, reference).
  - UTILISER snake_case uniquement pour les champs système Supabase (organisation_id, user_id, created_at, updated_at, etc.).
- Cette directive s'applique pour la conception de cette tables

## Ressources obligatoires
- Avant toute création ou modification de champ ou de note de bas de page
- Faire obligatoirement une analyse des fichiers de l'application
- Lire et analyer les audits
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/01.Etape1.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/02.Etape2.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/03.Etape3.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/04.Etape4.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/05.Etape5.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/06.Etape5animation.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/07.BilanEtape1aEtape5.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/08.ProcessEnvoiInfosOpenAI.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1à5/09.ProcessPassageEtapeSuivante.md
---
---
---

# Structure de la table
---

| Table       | Code champ          | Description                            | Obligatoire                   | Facultatif   | Condition de remplissage                                                       | Droits de modification tables   | Droits de modification presenca   | Type SQL    | Clé primaire (PK)   | Clé étrangère (FK)   | Référence vers table   | Contraintes Supabase       | Type d'identifiant   | Actions à prévoir                    |
|:------------|:--------------------|:---------------------------------------|:------------------------------|:-------------|:-------------------------------------------------------------------------------|:--------------------------------|:----------------------------------|:------------|:--------------------|:---------------------|:-----------------------|:---------------------------|:---------------------|:-------------------------------------|
| etapes_1to5 | id                  | Identifiant unique du projet annonce   | Oui                           |              | Auto-généré                                                                    | Lecture seule                   | Lecture seule                     | uuid        | Oui                 |                      |                        | Default: gen_random_uuid() | UUID                 | auto                                 |
| etapes_1to5 | organisation_id     | Identifiant du réseau / agence         | Oui                           |              | Doit correspondre à l'organisation de l'utilisateur                            | Modif admin uniquement          | Non modifiable                    | uuid        |                     | Oui                  | organisations.organisation_id       | FK + ON DELETE CASCADE     | UUID                 | à relier à la structure multi-tenant |
| etapes_1to5 | user_id             | Identifiant de l'utilisateur créateur  | Oui                           |              | Défini automatiquement à la création                                           | Lecture seule                   | Lecture seule                     | uuid        |                     | Oui                  | users.users_id               | FK + ON DELETE CASCADE     | UUID                 | auto                                 |
| etapes_1to5 | step_progress | Liste cumulative des étapes déverrouillées (1 à 5) | Oui |  | Toujours renseigné (valeur par défaut '{1}' à la création) | Lecture seule | Consultation uniquement | integer[] | Non | Non | — | NOT NULL, DEFAULT '{1}'::integer[], CHECK (array_length(step_progress, 1) >= 1 AND 1 = ANY(step_progress) AND step_progress <@ ARRAY[1,2,3,4,5]) | Array | Auto (géré par completeStep) |
| etapes_1to5 | statut | Statut du projet ('en_cours', 'archive') | Oui | | Défini par le système selon progression | Automatique / Admin | Modifiable | text | | | | Default 'en_cours', CHECK (statut IN ('en_cours', 'archive')) | text | Gestion du cycle de vie |
| etapes_1to5 | validated_at        | Date de validation finale avant OpenAI               |                               | Oui          | Renseignée lors de la validation étape 5                                       | Automatique                     | Lecture seule                     | timestamptz |                     |                      |                        | NULL par défaut            | Timestamp            | Trigger auto-set                     |
| etapes_1to5 | logs                | Logs de modifications locales                        |                               | Oui          | Alimentés automatiquement                                                      | Automatique                     | Lecture seule                     | jsonb       |                     |                      |                        | Default '{}'::jsonb                            | JSON                 | optionnel                            |
| etapes_1to5 | created_at          | Date de création                                     | Oui                           |              | Auto                                                                           | Auto                            | Lecture seule                     | timestamptz |                     |                      |                        | Default now()              | Timestamp            | auto                                 |
| etapes_1to5 | updated_at          | Dernière modification                                | Oui                           |              | Auto via trigger                                                               | Auto                            | Lecture seule                     | timestamptz |                     |                      |                        | Trigger set_updated_at()    | Timestamp            | auto                                 |

---

# Champs PropertyData (14 champs métier)

---
| Table        | Code champ          | Description                                               | Obligatoire | Facultatif | Condition de remplissage                        | Droits de modification tables | Droits de modification presenca | Type SQL | Clé primaire (PK) | Clé étrangère (FK) | Référence vers table | Contraintes Supabase             | Type d'identifiant | Actions à prévoir | Étape collecte |
|---------------|--------------------|-----------------------------------------------------------|--------------|-------------|--------------------------------------------------|-------------------------------|----------------------------------|-----------|-------------------|--------------------|-----------------------|----------------------------------|--------------------|------------------|----------------|
| etapes_1to5 | agencyName | Nom de l'agence du créateur de l'annonce | Oui | Non | Aucune (toujours requis à l'étape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL |  |  Migration des données depuis localStorage : Récupération de la clé : propertyData.agencyName | Etape 1   |
| etapes_1to5 | reference | Référence du bien immobilier | Oui | Non | Aucune (toujours requis à l'étape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des données depuis localStorage : Récupération de la clé : propertyData.reference | Étape 1 |
| etapes_1to5 | exclusivite | Exclusivité du mandat (Oui/Non) | Oui | Non | Valeur par défaut "Non" (modifiable par l'utilisateur) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (exclusivite IN ('Oui', 'Non')) | - | Migration des données depuis localStorage : Récupération de la clé : propertyData.exclusivite | Étape 1 |
| etapes_1to5 | location | Emplacement du bien (ville, arrondissement, département) | Oui | Non | Aucune (toujours requis à l'étape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des données depuis `localStorage` : Récupération de la clé `propertyData.location`| Étape 1 |
| etapes_1to5 | propertyType | Type de bien immobilier (Restaurant, Commerce, Local Commercial, Bureau...) | Oui | Non | Aucune (toujours requis à l'étape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des données depuis `localStorage` : Récupération de la clé `propertyData.propertyType` | Étape 1 |
| etapes_1to5 | saleType | Type de transaction (à vendre / à louer) | Oui | Non | Valeur par défaut "à vendre" (modifiable par l'utilisateur) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (saleType IN ('à vendre', 'à louer')) | - | Migration des données depuis `localStorage` : Récupération de la clé `propertyData.saleType` | Étape 1 |
| etapes_1to5 | price | Prix FAI (Frais d'Agence Inclus) en euros | **Conditionnel** | Oui | **Requis uniquement si** `saleType === 'à vendre'`. Vide si `saleType === 'à louer'` | user_id | Oui | **NUMERIC(12,2)** | Non | Non | - | `CHECK ((saleType = 'à vendre' AND price IS NOT NULL AND price >= 0) OR (saleType = 'à louer' AND price IS NULL))` | - | Migration depuis `localStorage` : Récupération `propertyData.price` (format stocké : `"450 000€"` → Parser en nombre via `parseEuroAmount()`) | Étape 1 |
| etapes_1to5 | rentAmount | Montant du loyer HT/HC en euros | **Conditionnel** | Non | **Requis si** `saleType === 'à louer'`**NULL si** `saleType === 'à vendre'` | user_id | Oui | NUMERIC(12,2) | Non | Non | - | `CHECK ((saleType = 'à louer' AND rentAmount IS NOT NULL AND rentAmount >= 0) OR (saleType = 'à vendre' AND rentAmount IS NULL))` | - | Migration depuis `localStorage` : Récupération `propertyData.rentAmount` (format stocké : `"1 200€"` → Parser en nombre via `parseEuroAmount()`) | Étape 1 |
| etapes_1to5 | rentPeriodicity | Périodicité du loyer (Mensuel / Trimestriel / Annuel) | **Conditionnel** | Non | **Requis si** `saleType === 'à louer'`**NULL si** `saleType === 'à vendre'` | user_id | Oui | TEXT | Non | Non | - | `CHECK ((saleType = 'à louer' AND rentPeriodicity IS NOT NULL) OR (saleType = 'à vendre' AND rentPeriodicity IS NULL))`, `CHECK (rentPeriodicity IN ('Mensuel', 'Trimestriel', 'Annuel'))` | - | Migration depuis `localStorage` : Récupération `propertyData.rentPeriodicity` (valeur par défaut : `"Mensuel"`) | Étape 1 |
| etapes_1to5 | keyElements | Arguments commerciaux : points forts du bien (emplacement premium, conditions locatives, potentiel, rareté, etc.) | Oui | Non | Aucune (toujours requis à l'étape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(keyElements) > 0) | - | Migration depuis `localStorage` : Récupération `propertyData.keyElements` | Étape 1 |
| etapes_1to5 | propertyDescription | Description détaillée du bien : emplacement, superficie, activité, clientèle, équipements, ambiance... | Oui | Non | Aucune (toujours requis à l'étape 2) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(propertyDescription) > 0) | - | Migration depuis `localStorage` : Récupération `propertyData.propertyDescription` (format stocké : texte avec puces `• ` en début de ligne + capitalisation automatique) | Étape 2 |
| etapes_1to5 | financials | Informations financières du bien : conditions locatives, performances financières, potentiel de développement | Oui | Non | Aucune (toujours requis à l'étape 3) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(financials) > 0) | - | Migration depuis `localStorage` : Récupération `propertyData.financials` (format stocké : texte avec puces `• ` en début de ligne + capitalisation automatique) | Étape 3 |
| etapes_1to5 | details | Informations complémentaires optionnelles sur le bien (horaires d'ouverture, périodes de fermeture, autres détails d'exploitation) | **Conditionnel** | Oui | **Requis si** `hasNoDetails === false` **ET** utilisateur saisit des informations. **Vide si** `hasNoDetails === true` | user_id | Oui | TEXT | Non | Non | - | `CHECK ((hasNoDetails = false AND length(details) > 0) OR (hasNoDetails = true AND (details IS NULL OR details = '')))` | - | Migration depuis `localStorage` : Récupération `propertyData.details` (format stocké : texte avec puces `• ` en début de ligne + capitalisation automatique) | Étape 4 |
| etapes_1to5 | hasNoDetails | Indicateur booléen : l'utilisateur a coché "Je n'ai pas d'informations complémentaires à fournir" | **Conditionnel** | Oui | **`true` si** checkbox cochée (et `details` devient vide/NULL). **`false` si** utilisateur saisit des informations dans `details` | user_id | Oui | BOOLEAN | Non | Non | - | `NOT NULL, DEFAULT false`, `CHECK ((hasNoDetails = false AND length(details) > 0) OR (hasNoDetails = true AND (details IS NULL OR details = '')))` | - | Migration depuis `localStorage` : Récupération `propertyData.hasNoDetails` (valeur par défaut : `false`) | Étape 4 |
---

## 📌 **Notes explicatives**

### **Champ `statut`**
**Valeurs possibles** : 'en_cours', 'archive'

**Statut du projet**
-  `'en_cours'` (défaut) : Projet actif, en cours de saisie
- `'archive'` : Projet validé et archivé après validation étape 5
  - Transition automatique via trigger Supabase
  - Permettra dans une utilisation future de conserver l'historique des projets finalisés

**Trigger Supabase** :
  - Nom : `statut_du_projet`
  - Déclenchement : `BEFORE UPDATE` sur la table `etapes_1to5`
  - Condition : Si `validated_at IS NOT NULL` ET `5 = ANY(step_progress)`
  - Action : `statut` passe automatiquement de `'en_cours'` à `'archive'`

**Cas d'usage** :
  - Page "Mes projets en cours" : `WHERE statut = 'en_cours'`
  - Page "Historique des annonces" : `WHERE statut = 'archive'`

---

### **Champ `validated_at`**
**Type** : `timestamptz NULL DEFAULT NULL`

**Rôle** : Enregistre la date et l'heure exactes de validation finale (étape 5)

**Valeurs** : `NULL` (non validé) ou timestamp (validé)

**Trigger à créer :**
  - **Nom** : `set_validated_at`
  - **Déclenchement** : `BEFORE UPDATE` sur la table `etapes_1to5`
  - **Condition** : Si `NEW.validated_at IS NOT NULL` AND `OLD.validated_at IS NULL`
  - **Action** : Renseigne automatiquement `validated_at := NOW()`

**Utilisation :**
- Utilisé comme l'une des 2 conditions du trigger `statut_du_projet` (voir section `statut`)
- Permet la traçabilité temporelle de la validation

---
###  **Champ `step_progress`**
- Le champ `step_progress` stocke un **tableau d'entiers non régressif** représentant toutes les étapes déjà déverrouillées par l'utilisateur
- (ex : `{1, 2, 3}` signifie que les étapes 1, 2 et 3 sont accessibles).

**Fonctionnement :**
- **Initialisation** : `{1}` (seule l'étape 1 est accessible)
- **Progression séquentielle** : À chaque validation d'étape, `completeStep(X)` ajoute l'étape suivante (ex : après validation de l'étape 2 → `{1, 2, 3}`)
- **Navigation libre** : L'utilisateur peut naviguer entre toutes les étapes présentes dans `step_progress` sans restriction
- **Non régressif** : Une fois une étape ajoutée, elle reste accessible même si l'utilisateur modifie des données précédentes (via `handleBackToEtape5()`)

**Contrainte CHECK :**
- Le tableau doit **toujours contenir au moins l'étape 1**
- Les valeurs doivent être **comprises entre 1 et 5**
- Empêche les états invalides (ex : `{3, 4}` sans étapes 1 et 2)

**Utilisation applicative :**
- `isStepAvailable(step)` : Vérifie si une étape est accessible
- `getDisabledSteps()` : Calcule les étapes désactivées pour le menu de navigation
- `hasCompletedStep4` : Détecté par la présence du chiffre `5` dans le tableau

**Cette structure garantit :**
1. **Migration transparente** depuis `localStorage.stepProgress`
2. **Navigation libre** entre étapes validées
3. **Intégrité des données** via la contrainte CHECK
4. ""Compatibilité totale avec le hook useStepProgress.ts existant""
---
### **Champ `updated_at`**
**Type** : `timestamptz NOT NULL DEFAULT now()`

**Rôle** : Enregistre automatiquement la date et l'heure de chaque modification du projet

**Valeurs** : Timestamp mis à jour automatiquement à chaque `UPDATE`

**Trigger à créer :**
  - **Nom** : `set_updated_at_etapes1to5` 
  - **Déclenchement** : `BEFORE UPDATE` sur la table `etapes_1to5`
  - **Condition** : À chaque modification (sans condition)
  - **Action** : `NEW.updated_at := NOW()`

**Utilisation :**
  - Traçabilité temporelle des modifications de projet
  - Permet de trier les projets par "dernière modification"
  - Utile pour audit et détection des projets abandonnés

**Cas d'usage :**
  - Page "Mes projets" : tri par `ORDER BY updated_at DESC`
  -  Détection projets inactifs : `WHERE updated_at < NOW() - INTERVAL '30 days'`
  - Synchronisation : comparaison timestamps pour conflits
    
---
## **Champ exclusivite**

**Description**
- **"Exclusivité du mandat (Oui/Non)"** : Indique si l'agence détient un mandat exclusif sur le bien.

**Obligatoire : Oui**
- **Référence ligne 27** : `const [exclusivite, setExclusivite] = useState("Non");`
- **Référence ligne 258** : `required={true}` dans le composant `SelectionButtonRond`
- Le champ a toujours une valeur par défaut ("Non"), donc techniquement **toujours rempli**, mais **requis dans le formulaire**.

**Condition de remplissage**
- **"Valeur par défaut 'Non' (modifiable par l'utilisateur)"** : 
  - Ligne 27 : `useState("Non")` → initialisation par défaut
  - Ligne 74 : `setExclusivite(propertyData.exclusivite || "Non")` → si chargement depuis `localStorage`, valeur par défaut "Non"
  - L'utilisateur peut la modifier via les boutons radio ("Oui" / "Non")

**Droits de modification**
- **Tables** : `user_id` (créateur de l'annonce)
- **Presenca** : `Oui` (admin peut modifier)

**Type SQL : TEXT**
- Stocke une chaîne de caractères : `"Oui"` ou `"Non"`

**Contraintes Supabase**
- **`NOT NULL`** : Le champ ne peut jamais être vide (valeur par défaut "Non")
- **`CHECK (exclusivite IN ('Oui', 'Non'))`** : Garantit que seules les valeurs "Oui" ou "Non" sont acceptées (validation côté base de données)

#**Actions à prévoir**
- **Migration des données depuis `localStorage`** : Récupération de la clé `propertyData.exclusivite`
---

## **Champ `saleType`** :

**1. Description** 
- "Type de transaction (à vendre / à louer)" 
→ Correspond à la documentation (ligne 192 du fichier `01.Etape1.md` : `saleType`)

**2. Obligatoire : Oui**
- **Ligne 30** : `const [saleType, setSaleType] = useState("à vendre");` → Valeur par défaut toujours définie
- **Lignes 47-50** : Options de sélection via `SelectionButtonRond` → Toujours une valeur sélectionnée
- **Ligne 293** : `required={true}` → Champ obligatoire dans le formulaire
- **Ligne 147-164** : Validation conditionnelle des champs `price` et `rentAmount` **dépend** de `saleType` → **Toujours nécessaire pour déterminer les champs à afficher**

**3. Condition de remplissage**
- **Valeur par défaut "à vendre"** (ligne 30 et 77) → Modifiable par l'utilisateur via les boutons radio

**4. Droits de modification**
- **Droits de modification tables** : `user_id` → Cohérent avec les autres champs
- **Droits de modification presenca** : `Oui` → Cohérent avec les autres champs

**5. Type SQL : TEXT**
- **Lignes 47-50** : Options `"à vendre"` ou `"à louer"` → Type texte

**6. Contraintes Supabase**
- `NOT NULL` → Champ obligatoire
- `CHECK (saleType IN ('à vendre', 'à louer'))` → **Contrainte d'intégrité** pour limiter les valeurs possibles aux deux options définies

**7. Actions à prévoir**
- **Migration depuis `localStorage`** : Ligne 77 → `setSaleType(propertyData.saleType || "à vendre");`
- **Récupération de la clé** : `propertyData.saleType`

---
## **Champ `price`** :

**1. Description**
- **"Prix FAI (Frais d'Agence Inclus) en euros"**
- Source : Ligne 415 du fichier `01.Etape1.md` : `id: "price", titre: "Prix FAI"`

**2. Obligatoire : Conditionnel**
- **Ligne 274-278** de `EnsembleFormulairesEtape1Form.tsx` :
  ```typescript
  if (saleType === "à vendre" && !price.trim()) {
    toast({ description: "Veuillez saisir le prix du bien." });
    return false;
  }
  ```
- Le champ `price` est **obligatoire uniquement si** `saleType === "à vendre"`.
- Si `saleType === "à louer"`, le champ n'est **pas affiché** et donc **facultatif** (NULL).


**3. Facultatif : Oui**
- Si `saleType === "à louer"`, le champ `price` n'est **pas requis** et peut rester vide (NULL).


**4. Condition de remplissage**
- **Requis si** `saleType === 'à vendre'`
- **Vide (NULL) si** `saleType === 'à louer'`
- **Source** : Lignes 295-302 de `EnsembleFormulairesEtape1Form.tsx` :
  ```typescript
   setPrice(e.target.value)}
    required={saleType === "à vendre"} // ← Condition
  />
  ```
- Le champ n'est **affiché** que si `saleType === "à vendre"` (lignes 293-303).

**5. Droits de modification**
- **Droits de modification tables** : `user_id` → Cohérent avec les autres champs
- **Droits de modification presenca** : `Oui` → Admin peut corriger les erreurs de saisie

**6. Type SQL : NUMERIC(12,2)**
- **Pourquoi NUMERIC et pas TEXT ?**
  - Bien que le champ soit **affiché formaté** (`"450 000€"`) dans le formulaire, il doit être **stocké en nombre** en base pour :
    - Permettre les **calculs** (statistiques, moyenne des prix, filtres...)
    - Permettre les **comparaisons** (recherche par plage de prix)
    - Assurer l'**intégrité des données** (pas de texte invalide)

- **Format actuel dans `localStorage`** :
  - **Ligne 192** : `const [price, setPrice] = useState("");` → Type `string`
  - **Ligne 77** : `setPrice(propertyData.price || "");` → Stocké comme `"450 000€"`

- **Parsing nécessaire lors de la migration** :
  - Utiliser la fonction `parseEuroAmount()` de `src/utils/GenerateurAnnoncesOutilsSeo/format.ts` (lignes 29-37) :
    ```typescript
    export const parseEuroAmount = (value?: string): number | undefined => {
      if (!value) return undefined;
      try {
        const numericValue = value.replace(/[^\d]/g, ''); // Supprime espaces et €
        return parseInt(numericValue, 10);
      } catch (error) {
        return undefined;
      }
    };
    ```

- **NUMERIC(12,2)** :
  - 12 chiffres au total (permet jusqu'à 999 999 999 999,99 €)
  - 2 décimales pour les centimes (bien que généralement 0 pour les prix immobiliers)

**7. Contraintes Supabase**
```sql
CHECK (
  (saleType = 'à vendre' AND price IS NOT NULL AND price >= 0) 
  OR 
  (saleType = 'à louer' AND price IS NULL)
)
```

**Explication** :
- **Si vente** (`saleType = 'à vendre'`) :
  - `price` doit être **renseigné** (`IS NOT NULL`)
  - `price` doit être **positif ou nul** (`>= 0`)
- **Si location** (`saleType = 'à louer'`) :
  - `price` doit être **NULL** (non renseigné)
- Cette contrainte assure la **cohérence logique** avec la validation côté client.

**8. Actions à prévoir**
1. **Migration depuis `localStorage`** :
   - Récupérer `propertyData.price` (format texte : `"450 000€"`)


2. **Affichage dans le formulaire** :
   - Récupérer le nombre depuis Supabase
   - **Formater pour affichage** via `formatPrice()` de `format.ts` (lignes 47-60) :
     ```typescript
     export const formatPrice = (value?: string | number): string => {
       if (value === undefined || value === null || value === '') return '';
       const numericValue = typeof value === 'string' 
         ? parseFloat(value.replace(/[^\d.]/g, '')) 
         : value;
       if (isNaN(numericValue)) return '';
       return numericValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ') + '€';
     };
     ```
   - Exemple : `450000` → `"450 000€"`
   ---
   
## Champ : **rentAmount**

**Obligatoire : Conditionnel**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape1/EnsembleFormulairesEtape1Form.tsx` (lignes 157-165) :
  ```typescript
  if (saleType === "à louer" && !rentAmount.trim()) {
    toast({
      title: "Erreur de validation",
      description: "Veuillez saisir le montant du loyer.",
      duration: 3000,
      variant: "destructive"
    });
    return false;
  }
  ```
- Le champ est **requis uniquement si** `saleType === "à louer"`, sinon il est **NULL**.

**Condition de remplissage**
**Sources :**
- Lignes 312-338 du même fichier montrent l'affichage conditionnel :
  ```typescript
  {saleType === "à louer" && (
    <>

         setRentAmount(e.target.value)}
          currency="€"
          required={true}
        />

      ...

  )}
  ```
- Le champ n'est **visible et requis** que si `saleType === "à louer"`.
- Si `saleType === "à vendre"`, alors `rentAmount` doit être `NULL`.

**Type SQL : NUMERIC(12,2)**
**Pourquoi ?**
- Le champ `rentAmount` est stocké dans le `localStorage` au format **texte formaté** : `"1 200€"`.
- En base de données Supabase, il doit être stocké comme un **nombre** pour permettre :
  - Des calculs (statistiques, moyennes, filtres).
  - Des tris par montant.
  - Des comparaisons (loyers > X).
- **NUMERIC(12,2)** permet de stocker jusqu'à **999 999 999 999,99 €** (12 chiffres au total, 2 après la virgule).

**Contraintes Supabase**
```sql
CHECK (
  (saleType = 'à louer' AND rentAmount IS NOT NULL AND rentAmount >= 0) 
  OR 
  (saleType = 'à vendre' AND rentAmount IS NULL)
)
```
**Explication :**
- Si `saleType = 'à louer'` → `rentAmount` doit être **NOT NULL** et **≥ 0**.
- Si `saleType = 'à vendre'` → `rentAmount` doit être **NULL**.

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Fonction de parsing nécessaire : `parseEuroAmount()`
  ```typescript
  function parseEuroAmount(value: string): number | null {
    if (!value || value.trim() === '') return null;

    // Supprimer le symbole € et les espaces
    const cleaned = value.replace(/€/g, '').replace(/\s/g, '');

    // Convertir en nombre
    const number = parseFloat(cleaned);

    return isNaN(number) ? null : number;
  }
  ```
- Exemple de migration :
  - `localStorage`: `"1 200€"` → Supabase : `1200.00`
  - `localStorage`: `"5 000€"` → Supabase : `5000.00`


**Relation avec `rentPeriodicity`**
- **Important** : Le champ `rentPeriodicity` est **lié** à `rentAmount`.
- Si `rentAmount` est renseigné (location), alors `rentPeriodicity` doit aussi être renseigné.
- Contrainte additionnelle à ajouter :
  ```sql
  CHECK (
    (rentAmount IS NOT NULL AND rentPeriodicity IS NOT NULL) 
    OR 
    (rentAmount IS NULL AND rentPeriodicity IS NULL)
  )
  ```

---

** Résumé des particularités de `rentAmount`**

| Aspect | Détail |
|--------|--------|
| **Nature** | Champ conditionnel inversé de `price` |
| **Visibilité** | Affiché uniquement si `saleType === "à louer"` |
| **Format stockage actuel** | Texte formaté avec € (ex: `"1 200€"`) |
| **Format stockage Supabase** | NUMERIC(12,2) (ex: `1200.00`) |
| **Parsing requis** | Oui, via `parseEuroAmount()` |
| **Contrainte CHECK** | Validation croisée avec `saleType` |
| **Champ lié** | `rentPeriodicity` (doit être renseigné si `rentAmount` l'est) |

---
## Champ : **rentPeriodicity**

**Obligatoire : Conditionnel**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape1/EnsembleFormulairesEtape1Form.tsx` (lignes 33, 52-56, 80) :
  ```typescript
  // État initial avec valeur par défaut
  const [rentPeriodicity, setRentPeriodicity] = useState("Mensuel");

  // Options disponibles
  const rentPeriodicityOptions = [
    { id: "Mensuel", label: "Mensuel" },
    { id: "Trimestriel", label: "Trimestriel" },
    { id: "Annuel", label: "Annuel" }
  ];

  // Chargement depuis localStorage avec valeur par défaut
  setRentPeriodicity(propertyData.rentPeriodicity || "Mensuel");
  ```
- Le champ est **requis uniquement si** `saleType === "à louer"`, sinon il est **NULL**.
- **Pas de validation explicite** dans `handleValidation()` car la sélection d'une valeur est **obligatoire** via les boutons radio (toujours une option sélectionnée).

**Condition de remplissage**
**Sources :**
- Lignes 312-338 du même fichier montrent l'affichage conditionnel :
  ```typescript
  {saleType === "à louer" && (
    <>

  )}
  ```
- Le champ n'est **visible et requis** que si `saleType === "à louer"`.
- Si `saleType === "à vendre"`, alors `rentPeriodicity` doit être **NULL**.

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `rentPeriodicity` stocke une valeur texte parmi **3 options fixes** : `"Mensuel"`, `"Trimestriel"`, `"Annuel"`.
- Type **TEXT** est suffisant (pas besoin de ENUM PostgreSQL car gestion des valeurs via contrainte CHECK).
- Format de stockage identique entre `localStorage` et Supabase → **Aucun parsing nécessaire**.

**Contraintes Supabase**
```sql
-- Contrainte 1 : Validation croisée avec saleType
CHECK (
  (saleType = 'à louer' AND rentPeriodicity IS NOT NULL) 
  OR 
  (saleType = 'à vendre' AND rentPeriodicity IS NULL)
)

-- Contrainte 2 : Validation des valeurs autorisées
CHECK (
  rentPeriodicity IN ('Mensuel', 'Trimestriel', 'Annuel')
)
```
**Explication :**
- **Contrainte 1** : Si `saleType = 'à louer'` → `rentPeriodicity` doit être **NOT NULL**. Si `saleType = 'à vendre'` → `rentPeriodicity` doit être **NULL**.
- **Contrainte 2** : Si `rentPeriodicity` est renseigné, il doit faire partie des 3 valeurs autorisées.

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Récupération directe sans transformation :


**Relation avec `rentAmount`**
- **Important** : Le champ `rentPeriodicity` est **lié** à `rentAmount`.
- Si `rentAmount` est renseigné (location), alors `rentPeriodicity` doit aussi être renseigné.
- Si `rentAmount` est NULL (vente), alors `rentPeriodicity` doit aussi être NULL.
- Cette logique est **déjà garantie** par la condition d'affichage (`saleType === "à louer"`).

---

**Résumé des particularités de `rentPeriodicity`**

| Aspect | Détail |
|--------|--------|
| **Nature** | Champ conditionnel lié à `rentAmount` |
| **Visibilité** | Affiché uniquement si `saleType === "à louer"` |
| **Format stockage actuel** | Texte brut (ex: `"Mensuel"`) |
| **Format stockage Supabase** | TEXT (ex: `"Mensuel"`) |
| **Parsing requis** | Non (format identique) |
| **Contrainte CHECK** | Validation croisée avec `saleType` + Validation des valeurs autorisées |
| **Champ lié** | `rentAmount` (doivent être renseignés ensemble ou NULL ensemble) |
| **Valeur par défaut** | `"Mensuel"` (définie côté frontend, pas en base) |
| **Validation explicite** | Aucune (bouton radio toujours sélectionné si visible) |

---
## Champ : **keyElements**

**Obligatoire : Oui**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape1/EnsembleFormulairesEtape1Form.tsx` (lignes 167-175) :
  ```typescript
  // 7. Vérification "keyElements"
  if (!keyElements.trim()) {
    toast({
      title: "Erreur de validation",
      description: "Veuillez saisir au moins un argument commercial.",
      duration: 3000,
      variant: "destructive"
    });
    return false;
  }
  ```
- Le champ bloque la validation si vide → **Obligatoire**

**Condition de remplissage**
**Sources :**
- Ligne 36 : `const [keyElements, setKeyElements] = useState("");` → Pas de valeur par défaut
- Ligne 80 : `setKeyElements(propertyData.keyElements || "");` → Chargement depuis `localStorage`
- **Aucune condition** : Le champ est toujours affiché et toujours requis, quelle que soit la valeur de `saleType`

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `keyElements` stocke du **texte multiligne** avec formatage spécifique :
  - Puces automatiques (`• `) en début de ligne
  - Capitalisation de la première lettre après la puce
  - Longueur variable (pas de limite technique)
- Format actuel dans `localStorage` : texte brut avec retours à la ligne

**Contraintes Supabase**
```sql
NOT NULL,
CHECK (length(keyElements) > 0)
```
**Explication :**
- `NOT NULL` : Le champ ne peut pas être vide
- `CHECK (length(keyElements) > 0)` : Garantit qu'il contient au moins 1 caractère (empêche les chaînes vides)

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Récupération directe : `propertyData.keyElements`
- Aucun parsing nécessaire : le texte est stocké tel quel

---

## Champ : **propertyDescription**

**Obligatoire : Oui**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape2/SaisieDescriptionForm.tsx` (lignes 43-52) :
  ```typescript
  const handleValidation = () => {
    if (!propertyDescription.trim()) {
      toast({
        title: "Erreur de validation",
        description: "Veuillez saisir une description du bien avant de continuer.",
        duration: 3000,
        variant: "destructive"
      });
      return;
    }

    updatePropertyData({ propertyDescription });
  ```
- Le champ est **toujours requis** pour valider l'Étape 2.

**Condition de remplissage**

**Sources :**
- Lignes 96-103 du même fichier montrent le champ en tant que champ unique obligatoire :
  ```typescript

  ```
- Le champ est **toujours visible** et **toujours requis**, sans condition.

**Type SQL : TEXT**

**Pourquoi ?**
- Le champ `propertyDescription` stocke une **description détaillée multiligne** du bien immobilier.
- En base de données Supabase, il doit être stocké comme **TEXT** car :
  - Contenu de longueur variable (pas de limite fixe).
  - Contient des retours à la ligne (`\n`) et des caractères spéciaux (`• `).
  - Pas de calculs ou tris numériques nécessaires.
- **TEXT** est le type approprié pour du contenu textuel long sans limite de taille.

**Explication :**
- `NOT NULL` : Le champ ne peut jamais être vide.
- `CHECK (length(propertyDescription) > 0)` : La description doit contenir au moins 1 caractère (évite les chaînes vides).

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Récupération directe depuis `propertyData.propertyDescription`


**Formatage automatique**
Le composant `FormulaireSaisie` applique automatiquement :
1. **Ajout de puces `• `** en début de chaque ligne (si pas déjà présentes)
2. **Capitalisation** de la première lettre après la puce
3. **Ajustement dynamique** de la hauteur du textarea
---

## Champ : **financials**

**Obligatoire : Oui**

**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape3/SaisieFinancialForm.tsx` (lignes 43-52) :
  ```typescript
  const handleValidation = () => {
    if (!financials.trim()) {
      toast({
        title: "Erreur de validation",
        description: "Veuillez saisir des informations financières avant de continuer.",
        duration: 3000,
        variant: "destructive"
      });
      return;
    }
  ```
- Le champ est **toujours requis** à l'Étape 3 : impossible de passer à l'Étape 4 sans avoir saisi des informations financières.

**Type SQL : TEXT**

**Pourquoi ?**
- Le champ `financials` est stocké dans `localStorage` au format **texte formaté** avec puces `• ` et capitalisation.
- Le type **TEXT** est adapté pour stocker du texte libre de longueur variable (sans limite stricte).
- Pas de traitement numérique → pas besoin de `NUMERIC`.

**Contraintes Supabase**
**Explication :**
- **`NOT NULL`** : Le champ ne peut jamais être vide (obligatoire).
- **`CHECK (length(financials) > 0)`** : Garantit que le champ contient au moins un caractère (évite les chaînes vides).

---

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Récupération directe de `propertyData.financials` depuis `localStorage`.
- **Aucun parsing nécessaire** : le format stocké dans `localStorage` (texte avec puces `• `) est identique au format attendu en base.

**Formatage automatique**
- Le formatage (ajout des puces `• `, capitalisation) est géré par le composant `FormulaireSaisie` **avant** la sauvegarde dans `localStorage`.
- La donnée est donc **déjà formatée** lors de la migration vers Supabase.

---

## **Champ : `details`**

**Obligatoire : Conditionnel**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape4/SaisieDetailsForm.tsx` (lignes 50-58) :
  ```typescript
  const handleValidation = () => {
    if (!hasNoDetails && details.trim() === "") {
      toast({
        title: "Attention",
        description: "Cette étape est optionnelle, mais vous devez indiquer votre choix. Soit cocher la case 'Je n'ai pas d'informations complémentaires à fournir', soit saisir des informations.",
        duration: 5000,
      });
      return;
    }
  ```
- **Particularité** : L'utilisateur **doit obligatoirement faire un choix** :
  - **Option A** : Cocher `hasNoDetails` → `details` sera **vide**
  - **Option B** : Saisir du contenu dans `details` → `hasNoDetails` sera **false**

**Condition de remplissage**
**Sources :**
- Lignes 119-130 : Checkbox "Je n'ai pas d'informations complémentaires"
  ```typescript
   handleHasNoDetailsChange(e.target.checked)}
  />
  ```
- Lignes 42-48 : Gestion de la checkbox
  ```typescript
  const handleHasNoDetailsChange = (value: boolean) => {
    setHasNoDetails(value);
    if (value === true) {
      setDetails("");
    }
  };
  ```
- **Logique** :
  - Si `hasNoDetails = true` → `details` **doit être vide**
  - Si `hasNoDetails = false` → `details` **doit contenir du texte** (sinon erreur de validation)

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `details` est stocké dans le `localStorage` au format **texte multiligne** avec formatage automatique (puces `• `, capitalisation).
- Comme les autres champs textuels (`propertyDescription`, `financials`), il n'a **pas de limite de longueur prédéfinie**.
- **TEXT** est adapté pour stocker du contenu de taille variable sans contrainte stricte.

**Contraintes Supabase**
```sql
CHECK (
  (hasNoDetails = false AND length(details) > 0) 
  OR 
  (hasNoDetails = true AND (details IS NULL OR details = ''))
)
```
**Explication :**
- **Si `hasNoDetails = false`** → `details` **doit contenir du texte** (`length(details) > 0`)
- **Si `hasNoDetails = true`** → `details` **doit être vide ou NULL** (`details IS NULL OR details = ''`)

⚠️ **Attention** : Cette contrainte CHECK doit être **synchronisée avec le champ `hasNoDetails`** (voir section suivante).

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- **Clé** : `propertyData.details`
- **Format stocké** : Texte avec puces `• ` en début de ligne + capitalisation automatique (géré par `FormulaireSaisie`)
- **Pas de parsing nécessaire** : Stockage direct en `TEXT`.

**Gestion du champ `hasNoDetails`**
- **Clé** : `propertyData.hasNoDetails`
- **Type** : `boolean`
- **Valeurs possibles** : `true` (utilisateur a coché la checkbox) ou `false` (utilisateur a saisi des informations)
- **Logique de chargement** (lignes 99-112) :
  ```typescript
  useEffect(() => {
    const propertyData = getPropertyDataFromStorage();

    if (propertyData.details) {
      setDetails(propertyData.details);
      setHasNoDetails(false);
    } else if (propertyData.hasNoDetails) {
      setHasNoDetails(true);
      setDetails("");
    } else {
      setHasNoDetails(false);
      setDetails("");
    }
  }, []);
  ```
**Particularités de `details`**
**1. Seul champ optionnel avec choix obligatoire**
- Contrairement aux autres champs, `details` est **optionnel** mais **l'utilisateur doit explicitement indiquer son choix** :
  - Soit cocher "Je n'ai pas d'informations complémentaires" (`hasNoDetails = true`)
  - Soit saisir du contenu dans le champ `details`

**2. Désactivation conditionnelle du champ**
- Ligne 139 : `readOnly={hasNoDetails}`
- Si la checkbox est cochée, le champ devient **en lecture seule** et est **vidé automatiquement** (ligne 46).

---

## Champ : **hasNoDetails**

**Obligatoire : Conditionnel**

**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape4/SaisieDetailsForm.tsx` (lignes 12-13) :
  ```typescript
  const [details, setDetails] = useState("");
  const [hasNoDetails, setHasNoDetails] = useState(false);
  ```
- **Valeur par défaut** : `false` (l'utilisateur n'a **pas** coché la case par défaut)

**Condition de remplissage**

**Sources :**
- Lignes 42-48 : Gestion de la checkbox
  ```typescript
  const handleHasNoDetailsChange = (value: boolean) => {
    setHasNoDetails(value);

    if (value === true) {
      setDetails("");  // ✅ Si checkbox cochée → details vidé
    }
  };
  ```
- Lignes 35-40 : Auto-décochage si saisie
  ```typescript
  const handleDetailsChange = (e: React.ChangeEvent) => {
    setDetails(e.target.value);
    if (e.target.value.trim() !== "") {
      setHasNoDetails(false);  // ✅ Si l'utilisateur saisit → checkbox décochée
    }
  };
  ```

**Logique de synchronisation** :
- Si l'utilisateur **coche la checkbox** → `hasNoDetails = true` ET `details = ""`
- Si l'utilisateur **saisit du texte** → `hasNoDetails = false` automatiquement
- Les deux champs sont **mutuellement exclusifs** : soit checkbox cochée, soit contenu saisi

**Type SQL : BOOLEAN**

**Pourquoi ?**
- Le champ `hasNoDetails` est un **indicateur binaire** (vrai/faux)
- En base de données Supabase, il doit être stocké comme `BOOLEAN` pour :
  - Interrogations simples : `WHERE hasNoDetails = true`
  - Filtres performants (index sur booléens)
  - Clarté sémantique du modèle de données

**Valeur par défaut** : `false`
- Ligne 13 : `useState(false)` → état initial
- Ligne 110 : `setHasNoDetails(false)` → si aucune donnée dans `localStorage`

**Contraintes Supabase**

**Explication :**
- **`NOT NULL`** : Le champ doit toujours avoir une valeur (jamais `NULL`)
- **`DEFAULT false`** : Valeur par défaut = `false` (pas de case cochée initialement)
- **`CHECK` (contrainte croisée avec `details`)** :
  - Si `hasNoDetails = false` → `details` doit contenir du texte (`length(details) > 0`)
  - Si `hasNoDetails = true` → `details` doit être vide (`NULL` ou `''`)

Cette contrainte **garantit la cohérence** entre les deux champs et évite les états invalides (ex : checkbox cochée + texte saisi).

**Actions à prévoir**

**Migration des données depuis `localStorage`**
- Récupération directe : `propertyData.hasNoDetails`
- Aucun parsing nécessaire (déjà stocké comme `boolean`)

**Code de chargement existant** (lignes 99-112) :
```typescript
useEffect(() => {
  const propertyData = getPropertyDataFromStorage();

  if (propertyData.details) {
    setDetails(propertyData.details);
    setHasNoDetails(false);  // ✅ Si details présent → hasNoDetails = false
  } else if (propertyData.hasNoDetails) {
    setHasNoDetails(true);   // ✅ Si hasNoDetails = true dans storage
    setDetails("");          // ✅ Details vidé
  } else {
    setHasNoDetails(false);  // ✅ Valeur par défaut
    setDetails("");
  }
}, []);
```
---
