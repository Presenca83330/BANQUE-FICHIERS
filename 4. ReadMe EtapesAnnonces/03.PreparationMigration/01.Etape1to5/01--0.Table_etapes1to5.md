
# Pr√©paration de la Table : etapes_1to5

## Description g√©n√©rale
- Pr√©paration de la Table de stockage des donn√©es collect√©es lors des **√âtapes 1 √† 5** du parcours de cr√©ation d'annonce immobili√®re.
- Cette table capture les 14 champs `propertyData` avant l'envoi des prompts vers OpenAI (Phase 1).

## Rappel de l'architecture avec CONSERVATION DU NOMMAGE camelCase
- Tous les hooks, fonctions, et interactions Supabase cr√©√©s lors de la migration
  - DOIVENT IMPERATIVEMETN CONSERVER :
    - la structure camelCase existante pour les champs m√©tier (agencyName, propertyType, saleType, price, rentAmount, rentPeriodicity, keyElements, propertyDescription, financials, details, exclusivite, location, reference).
  - UTILISER snake_case uniquement pour les champs syst√®me Supabase (organisation_id, user_id, created_at, updated_at, etc.).
- Cette directive s'applique pour la conception de cette tables

## Ressources obligatoires
- Avant toute cr√©ation ou modification de champ ou de note de bas de page
- Faire obligatoirement une analyse des fichiers de l'application
- Lire et analyer les audits
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/01.Etape1.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/02.Etape2.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/03.Etape3.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/04.Etape4.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/05.Etape5.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/06.Etape5animation.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/07.BilanEtape1aEtape5.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/08.ProcessEnvoiInfosOpenAI.md
  - public/4. ReadMe EtapesAnnonces/01.Etape1√†5/09.ProcessPassageEtapeSuivante.md
---
---
---

# Structure de la table
---


| Table       | Code champ          | Description                            | Obligatoire | Facultatif | Condition de remplissage | Droits de modification tables | Droits de modification presenca | Type SQL | Cl√© primaire (PK) | Cl√© √©trang√®re (FK) | R√©f√©rence vers table | Contraintes Supabase | Type d'identifiant | Actions √† pr√©voir |
|:------------|:--------------------|:---------------------------------------|:------------|:-----------|:-------------------------|:------------------------------|:--------------------------------|:---------|:------------------|:-------------------|:---------------------|:---------------------|:-------------------|:------------------|
| etapes_1to5 | project_id | Identifiant unique du projet annonce | Oui | | Auto-g√©n√©r√© | Lecture seule | Lecture seule | uuid | Oui | | | Default: gen_random_uuid() | UUID | auto |
| etapes_1to5 | organisation_id | Identifiant de l'organisation (tenant) | Oui | | Doit correspondre √† l'organisation de l'utilisateur | Lecture seule | Lecture seule | uuid | | Oui | organisations(organisation_id) | NOT NULL, FK, ON DELETE CASCADE | UUID | Auto (via get_user_organisation_id()) |
| etapes_1to5 | user_id | Identifiant de l'utilisateur cr√©ateur | Oui | | D√©fini automatiquement √† la cr√©ation | Lecture seule | Lecture seule | uuid | | Oui | users(users_id) | NOT NULL, FK, ON DELETE CASCADE | UUID | Auto (via auth.uid() ‚Üí users) |
| etapes_1to5 | utilisateur_type_compte | Type de compte utilisateur | Oui | | D√©fini automatiquement √† la cr√©ation | Lecture seule | Lecture seule | text | | | | NOT NULL, CHECK (utilisateur_type_compte IN ('reseau', 'reseau_direction', 'reseau_agence', 'reseau_agence_responsable', 'reseau_agence_collaborateur', 'agence_independante', 'agence_independante_responsable', 'agence_independante_collaborateur')) | text | Auto (via get_user_type_compte()) |
| etapes_1to5 | reseau_id | R√©f√©rence optionnelle vers r√©seau (analytique) | | Oui | Renseign√© si utilisateur appartient √† un r√©seau | Lecture seule | Lecture seule | uuid | | Oui | reseau(reseau_id) | NULL, FK, ON DELETE SET NULL | UUID | Auto (si type r√©seau) |
| etapes_1to5 | reseau_agence_id | R√©f√©rence optionnelle vers agence r√©seau (analytique) | | Oui | Renseign√© si utilisateur appartient √† une agence r√©seau | Lecture seule | Lecture seule | uuid | | Oui | reseau_agence(reseau_agence_id) | NULL, FK, ON DELETE SET NULL | UUID | Auto (si type agence r√©seau) |
| etapes_1to5 | agence_indep_id | R√©f√©rence optionnelle vers agence ind√©pendante (analytique) | | Oui | Renseign√© si utilisateur appartient √† une agence ind√©pendante | Lecture seule | Lecture seule | uuid | | Oui | agence_independante(agence_indep_id) | NULL, FK, ON DELETE SET NULL | UUID | Auto (si type agence ind√©p.) |
| etapes_1to5 | step_progress | Liste cumulative des √©tapes d√©verrouill√©es (1 √† 5) | Oui |  | Toujours renseign√© (valeur par d√©faut '{1}' √† la cr√©ation) | Lecture seule | Consultation uniquement | integer[] | Non | Non | ‚Äî | NOT NULL, DEFAULT '{1}'::integer[], CHECK (array_length(step_progress, 1) >= 1 AND 1 = ANY(step_progress) AND step_progress <@ ARRAY[1,2,3,4,5]) | Array | Auto (g√©r√© par completeStep) |
| etapes_1to5 | statut | Statut du projet ('en_cours', 'archive') | Oui | | D√©fini par le syst√®me selon progression | Automatique / Admin | Modifiable | text | | | | Default 'en_cours', CHECK (statut IN ('en_cours', 'archive')) | text | Gestion du cycle de vie |
| etapes_1to5 | validated_at | Date de validation finale avant OpenAI |   | Oui  | Renseign√©e lors de la validation √©tape 5 | Automatique | Lecture seule  | timestamptz |  |  |    | NULL par d√©faut| Timestamp | Trigger auto-set |
| etapes_1to5 | logs| Logs de modifications locales|   | Oui  | Aliment√©s automatiquement   Automatique | Lecture seule | jsonb |  |   |  | Default '{}'::jsonb | JSON | optionnel|
| etapes_1to5 | created_at| Date de cr√©ation | Oui| | Auto | Auto | Lecture seule | timestamptz | |   |  | Default now() | Timestamp | auto |
| etapes_1to5 | updated_at | Derni√®re modification | Oui|  | Auto via trigger | Auto | Lecture seule| timestamptz |  |  |  | Trigger set_updated_at() | Timestamp | auto |

---

# Champs PropertyData (14 champs m√©tier)

---
| Table        | Code champ          | Description                                               | Obligatoire | Facultatif | Condition de remplissage                        | Droits de modification tables | Droits de modification presenca | Type SQL | Cl√© primaire (PK) | Cl√© √©trang√®re (FK) | R√©f√©rence vers table | Contraintes Supabase             | Type d'identifiant | Actions √† pr√©voir | √âtape collecte |
|---------------|--------------------|-----------------------------------------------------------|--------------|-------------|--------------------------------------------------|-------------------------------|----------------------------------|-----------|-------------------|--------------------|-----------------------|----------------------------------|--------------------|------------------|----------------|
| etapes_1to5 | agencyName | Nom de l'agence du cr√©ateur de l'annonce | Oui | Non | Aucune (toujours requis √† l'√©tape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL |  |  Migration des donn√©es depuis localStorage : R√©cup√©ration de la cl√© : propertyData.agencyName | Etape 1   |
| etapes_1to5 | reference | R√©f√©rence du bien immobilier | Oui | Non | Aucune (toujours requis √† l'√©tape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des donn√©es depuis localStorage : R√©cup√©ration de la cl√© : propertyData.reference | √âtape 1 |
| etapes_1to5 | exclusivite | Exclusivit√© du mandat (Oui/Non) | Oui | Non | Valeur par d√©faut "Non" (modifiable par l'utilisateur) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (exclusivite IN ('Oui', 'Non')) | - | Migration des donn√©es depuis localStorage : R√©cup√©ration de la cl√© : propertyData.exclusivite | √âtape 1 |
| etapes_1to5 | location | Emplacement du bien (ville, arrondissement, d√©partement) | Oui | Non | Aucune (toujours requis √† l'√©tape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des donn√©es depuis `localStorage` : R√©cup√©ration de la cl√© `propertyData.location`| √âtape 1 |
| etapes_1to5 | propertyType | Type de bien immobilier (Restaurant, Commerce, Local Commercial, Bureau...) | Oui | Non | Aucune (toujours requis √† l'√©tape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL | - | Migration des donn√©es depuis `localStorage` : R√©cup√©ration de la cl√© `propertyData.propertyType` | √âtape 1 |
| etapes_1to5 | saleType | Type de transaction (√† vendre / √† louer) | Oui | Non | Valeur par d√©faut "√† vendre" (modifiable par l'utilisateur) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (saleType IN ('√† vendre', '√† louer')) | - | Migration des donn√©es depuis `localStorage` : R√©cup√©ration de la cl√© `propertyData.saleType` | √âtape 1 |
| etapes_1to5 | price | Prix FAI (Frais d'Agence Inclus) en euros | Conditionnel | Oui | Requis uniquement si saleType === '√† vendre'. Vide si saleType === '√† louer' | user_id | Oui | TEXT | Non | Non | - | CHECK ((saleType = '√† vendre' AND price IS NOT NULL AND length(trim(price)) > 0) OR (saleType = '√† louer' AND price IS NULL)) | - | Migration depuis localStorage : R√©cup√©ration directe de propertyData.price (format d√©j√† stock√© : "450 000‚Ç¨") | √âtape 1 |
| etapes_1to5 | rentAmount | Montant du loyer HT/HC en euros | Conditionnel | Oui | Requis si saleType === '√† louer'. NULL si saleType === '√† vendre' | user_id | Oui | TEXT | Non | Non | - | CHECK ((saleType = '√† louer' AND rentAmount IS NOT NULL AND length(trim(rentAmount)) > 0) OR (saleType = '√† vendre' AND rentAmount IS NULL)) | - | Migration depuis localStorage : R√©cup√©ration directe de propertyData.rentAmount (format d√©j√† stock√© : "1 200‚Ç¨") | √âtape 1 |
| etapes_1to5 | rentPeriodicity | P√©riodicit√© du loyer (Mensuel / Trimestriel / Annuel) | **Conditionnel** | Non | **Requis si** `saleType === '√† louer'`**NULL si** `saleType === '√† vendre'` | user_id | Oui | TEXT | Non | Non | - | `CHECK ((saleType = '√† louer' AND rentPeriodicity IS NOT NULL) OR (saleType = '√† vendre' AND rentPeriodicity IS NULL))`, `CHECK (rentPeriodicity IN ('Mensuel', 'Trimestriel', 'Annuel'))` | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.rentPeriodicity` (valeur par d√©faut : `"Mensuel"`) | √âtape 1 |
| etapes_1to5 | keyElements | Arguments commerciaux : points forts du bien (emplacement premium, conditions locatives, potentiel, raret√©, etc.) | Oui | Non | Aucune (toujours requis √† l'√©tape 1) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(keyElements) > 0) | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.keyElements` | √âtape 1 |
| etapes_1to5 | propertyDescription | Description d√©taill√©e du bien : emplacement, superficie, activit√©, client√®le, √©quipements, ambiance... | Oui | Non | Aucune (toujours requis √† l'√©tape 2) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(propertyDescription) > 0) | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.propertyDescription` (format stock√© : texte avec puces `‚Ä¢ ` en d√©but de ligne + capitalisation automatique) | √âtape 2 |
| etapes_1to5 | financials | Informations financi√®res du bien : conditions locatives, performances financi√®res, potentiel de d√©veloppement | Oui | Non | Aucune (toujours requis √† l'√©tape 3) | user_id | Oui | TEXT | Non | Non | - | NOT NULL, CHECK (length(financials) > 0) | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.financials` (format stock√© : texte avec puces `‚Ä¢ ` en d√©but de ligne + capitalisation automatique) | √âtape 3 |
| etapes_1to5 | details | Informations compl√©mentaires optionnelles sur le bien (horaires d'ouverture, p√©riodes de fermeture, autres d√©tails d'exploitation) | **Conditionnel** | Oui | **Requis si** `hasNoDetails === false` **ET** utilisateur saisit des informations. **Vide si** `hasNoDetails === true` | user_id | Oui | TEXT | Non | Non | - | `CHECK ((hasNoDetails = false AND length(details) > 0) OR (hasNoDetails = true AND (details IS NULL OR details = '')))` | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.details` (format stock√© : texte avec puces `‚Ä¢ ` en d√©but de ligne + capitalisation automatique) | √âtape 4 |
| etapes_1to5 | hasNoDetails | Indicateur bool√©en : l'utilisateur a coch√© "Je n'ai pas d'informations compl√©mentaires √† fournir" | **Conditionnel** | Oui | **`true` si** checkbox coch√©e (et `details` devient vide/NULL). **`false` si** utilisateur saisit des informations dans `details` | user_id | Oui | BOOLEAN | Non | Non | - | `NOT NULL, DEFAULT false`, `CHECK ((hasNoDetails = false AND length(details) > 0) OR (hasNoDetails = true AND (details IS NULL OR details = '')))` | - | Migration depuis `localStorage` : R√©cup√©ration `propertyData.hasNoDetails` (valeur par d√©faut : `false`) | √âtape 4 |
---

## üìå **Notes explicatives**

### **Champ `statut`**
**Valeurs possibles** : 'en_cours', 'archive'

**Statut du projet**
-  `'en_cours'` (d√©faut) : Projet actif, en cours de saisie
- `'archive'` : Projet valid√© et archiv√© apr√®s validation √©tape 5
  - Transition automatique via trigger Supabase
  - Permettra dans une utilisation future de conserver l'historique des projets finalis√©s

**Trigger Supabase** :
  - Nom : `statut_du_projet`
  - D√©clenchement : `BEFORE UPDATE` sur la table `etapes_1to5`
  - Condition : Si `validated_at IS NOT NULL` ET `5 = ANY(step_progress)`
  - Action : `statut` passe automatiquement de `'en_cours'` √† `'archive'`

**Cas d'usage** :
  - Page "Mes projets en cours" : `WHERE statut = 'en_cours'`
  - Page "Historique des annonces" : `WHERE statut = 'archive'`

---

### **Champ `validated_at`**
**Type** : `timestamptz NULL DEFAULT NULL`

**R√¥le** : Enregistre la date et l'heure exactes de validation finale (√©tape 5)

**Valeurs** : `NULL` (non valid√©) ou timestamp (valid√©)

**Trigger √† cr√©er :**
  - **Nom** : `set_validated_at`
  - **D√©clenchement** : `BEFORE UPDATE` sur la table `etapes_1to5`
  - **Condition** : Si `NEW.validated_at IS NOT NULL` AND `OLD.validated_at IS NULL`
  - **Action** : Renseigne automatiquement `validated_at := NOW()`

**Utilisation :**
- Utilis√© comme l'une des 2 conditions du trigger `statut_du_projet` (voir section `statut`)
- Permet la tra√ßabilit√© temporelle de la validation

---
###  **Champ `step_progress`**
- Le champ `step_progress` stocke un **tableau d'entiers non r√©gressif** repr√©sentant toutes les √©tapes d√©j√† d√©verrouill√©es par l'utilisateur
- (ex : `{1, 2, 3}` signifie que les √©tapes 1, 2 et 3 sont accessibles).

**Fonctionnement :**
- **Initialisation** : `{1}` (seule l'√©tape 1 est accessible)
- **Progression s√©quentielle** : √Ä chaque validation d'√©tape, `completeStep(X)` ajoute l'√©tape suivante (ex : apr√®s validation de l'√©tape 2 ‚Üí `{1, 2, 3}`)
- **Navigation libre** : L'utilisateur peut naviguer entre toutes les √©tapes pr√©sentes dans `step_progress` sans restriction
- **Non r√©gressif** : Une fois une √©tape ajout√©e, elle reste accessible m√™me si l'utilisateur modifie des donn√©es pr√©c√©dentes (via `handleBackToEtape5()`)

**Contrainte CHECK :**
- Le tableau doit **toujours contenir au moins l'√©tape 1**
- Les valeurs doivent √™tre **comprises entre 1 et 5**
- Emp√™che les √©tats invalides (ex : `{3, 4}` sans √©tapes 1 et 2)

**Utilisation applicative :**
- `isStepAvailable(step)` : V√©rifie si une √©tape est accessible
- `getDisabledSteps()` : Calcule les √©tapes d√©sactiv√©es pour le menu de navigation
- `hasCompletedStep4` : D√©tect√© par la pr√©sence du chiffre `5` dans le tableau

**Cette structure garantit :**
1. **Migration transparente** depuis `localStorage.stepProgress`
2. **Navigation libre** entre √©tapes valid√©es
3. **Int√©grit√© des donn√©es** via la contrainte CHECK
4. ""Compatibilit√© totale avec le hook useStepProgress.ts existant""
---
### **Champ `updated_at`**
**Type** : `timestamptz NOT NULL DEFAULT now()`

**R√¥le** : Enregistre automatiquement la date et l'heure de chaque modification du projet

**Valeurs** : Timestamp mis √† jour automatiquement √† chaque `UPDATE`

**Trigger √† cr√©er :**
  - **Nom** : `set_updated_at_etapes1to5` 
  - **D√©clenchement** : `BEFORE UPDATE` sur la table `etapes_1to5`
  - **Condition** : √Ä chaque modification (sans condition)
  - **Action** : `NEW.updated_at := NOW()`

**Utilisation :**
  - Tra√ßabilit√© temporelle des modifications de projet
  - Permet de trier les projets par "derni√®re modification"
  - Utile pour audit et d√©tection des projets abandonn√©s

**Cas d'usage :**
  - Page "Mes projets" : tri par `ORDER BY updated_at DESC`
  -  D√©tection projets inactifs : `WHERE updated_at < NOW() - INTERVAL '30 days'`
  - Synchronisation : comparaison timestamps pour conflits
    
---
## **Champ exclusivite**

**Description**
- **"Exclusivit√© du mandat (Oui/Non)"** : Indique si l'agence d√©tient un mandat exclusif sur le bien.

**Obligatoire : Oui**
- **R√©f√©rence ligne 27** : `const [exclusivite, setExclusivite] = useState("Non");`
- **R√©f√©rence ligne 258** : `required={true}` dans le composant `SelectionButtonRond`
- Le champ a toujours une valeur par d√©faut ("Non"), donc techniquement **toujours rempli**, mais **requis dans le formulaire**.

**Condition de remplissage**
- **"Valeur par d√©faut 'Non' (modifiable par l'utilisateur)"** : 
  - Ligne 27 : `useState("Non")` ‚Üí initialisation par d√©faut
  - Ligne 74 : `setExclusivite(propertyData.exclusivite || "Non")` ‚Üí si chargement depuis `localStorage`, valeur par d√©faut "Non"
  - L'utilisateur peut la modifier via les boutons radio ("Oui" / "Non")

**Droits de modification**
- **Tables** : `user_id` (cr√©ateur de l'annonce)
- **Presenca** : `Oui` (admin peut modifier)

**Type SQL : TEXT**
- Stocke une cha√Æne de caract√®res : `"Oui"` ou `"Non"`

**Contraintes Supabase**
- **`NOT NULL`** : Le champ ne peut jamais √™tre vide (valeur par d√©faut "Non")
- **`CHECK (exclusivite IN ('Oui', 'Non'))`** : Garantit que seules les valeurs "Oui" ou "Non" sont accept√©es (validation c√¥t√© base de donn√©es)

#**Actions √† pr√©voir**
- **Migration des donn√©es depuis `localStorage`** : R√©cup√©ration de la cl√© `propertyData.exclusivite`
---

## **Champ `saleType`** :

**1. Description** 
- "Type de transaction (√† vendre / √† louer)" 
‚Üí Correspond √† la documentation (ligne 192 du fichier `01.Etape1.md` : `saleType`)

**2. Obligatoire : Oui**
- **Ligne 30** : `const [saleType, setSaleType] = useState("√† vendre");` ‚Üí Valeur par d√©faut toujours d√©finie
- **Lignes 47-50** : Options de s√©lection via `SelectionButtonRond` ‚Üí Toujours une valeur s√©lectionn√©e
- **Ligne 293** : `required={true}` ‚Üí Champ obligatoire dans le formulaire
- **Ligne 147-164** : Validation conditionnelle des champs `price` et `rentAmount` **d√©pend** de `saleType` ‚Üí **Toujours n√©cessaire pour d√©terminer les champs √† afficher**

**3. Condition de remplissage**
- **Valeur par d√©faut "√† vendre"** (ligne 30 et 77) ‚Üí Modifiable par l'utilisateur via les boutons radio

**4. Droits de modification**
- **Droits de modification tables** : `user_id` ‚Üí Coh√©rent avec les autres champs
- **Droits de modification presenca** : `Oui` ‚Üí Coh√©rent avec les autres champs

**5. Type SQL : TEXT**
- **Lignes 47-50** : Options `"√† vendre"` ou `"√† louer"` ‚Üí Type texte

**6. Contraintes Supabase**
- `NOT NULL` ‚Üí Champ obligatoire
- `CHECK (saleType IN ('√† vendre', '√† louer'))` ‚Üí **Contrainte d'int√©grit√©** pour limiter les valeurs possibles aux deux options d√©finies

**7. Actions √† pr√©voir**
- **Migration depuis `localStorage`** : Ligne 77 ‚Üí `setSaleType(propertyData.saleType || "√† vendre");`
- **R√©cup√©ration de la cl√©** : `propertyData.saleType`

---
## **Champ `price`** :

**1. Description**
- **"Prix FAI (Frais d'Agence Inclus) en euros"**
- **Source :** Ligne 415 du fichier `01.Etape1.md` : `id: "price"`, `titre: "Prix FAI"`

**2. Obligatoire : Conditionnel**

-**Ligne 274-278 de `EnsembleFormulairesEtape1Form.tsx` :**
```typescript
if (saleType === "√† vendre" && !price.trim()) {
  toast({ description: "Veuillez saisir le prix du bien." });
  return false;
}
```
- Le champ `price` est **obligatoire uniquement** si `saleType === "√† vendre"`.
- Si `saleType === "√† louer"`, le champ n'est pas affich√© et donc **facultatif (NULL)**.

**3. Facultatif : Oui**
- Si `saleType === "√† louer"`, le champ `price` n'est pas requis et peut rester vide (**NULL**).

**4. Condition de remplissage**
- **Requis** si `saleType = '√† vendre'`
- **Vide (NULL)** si `saleType = '√† louer'`

**Source :** Lignes 295-302 de `EnsembleFormulairesEtape1Form.tsx` :
```tsx
 setPrice(e.target.value)}
  required={saleType === "√† vendre"} // ‚Üê Condition
/>
```
- Le champ n'est affich√© que si `saleType === "√† vendre"` (lignes 293-303).

**5. Droits de modification**
- **Droits de modification tables :** `user_id` ‚Üí Coh√©rent avec les autres champs
- **Droits de modification presenca :** `Oui` ‚Üí Admin peut corriger les erreurs de saisie

**6. Type SQL : TEXT**

**Pourquoi TEXT et pas NUMERIC ?**
- Le champ est stock√© **directement au format texte format√©** (`"450 000‚Ç¨"`) car :
- 1. **Stockage localStorage actuel :** Format texte d√©j√† format√©
   - Ligne 192 : `const [price, setPrice] = useState("");` ‚Üí Type string
   - Ligne 77 : `setPrice(propertyData.price || "");` ‚Üí Stock√© comme `"450 000‚Ç¨"`
- 2. **Composant de saisie :** `MonetaryFieldForm` produit directement le format `"450 000‚Ç¨"`
   - Le composant g√®re automatiquement le formatage avec espaces et symbole ‚Ç¨
   - Pas de conversion num√©rique n√©cessaire
- 3. **Pas de calculs directs en SQL :** 
   - Les calculs statistiques ou filtres se feront c√¥t√© application
   - La validation du format reste applicative (via `MonetaryFieldForm`)
- 4. **Coh√©rence avec l'existant :**
   - Migration simplifi√©e (pas de parsing/conversion)
   - Affichage direct sans re-formatage
- **Type :** `TEXT` (longueur variable, pas de limite fixe)

**7. Contraintes Supabase**
```sql
CHECK (
  (saleType = '√† vendre' AND price IS NOT NULL AND length(trim(price)) > 0) 
  OR 
  (saleType = '√† louer' AND price IS NULL)
)
```

- **Explication :**
- **Si vente** (`saleType = '√† vendre'`) :
  - `price` doit √™tre renseign√© (`IS NOT NULL`)
  - `price` ne doit pas √™tre une cha√Æne vide (`length(trim(price)) > 0`)

- **Si location** (`saleType = '√† louer'`) :
  - `price` doit √™tre `NULL` (non renseign√©)
- Cette contrainte assure la **coh√©rence logique** avec la validation c√¥t√© client.

**8. Actions √† pr√©voir**
- **Migration depuis localStorage :**
```typescript
// R√©cup√©ration DIRECTE sans parsing
const priceValue = propertyData.price; // "450 000‚Ç¨"

// Insertion en base
await supabase.from('etapes_1to5').insert({
  price: priceValue, // Stock√© tel quel : "450 000‚Ç¨"
  // ...
});
```
- **Pas de parsing n√©cessaire** 
   ---
   
## Champ : **rentAmount**

**1. Description**
- **"Montant du loyer HT/HC en euros"**
- **Source :** Ligne 314 du fichier `EnsembleFormulairesEtape1Form.tsx` : `id: "rentAmount"`, `titre: "Loyer HT/HC"`

**2. Obligatoire : Conditionnel**
- **Lignes 157-165 de `EnsembleFormulairesEtape1Form.tsx` :**
```typescript
if (saleType === "√† louer" && !rentAmount.trim()) {
  toast({
    title: "Erreur de validation",
    description: "Veuillez saisir le montant du loyer.",
    duration: 3000,
    variant: "destructive"
  });
  return false;
}
```
- Le champ `rentAmount` est **obligatoire uniquement si** `saleType === "√† louer"`.
- Si `saleType === "√† vendre"`, le champ n'est pas affich√© et donc **facultatif (NULL)**.

**3. Facultatif : Oui**
- Si `saleType === "√† vendre"`, le champ `rentAmount` n'est pas requis et peut rester vide (NULL).

**4. Condition de remplissage**
- **Requis si** `saleType === '√† louer'`
- **Vide (NULL) si** `saleType === '√† vendre'`
- **Source : Lignes 312-338 de `EnsembleFormulairesEtape1Form.tsx` :**
```typescript
{saleType === "√† louer" && (
  <>
     setRentAmount(e.target.value)}
      currency="‚Ç¨"
      required={true} // ‚Üê Condition
    />

)}
```

- Le champ n'est **affich√© que si** `saleType === "√† louer"` (lignes 312-338).

**5. Droits de modification**
- **Droits de modification tables** : `user_id` ‚Üí Coh√©rent avec les autres champs
- **Droits de modification presenca** : Oui ‚Üí Admin peut corriger les erreurs de saisie

**6. Type SQL : TEXT**
**Pourquoi TEXT et pas NUMERIC ?**
- Bien que l'on pourrait penser qu'un montant devrait √™tre stock√© comme nombre, l'application utilise le format **texte format√©** :
- 1. **Format actuel dans `localStorage` :**
   - Ligne 193 : `const [rentAmount, setRentAmount] = useState("");` ‚Üí Type `string`
   - Ligne 78 : `setRentAmount(propertyData.rentAmount || "");` ‚Üí Stock√© comme `"1 200‚Ç¨"`

- 2. **Le composant `MonetaryFieldForm` produit du texte format√© :**
   - Entr√©e utilisateur : `1200`
   - Sortie format√©e : `"1 200‚Ç¨"`
   - Le formatage inclut espaces et symbole ‚Ç¨

- 3. **Pas de calculs arithm√©tiques directs :**
   - Aucune op√©ration math√©matique n'est effectu√©e directement sur `rentAmount`
   - Les statistiques/filtres peuvent √™tre impl√©ment√©s ult√©rieurement avec parsing c√¥t√© application si n√©cessaire

- 4. **Coh√©rence avec `price` :**
   - Le champ `price` utilise √©galement `TEXT`
   - Les deux champs mon√©taires suivent la m√™me logique de stockage

- **Conclusion :** `TEXT` est le type appropri√© car il correspond au format r√©el de l'application.

**7. Contraintes Supabase**

```sql
CHECK (
  (saleType = '√† louer' AND rentAmount IS NOT NULL AND length(trim(rentAmount)) > 0) 
  OR 
  (saleType = '√† vendre' AND rentAmount IS NULL)
)
```

**Explication :**

- **Si location** (`saleType = '√† louer'`) :
  - `rentAmount` doit √™tre renseign√© (`IS NOT NULL`)
  - `rentAmount` doit contenir du texte non vide (`length(trim(rentAmount)) > 0`)

- **Si vente** (`saleType = '√† vendre'`) :
  - `rentAmount` doit √™tre `NULL` (non renseign√©)

- Cette contrainte assure la coh√©rence logique avec la validation c√¥t√© client.

**8. Actions √† pr√©voir**
- **Migration depuis `localStorage` :**

```typescript
// CORRECT (TEXT)
const rentAmountValue = propertyData.rentAmount; // "1 200‚Ç¨"
```
- **R√©cup√©ration directe de `propertyData.rentAmount`** (format d√©j√† stock√© : `"1 200‚Ç¨"`)

- **PAS de parsing n√©cessaire** 
- **Stockage direct** du texte format√© tel quel
- **Affichage dans le formulaire :**

```typescript
// R√©cup√©ration depuis Supabase
const rentAmountFromDB = etape1Data.rentAmount; // "1 200‚Ç¨"

// Affichage direct dans MonetaryFieldForm
 setRentAmount(e.target.value)}
/>
```
- Le composant `MonetaryFieldForm` g√®re automatiquement le formatage
- Pas besoin de transformation entre base et interface

 **9. Validation applicative (non SQL)**
- La validation du format mon√©taire reste **c√¥t√© application** :
- 1. **Saisie :** `MonetaryFieldForm` formate automatiquement en `"XXX XXX‚Ç¨"`
- 2. **Validation m√©tier :** V√©rification que le champ n'est pas vide si requis (selon `saleType`)
- 3. **Pas de contrainte SQL sur le format :** SQL valide uniquement la pr√©sence/absence selon `saleType`

---
**10. Relation avec `rentPeriodicity`**
- **Important :** Le champ `rentPeriodicity` est **li√©** √† `rentAmount`.
- Si `rentAmount` est renseign√© (location), alors `rentPeriodicity` **doit aussi** √™tre renseign√©.
- Cette logique sera valid√©e **c√¥t√© application** (pas de contrainte CHECK crois√©e en SQL pour √©viter la complexit√©).

**R√©sum√© des changements pour `rentAmount`**

| Aspect |  Nouvelle version (CORRECTE) |
|--------|------------------------------|--------------------------------|
| **Type SQL** | `TEXT` |
| **Contrainte CHECK** | `length(trim(rentAmount)) > 0` (validation texte) |
| **Migration localStorage** | R√©cup√©ration directe : `"1 200‚Ç¨"` ‚Üí `"1 200‚Ç¨"` |
| **Stockage Supabase** |  Texte format√© |
| **Affichage formulaire** |  Utilisation directe du texte |

---
## Champ : **rentPeriodicity**

**Obligatoire : Conditionnel**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape1/EnsembleFormulairesEtape1Form.tsx` (lignes 33, 52-56, 80) :
  ```typescript
  // √âtat initial avec valeur par d√©faut
  const [rentPeriodicity, setRentPeriodicity] = useState("Mensuel");

  // Options disponibles
  const rentPeriodicityOptions = [
    { id: "Mensuel", label: "Mensuel" },
    { id: "Trimestriel", label: "Trimestriel" },
    { id: "Annuel", label: "Annuel" }
  ];

  // Chargement depuis localStorage avec valeur par d√©faut
  setRentPeriodicity(propertyData.rentPeriodicity || "Mensuel");
  ```
- Le champ est **requis uniquement si** `saleType === "√† louer"`, sinon il est **NULL**.
- **Pas de validation explicite** dans `handleValidation()` car la s√©lection d'une valeur est **obligatoire** via les boutons radio (toujours une option s√©lectionn√©e).

**Condition de remplissage**
**Sources :**
- Lignes 312-338 du m√™me fichier montrent l'affichage conditionnel :
  ```typescript
  {saleType === "√† louer" && (
    <>

  )}
  ```
- Le champ n'est **visible et requis** que si `saleType === "√† louer"`.
- Si `saleType === "√† vendre"`, alors `rentPeriodicity` doit √™tre **NULL**.

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `rentPeriodicity` stocke une valeur texte parmi **3 options fixes** : `"Mensuel"`, `"Trimestriel"`, `"Annuel"`.
- Type **TEXT** est suffisant (pas besoin de ENUM PostgreSQL car gestion des valeurs via contrainte CHECK).
- Format de stockage identique entre `localStorage` et Supabase ‚Üí **Aucun parsing n√©cessaire**.

**Contraintes Supabase**
```sql
-- Contrainte 1 : Validation crois√©e avec saleType
CHECK (
  (saleType = '√† louer' AND rentPeriodicity IS NOT NULL) 
  OR 
  (saleType = '√† vendre' AND rentPeriodicity IS NULL)
)

-- Contrainte 2 : Validation des valeurs autoris√©es
CHECK (
  rentPeriodicity IN ('Mensuel', 'Trimestriel', 'Annuel')
)
```
**Explication :**
- **Contrainte 1** : Si `saleType = '√† louer'` ‚Üí `rentPeriodicity` doit √™tre **NOT NULL**. Si `saleType = '√† vendre'` ‚Üí `rentPeriodicity` doit √™tre **NULL**.
- **Contrainte 2** : Si `rentPeriodicity` est renseign√©, il doit faire partie des 3 valeurs autoris√©es.

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- R√©cup√©ration directe sans transformation :


**Relation avec `rentAmount`**
- **Important** : Le champ `rentPeriodicity` est **li√©** √† `rentAmount`.
- Si `rentAmount` est renseign√© (location), alors `rentPeriodicity` doit aussi √™tre renseign√©.
- Si `rentAmount` est NULL (vente), alors `rentPeriodicity` doit aussi √™tre NULL.
- Cette logique est **d√©j√† garantie** par la condition d'affichage (`saleType === "√† louer"`).

---

**R√©sum√© des particularit√©s de `rentPeriodicity`**

| Aspect | D√©tail |
|--------|--------|
| **Nature** | Champ conditionnel li√© √† `rentAmount` |
| **Visibilit√©** | Affich√© uniquement si `saleType === "√† louer"` |
| **Format stockage actuel** | Texte brut (ex: `"Mensuel"`) |
| **Format stockage Supabase** | TEXT (ex: `"Mensuel"`) |
| **Parsing requis** | Non (format identique) |
| **Contrainte CHECK** | Validation crois√©e avec `saleType` + Validation des valeurs autoris√©es |
| **Champ li√©** | `rentAmount` (doivent √™tre renseign√©s ensemble ou NULL ensemble) |
| **Valeur par d√©faut** | `"Mensuel"` (d√©finie c√¥t√© frontend, pas en base) |
| **Validation explicite** | Aucune (bouton radio toujours s√©lectionn√© si visible) |

---
## Champ : **keyElements**

**Obligatoire : Oui**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape1/EnsembleFormulairesEtape1Form.tsx` (lignes 167-175) :
  ```typescript
  // 7. V√©rification "keyElements"
  if (!keyElements.trim()) {
    toast({
      title: "Erreur de validation",
      description: "Veuillez saisir au moins un argument commercial.",
      duration: 3000,
      variant: "destructive"
    });
    return false;
  }
  ```
- Le champ bloque la validation si vide ‚Üí **Obligatoire**

**Condition de remplissage**
**Sources :**
- Ligne 36 : `const [keyElements, setKeyElements] = useState("");` ‚Üí Pas de valeur par d√©faut
- Ligne 80 : `setKeyElements(propertyData.keyElements || "");` ‚Üí Chargement depuis `localStorage`
- **Aucune condition** : Le champ est toujours affich√© et toujours requis, quelle que soit la valeur de `saleType`

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `keyElements` stocke du **texte multiligne** avec formatage sp√©cifique :
  - Puces automatiques (`‚Ä¢ `) en d√©but de ligne
  - Capitalisation de la premi√®re lettre apr√®s la puce
  - Longueur variable (pas de limite technique)
- Format actuel dans `localStorage` : texte brut avec retours √† la ligne

**Contraintes Supabase**
```sql
NOT NULL,
CHECK (length(keyElements) > 0)
```
**Explication :**
- `NOT NULL` : Le champ ne peut pas √™tre vide
- `CHECK (length(keyElements) > 0)` : Garantit qu'il contient au moins 1 caract√®re (emp√™che les cha√Ænes vides)

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- R√©cup√©ration directe : `propertyData.keyElements`
- Aucun parsing n√©cessaire : le texte est stock√© tel quel

---

## Champ : **propertyDescription**

**Obligatoire : Oui**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape2/SaisieDescriptionForm.tsx` (lignes 43-52) :
  ```typescript
  const handleValidation = () => {
    if (!propertyDescription.trim()) {
      toast({
        title: "Erreur de validation",
        description: "Veuillez saisir une description du bien avant de continuer.",
        duration: 3000,
        variant: "destructive"
      });
      return;
    }

    updatePropertyData({ propertyDescription });
  ```
- Le champ est **toujours requis** pour valider l'√âtape 2.

**Condition de remplissage**

**Sources :**
- Lignes 96-103 du m√™me fichier montrent le champ en tant que champ unique obligatoire :
  ```typescript

  ```
- Le champ est **toujours visible** et **toujours requis**, sans condition.

**Type SQL : TEXT**

**Pourquoi ?**
- Le champ `propertyDescription` stocke une **description d√©taill√©e multiligne** du bien immobilier.
- En base de donn√©es Supabase, il doit √™tre stock√© comme **TEXT** car :
  - Contenu de longueur variable (pas de limite fixe).
  - Contient des retours √† la ligne (`\n`) et des caract√®res sp√©ciaux (`‚Ä¢ `).
  - Pas de calculs ou tris num√©riques n√©cessaires.
- **TEXT** est le type appropri√© pour du contenu textuel long sans limite de taille.

**Explication :**
- `NOT NULL` : Le champ ne peut jamais √™tre vide.
- `CHECK (length(propertyDescription) > 0)` : La description doit contenir au moins 1 caract√®re (√©vite les cha√Ænes vides).

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- R√©cup√©ration directe depuis `propertyData.propertyDescription`


**Formatage automatique**
Le composant `FormulaireSaisie` applique automatiquement :
1. **Ajout de puces `‚Ä¢ `** en d√©but de chaque ligne (si pas d√©j√† pr√©sentes)
2. **Capitalisation** de la premi√®re lettre apr√®s la puce
3. **Ajustement dynamique** de la hauteur du textarea
---

## Champ : **financials**

**Obligatoire : Oui**

**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape3/SaisieFinancialForm.tsx` (lignes 43-52) :
  ```typescript
  const handleValidation = () => {
    if (!financials.trim()) {
      toast({
        title: "Erreur de validation",
        description: "Veuillez saisir des informations financi√®res avant de continuer.",
        duration: 3000,
        variant: "destructive"
      });
      return;
    }
  ```
- Le champ est **toujours requis** √† l'√âtape 3 : impossible de passer √† l'√âtape 4 sans avoir saisi des informations financi√®res.

**Type SQL : TEXT**

**Pourquoi ?**
- Le champ `financials` est stock√© dans `localStorage` au format **texte format√©** avec puces `‚Ä¢ ` et capitalisation.
- Le type **TEXT** est adapt√© pour stocker du texte libre de longueur variable (sans limite stricte).
- Pas de traitement num√©rique ‚Üí pas besoin de `NUMERIC`.

**Contraintes Supabase**
**Explication :**
- **`NOT NULL`** : Le champ ne peut jamais √™tre vide (obligatoire).
- **`CHECK (length(financials) > 0)`** : Garantit que le champ contient au moins un caract√®re (√©vite les cha√Ænes vides).

---

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- R√©cup√©ration directe de `propertyData.financials` depuis `localStorage`.
- **Aucun parsing n√©cessaire** : le format stock√© dans `localStorage` (texte avec puces `‚Ä¢ `) est identique au format attendu en base.

**Formatage automatique**
- Le formatage (ajout des puces `‚Ä¢ `, capitalisation) est g√©r√© par le composant `FormulaireSaisie` **avant** la sauvegarde dans `localStorage`.
- La donn√©e est donc **d√©j√† format√©e** lors de la migration vers Supabase.

---

## **Champ : `details`**

**Obligatoire : Conditionnel**
**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape4/SaisieDetailsForm.tsx` (lignes 50-58) :
  ```typescript
  const handleValidation = () => {
    if (!hasNoDetails && details.trim() === "") {
      toast({
        title: "Attention",
        description: "Cette √©tape est optionnelle, mais vous devez indiquer votre choix. Soit cocher la case 'Je n'ai pas d'informations compl√©mentaires √† fournir', soit saisir des informations.",
        duration: 5000,
      });
      return;
    }
  ```
- **Particularit√©** : L'utilisateur **doit obligatoirement faire un choix** :
  - **Option A** : Cocher `hasNoDetails` ‚Üí `details` sera **vide**
  - **Option B** : Saisir du contenu dans `details` ‚Üí `hasNoDetails` sera **false**

**Condition de remplissage**
**Sources :**
- Lignes 119-130 : Checkbox "Je n'ai pas d'informations compl√©mentaires"
  ```typescript
   handleHasNoDetailsChange(e.target.checked)}
  />
  ```
- Lignes 42-48 : Gestion de la checkbox
  ```typescript
  const handleHasNoDetailsChange = (value: boolean) => {
    setHasNoDetails(value);
    if (value === true) {
      setDetails("");
    }
  };
  ```
- **Logique** :
  - Si `hasNoDetails = true` ‚Üí `details` **doit √™tre vide**
  - Si `hasNoDetails = false` ‚Üí `details` **doit contenir du texte** (sinon erreur de validation)

**Type SQL : TEXT**
**Pourquoi ?**
- Le champ `details` est stock√© dans le `localStorage` au format **texte multiligne** avec formatage automatique (puces `‚Ä¢ `, capitalisation).
- Comme les autres champs textuels (`propertyDescription`, `financials`), il n'a **pas de limite de longueur pr√©d√©finie**.
- **TEXT** est adapt√© pour stocker du contenu de taille variable sans contrainte stricte.

**Contraintes Supabase**
```sql
CHECK (
  (hasNoDetails = false AND length(details) > 0) 
  OR 
  (hasNoDetails = true AND (details IS NULL OR details = ''))
)
```
**Explication :**
- **Si `hasNoDetails = false`** ‚Üí `details` **doit contenir du texte** (`length(details) > 0`)
- **Si `hasNoDetails = true`** ‚Üí `details` **doit √™tre vide ou NULL** (`details IS NULL OR details = ''`)

‚ö†Ô∏è **Attention** : Cette contrainte CHECK doit √™tre **synchronis√©e avec le champ `hasNoDetails`** (voir section suivante).

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- **Cl√©** : `propertyData.details`
- **Format stock√©** : Texte avec puces `‚Ä¢ ` en d√©but de ligne + capitalisation automatique (g√©r√© par `FormulaireSaisie`)
- **Pas de parsing n√©cessaire** : Stockage direct en `TEXT`.

**Gestion du champ `hasNoDetails`**
- **Cl√©** : `propertyData.hasNoDetails`
- **Type** : `boolean`
- **Valeurs possibles** : `true` (utilisateur a coch√© la checkbox) ou `false` (utilisateur a saisi des informations)
- **Logique de chargement** (lignes 99-112) :
  ```typescript
  useEffect(() => {
    const propertyData = getPropertyDataFromStorage();

    if (propertyData.details) {
      setDetails(propertyData.details);
      setHasNoDetails(false);
    } else if (propertyData.hasNoDetails) {
      setHasNoDetails(true);
      setDetails("");
    } else {
      setHasNoDetails(false);
      setDetails("");
    }
  }, []);
  ```
**Particularit√©s de `details`**
**1. Seul champ optionnel avec choix obligatoire**
- Contrairement aux autres champs, `details` est **optionnel** mais **l'utilisateur doit explicitement indiquer son choix** :
  - Soit cocher "Je n'ai pas d'informations compl√©mentaires" (`hasNoDetails = true`)
  - Soit saisir du contenu dans le champ `details`

**2. D√©sactivation conditionnelle du champ**
- Ligne 139 : `readOnly={hasNoDetails}`
- Si la checkbox est coch√©e, le champ devient **en lecture seule** et est **vid√© automatiquement** (ligne 46).

---

## Champ : **hasNoDetails**

**Obligatoire : Conditionnel**

**Sources :**
- `src/components/1-Sources-Generation-Annonces/form-etape4/SaisieDetailsForm.tsx` (lignes 12-13) :
  ```typescript
  const [details, setDetails] = useState("");
  const [hasNoDetails, setHasNoDetails] = useState(false);
  ```
- **Valeur par d√©faut** : `false` (l'utilisateur n'a **pas** coch√© la case par d√©faut)

**Condition de remplissage**

**Sources :**
- Lignes 42-48 : Gestion de la checkbox
  ```typescript
  const handleHasNoDetailsChange = (value: boolean) => {
    setHasNoDetails(value);

    if (value === true) {
      setDetails("");  // ‚úÖ Si checkbox coch√©e ‚Üí details vid√©
    }
  };
  ```
- Lignes 35-40 : Auto-d√©cochage si saisie
  ```typescript
  const handleDetailsChange = (e: React.ChangeEvent) => {
    setDetails(e.target.value);
    if (e.target.value.trim() !== "") {
      setHasNoDetails(false);  // ‚úÖ Si l'utilisateur saisit ‚Üí checkbox d√©coch√©e
    }
  };
  ```

**Logique de synchronisation** :
- Si l'utilisateur **coche la checkbox** ‚Üí `hasNoDetails = true` ET `details = ""`
- Si l'utilisateur **saisit du texte** ‚Üí `hasNoDetails = false` automatiquement
- Les deux champs sont **mutuellement exclusifs** : soit checkbox coch√©e, soit contenu saisi

**Type SQL : BOOLEAN**

**Pourquoi ?**
- Le champ `hasNoDetails` est un **indicateur binaire** (vrai/faux)
- En base de donn√©es Supabase, il doit √™tre stock√© comme `BOOLEAN` pour :
  - Interrogations simples : `WHERE hasNoDetails = true`
  - Filtres performants (index sur bool√©ens)
  - Clart√© s√©mantique du mod√®le de donn√©es

**Valeur par d√©faut** : `false`
- Ligne 13 : `useState(false)` ‚Üí √©tat initial
- Ligne 110 : `setHasNoDetails(false)` ‚Üí si aucune donn√©e dans `localStorage`

**Contraintes Supabase**

**Explication :**
- **`NOT NULL`** : Le champ doit toujours avoir une valeur (jamais `NULL`)
- **`DEFAULT false`** : Valeur par d√©faut = `false` (pas de case coch√©e initialement)
- **`CHECK` (contrainte crois√©e avec `details`)** :
  - Si `hasNoDetails = false` ‚Üí `details` doit contenir du texte (`length(details) > 0`)
  - Si `hasNoDetails = true` ‚Üí `details` doit √™tre vide (`NULL` ou `''`)

Cette contrainte **garantit la coh√©rence** entre les deux champs et √©vite les √©tats invalides (ex : checkbox coch√©e + texte saisi).

**Actions √† pr√©voir**

**Migration des donn√©es depuis `localStorage`**
- R√©cup√©ration directe : `propertyData.hasNoDetails`
- Aucun parsing n√©cessaire (d√©j√† stock√© comme `boolean`)

**Code de chargement existant** (lignes 99-112) :
```typescript
useEffect(() => {
  const propertyData = getPropertyDataFromStorage();

  if (propertyData.details) {
    setDetails(propertyData.details);
    setHasNoDetails(false);  // ‚úÖ Si details pr√©sent ‚Üí hasNoDetails = false
  } else if (propertyData.hasNoDetails) {
    setHasNoDetails(true);   // ‚úÖ Si hasNoDetails = true dans storage
    setDetails("");          // ‚úÖ Details vid√©
  } else {
    setHasNoDetails(false);  // ‚úÖ Valeur par d√©faut
    setDetails("");
  }
}, []);
```
---
