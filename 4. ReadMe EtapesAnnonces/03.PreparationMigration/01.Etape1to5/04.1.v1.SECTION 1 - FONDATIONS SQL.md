# ðŸ“‹ SECTION 1 - FONDATIONS SQL

## **1.1. Table `etapes_1to5` (1 Ã©lÃ©ment)**

### **ðŸ“Œ Nom de l'Ã©lÃ©ment**
Table `etapes_1to5` - Table principale de stockage des donnÃ©es collectÃ©es lors des Ã‰tapes 1 Ã  5

### **ðŸ“ Emplacement prÃ©vu**
Migration SQL Supabase via outil de migration

### **ðŸŽ¯ ResponsabilitÃ© principale**
Stocker les 14 champs mÃ©tier `propertyData` collectÃ©s lors des Ã©tapes 1-5 du parcours de crÃ©ation d'annonce immobiliÃ¨re, avec gestion multi-tenant sÃ©curisÃ©e et visibilitÃ© hiÃ©rarchique.

---

### **ðŸ“Š Structure complÃ¨te de la table (30 champs)**

| CatÃ©gorie | Nombre de champs | Convention de nommage | Description |
|-----------|------------------|----------------------|-------------|
| **Champs systÃ¨me** | 9 | `snake_case` | Identifiants, dates, statuts systÃ¨me |
| **Champs analytiques** | 7 | `snake_case` | RÃ©fÃ©rences optionnelles pour analytics/traÃ§abilitÃ© |
| **Champs mÃ©tier** | 14 | **`camelCase`** | DonnÃ©es collectÃ©es Ã©tapes 1-5 (âš ï¸ IMPÃ‰RATIF : **PAS de transformation en `snake_case`**) |

---

### **ðŸ“‹ TABLEAU DÃ‰TAILLÃ‰ DES CHAMPS**

#### **1ï¸âƒ£ CHAMPS SYSTÃˆME (9 champs - `snake_case`)**

| Champ SQL | Type SQL | Contraintes | Valeur par dÃ©faut | Description | Auto-gÃ©rÃ© |
|-----------|----------|-------------|-------------------|-------------|-----------|
| `id` | `UUID` | `PRIMARY KEY`, `NOT NULL` | `gen_random_uuid()` | Identifiant unique du projet | âœ… Oui |
| `organisation_id` | `UUID` | `NOT NULL`, `FK â†’ organisations` | Injection auto via `get_user_organisation_id()` | Isolation tenant (multi-tenant) | âœ… Oui |
| `user_id` | `UUID` | `NOT NULL`, `FK â†’ users(users_id)` | Injection auto via `auth.uid()` | CrÃ©ateur du projet | âœ… Oui |
| `utilisateur_type_compte` | `TEXT` | `NOT NULL`, `CHECK (IN 'reseau', 'reseau_direction', ...)` | Injection auto via `get_user_type_compte()` | Type de compte utilisateur | âœ… Oui |
| `step_progress` | `INTEGER[]` | `NOT NULL`, `CHECK (1 = ANY(...))` | `'{1}'::integer[]` | Tableau cumulatif des Ã©tapes dÃ©verrouillÃ©es | Hook `completeStep()` |
| `statut` | `TEXT` | `CHECK (IN 'en_cours', 'archive')` | `'en_cours'` | Statut du projet | Trigger `statut_du_projet` |
| `validated_at` | `TIMESTAMPTZ` | `NULL` | `NULL` | Date de validation finale (Ã©tape 5) | Trigger `set_validated_at` |
| `created_at` | `TIMESTAMPTZ` | `NOT NULL` | `now()` | Date de crÃ©ation du projet | âœ… Oui |
| `updated_at` | `TIMESTAMPTZ` | `NOT NULL` | `now()` | Date derniÃ¨re modification | Trigger `set_updated_at` |

---

#### **2ï¸âƒ£ CHAMPS ANALYTIQUES OPTIONNELS (7 champs - `snake_case`)**

| Champ SQL | Type SQL | Contraintes | Valeur par dÃ©faut | Description | Auto-gÃ©rÃ© |
|-----------|----------|-------------|-------------------|-------------|-----------|
| `reseau_id` | `UUID` | `NULL`, `FK â†’ reseau` | Injection auto si type rÃ©seau | RÃ©fÃ©rence optionnelle vers rÃ©seau | Conditionnel |
| `reseau_agence_id` | `UUID` | `NULL`, `FK â†’ reseau_agence` | Injection auto si type agence rÃ©seau | RÃ©fÃ©rence optionnelle vers agence rÃ©seau | Conditionnel |
| `agence_indep_id` | `UUID` | `NULL`, `FK â†’ agence_independante` | Injection auto si type agence indÃ©p. | RÃ©fÃ©rence optionnelle vers agence indÃ©pendante | Conditionnel |
| `reseau_direction_id` | `UUID` | `NULL` | Injection auto si type direction rÃ©seau | RÃ©fÃ©rence optionnelle vers direction rÃ©seau | Conditionnel |
| `reseau_agence_responsable_id` | `UUID` | `NULL` | Injection auto si type responsable agence | RÃ©fÃ©rence optionnelle vers responsable | Conditionnel |
| `agence_indep_responsable_id` | `UUID` | `NULL` | Injection auto si type responsable agence indÃ©p. | RÃ©fÃ©rence optionnelle vers responsable | Conditionnel |
| `logs` | `JSONB` | `NULL` | `'{}'::jsonb` | Logs de modifications locales | Optionnel |

---

#### **3ï¸âƒ£ CHAMPS MÃ‰TIER (14 champs - âš ï¸ **`camelCase` IMPÃ‰RATIF**)**

| Champ SQL | Type SQL | Contraintes | Valeur par dÃ©faut | Ã‰tape | Obligatoire | Conditionnel |
|-----------|----------|-------------|-------------------|-------|-------------|--------------|
| `"agencyName"` | `TEXT` | `NOT NULL` | â€” | 1 | âœ… Oui | â€” |
| `"reference"` | `TEXT` | `NOT NULL` | â€” | 1 | âœ… Oui | â€” |
| `"exclusivite"` | `TEXT` | `NOT NULL`, `CHECK (IN 'Oui', 'Non')` | â€” | 1 | âœ… Oui | â€” |
| `"location"` | `TEXT` | `NOT NULL` | â€” | 1 | âœ… Oui | â€” |
| `"propertyType"` | `TEXT` | `NOT NULL` | â€” | 1 | âœ… Oui | â€” |
| `"saleType"` | `TEXT` | `NOT NULL`, `CHECK (IN 'Ã  vendre', 'Ã  louer')` | â€” | 1 | âœ… Oui | â€” |
| `"price"` | `NUMERIC(12,2)` | `NULL`, `CHECK (price >= 0)` | `NULL` | 1 | âš ï¸ Conditionnel | Si `saleType = 'Ã  vendre'` |
| `"rentAmount"` | `NUMERIC(12,2)` | `NULL`, `CHECK (rentAmount >= 0)` | `NULL` | 1 | âš ï¸ Conditionnel | Si `saleType = 'Ã  louer'` |
| `"rentPeriodicity"` | `TEXT` | `NULL`, `CHECK (IN 'Mensuel', 'Trimestriel', 'Annuel')` | `NULL` | 1 | âš ï¸ Conditionnel | Si `saleType = 'Ã  louer'` |
| `"keyElements"` | `TEXT` | `NOT NULL`, `CHECK (length(...) > 0)` | â€” | 1 | âœ… Oui | â€” |
| `"propertyDescription"` | `TEXT` | `NOT NULL`, `CHECK (length(...) > 0)` | â€” | 2 | âœ… Oui | â€” |
| `"financials"` | `TEXT` | `NOT NULL`, `CHECK (length(...) > 0)` | â€” | 3 | âœ… Oui | â€” |
| `"details"` | `TEXT` | `NULL` | `NULL` | 4 | âš ï¸ Conditionnel | Si `hasNoDetails = false` |
| `"hasNoDetails"` | `BOOLEAN` | `NOT NULL` | `false` | 4 | âœ… Oui | â€” |

---

### **ðŸ” CONTRAINTES TECHNIQUES IMPÃ‰RATIVES**

#### **RÃ¨gle SQL - CrÃ©ation de table (CRITIQUE)**
```sql
-- âœ… Champs mÃ©tier : "camelCase" (avec guillemets doubles)
CREATE TABLE etapes_1to5 (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organisation_id UUID NOT NULL,
  "agencyName" TEXT NOT NULL,  -- âš ï¸ GUILLEMETS OBLIGATOIRES
  "propertyType" TEXT NOT NULL,
  "saleType" TEXT NOT NULL
);
```

#### **RÃ¨gle TypeScript - Hooks & Services**
```typescript
// âœ… Utilisation directe du camelCase pour champs mÃ©tier
const { agencyName, propertyType, saleType } = propertyData;

// âœ… Utilisation directe du snake_case pour champs systÃ¨me
const { organisation_id, user_id, created_at } = record;

// âš ï¸ AUCUNE fonction de conversion n'est nÃ©cessaire
```

#### **RÃ¨gle Triggers SQL**
```sql
-- âœ… Syntaxe correcte dans les triggers
NEW."agencyName"     -- champ mÃ©tier camelCase
NEW.organisation_id  -- champ systÃ¨me snake_case
```

---

### **ðŸ“Œ CONTRAINTES MÃ‰TIER CRITIQUES**

#### **Contrainte 1 : CohÃ©rence `saleType` â†” `price` / `rentAmount`**
```sql
CHECK (
  (
    "saleType" = 'Ã  vendre' 
    AND "price" IS NOT NULL 
    AND "rentAmount" IS NULL 
    AND "rentPeriodicity" IS NULL
  )
  OR
  (
    "saleType" = 'Ã  louer' 
    AND "price" IS NULL 
    AND "rentAmount" IS NOT NULL 
    AND "rentPeriodicity" IS NOT NULL
  )
)
```

#### **Contrainte 2 : CohÃ©rence `hasNoDetails` â†” `details`**
```sql
CHECK (
  (
    "hasNoDetails" = false 
    AND length("details") > 0
  )
  OR
  (
    "hasNoDetails" = true 
    AND ("details" IS NULL OR "details" = '')
  )
)
```

#### **Contrainte 3 : ValiditÃ© `step_progress`**
```sql
CHECK (
  array_length(step_progress, 1) >= 1 
  AND 1 = ANY(step_progress) 
  AND step_progress <@ ARRAY[1,2,3,4,5]
)
```

---

### **ðŸ”‘ CLÃ‰S Ã‰TRANGÃˆRES (Foreign Keys)**

| Colonne | Table rÃ©fÃ©rencÃ©e | Colonne rÃ©fÃ©rencÃ©e | Action |
|---------|------------------|-------------------|--------|
| `organisation_id` | `organisations` | `organisation_id` | `ON DELETE CASCADE` |
| `user_id` | `users` | `users_id` | `ON DELETE CASCADE` |
| `reseau_id` | `reseau` | `reseau_id` | `ON DELETE SET NULL` |
| `reseau_agence_id` | `reseau_agence` | `reseau_agence_id` | `ON DELETE SET NULL` |
| `agence_indep_id` | `agence_independante` | `agence_indep_id` | `ON DELETE SET NULL` |

---

### **ðŸ“ NOTES STRATÃ‰GIQUES**

#### **Note 1 : Convention `camelCase` - CRITIQUE**
âš ï¸ **INTERDICTION FORMELLE de transformation `snake_case`**

**Raison** :
- Ã‰vite la rupture avec les 7 prompts OpenAI existants
- Ã‰vite la rupture avec l'Ã‰tape 6 Communication (Phase 2)
- Garantit une migration sans transformation de donnÃ©es

**Impact** :
- Les 14 champs mÃ©tier (`agencyName`, `propertyType`, `saleType`, `price`, `rentAmount`, `rentPeriodicity`, `keyElements`, `propertyDescription`, `financials`, `details`, `exclusivite`, `location`, `reference`) **DOIVENT IMPÃ‰RATIVEMENT** conserver leur structure `camelCase` en base de donnÃ©es.
- Seuls les champs systÃ¨me Supabase utilisent `snake_case` (`organisation_id`, `user_id`, `created_at`, `updated_at`, etc.).

---

#### **Note 2 : Champ `step_progress` (tableau non rÃ©gressif)**
**Fonctionnement** :
- Initialisation : `{1}` (seule l'Ã©tape 1 accessible)
- Progression : `completeStep(X)` ajoute l'Ã©tape suivante (ex : `{1, 2, 3}`)
- Navigation libre entre toutes les Ã©tapes prÃ©sentes
- **Non rÃ©gressif** : Ã©tapes ajoutÃ©es restent accessibles

**Utilisation** :
- `isStepAvailable(step)` : vÃ©rifie accessibilitÃ©
- `getDisabledSteps()` : calcule Ã©tapes dÃ©sactivÃ©es
- `hasCompletedStep4` : prÃ©sence du chiffre `5` dans le tableau

---

#### **Note 3 : Champ `statut` (cycle de vie projet)**
**Valeurs** :
- `'en_cours'` (dÃ©faut) : projet actif
- `'archive'` : projet validÃ© et archivÃ©

**Transition automatique** :
- Trigger `statut_du_projet`
- Condition : `validated_at IS NOT NULL` AND `5 = ANY(step_progress)`
- Action : `statut` passe de `'en_cours'` Ã  `'archive'`

---

#### **Note 4 : Champ `validated_at` (validation finale)**
**RÃ´le** : Enregistre la date et l'heure exactes de validation finale (Ã©tape 5)

**Trigger** :
- Nom : `set_validated_at`
- DÃ©clenchement : `BEFORE UPDATE`
- Condition : `NEW.validated_at IS NOT NULL` AND `OLD.validated_at IS NULL`
- Action : `validated_at := NOW()`

---

### **âš™ï¸ DÃ‰PENDANCES**

#### **Fonctions SQL Helper requises**
| Fonction | RÃ´le |
|----------|------|
| `get_user_organisation_id(user_uuid UUID)` | âœ… DÃ©jÃ  existante |
| `get_user_type_compte(user_uuid UUID)` | ðŸ†• Ã€ crÃ©er (Section 1.2) |
| `get_user_reseau_id(user_uuid UUID)` | âœ… DÃ©jÃ  existante |
| `get_user_reseau_agence_id(user_uuid UUID)` | ðŸ†• Ã€ crÃ©er (Section 1.2) |
| `get_user_agence_indep_id(user_uuid UUID)` | âœ… DÃ©jÃ  existante |
| `is_admin_presenca(user_uuid UUID)` | âœ… DÃ©jÃ  existante |

#### **Triggers SQL requis**
| Trigger | RÃ´le | Section |
|---------|------|---------|
| `set_updated_at_etapes1to5` | Met Ã  jour `updated_at` automatiquement | Section 1.3 |
| `set_validated_at_etapes1to5` | Met Ã  jour `validated_at` lors validation | Section 1.3 |
| `statut_du_projet_etapes1to5` | Passe `statut` Ã  `'archive'` si validÃ© | Section 1.3 |

#### **RLS Policies requises**
| Policy | RÃ´le | Section |
|--------|------|---------|
| `etapes_1to5_select_hierarchical` | VisibilitÃ© hiÃ©rarchique (SELECT) | Section 1.4 |
| `etapes_1to5_insert_own_organisation` | CrÃ©ation projet (INSERT) | Section 1.4 |
| `etapes_1to5_update_hierarchical` | Modification projet (UPDATE) | Section 1.4 |
| `etapes_1to5_delete_own_or_admin` | Suppression projet (DELETE) | Section 1.4 |

---

### **ðŸŽ¯ CHECKLIST DE MIGRATION**

- [ ] CrÃ©er la table `etapes_1to5` avec les 30 champs (9 systÃ¨me + 7 analytiques + 14 mÃ©tier)
- [ ] âš ï¸ **IMPÃ‰RATIF** : Utiliser guillemets doubles pour les 14 champs mÃ©tier `camelCase`
- [ ] Ajouter les contraintes `CHECK` (cohÃ©rence `saleType`, `hasNoDetails`, `step_progress`)
- [ ] Ajouter les clÃ©s Ã©trangÃ¨res (FK vers `organisations`, `users`, `reseau`, `reseau_agence`, `agence_independante`)
- [ ] CrÃ©er les fonctions SQL helper manquantes (Section 1.2)
- [ ] CrÃ©er les 3 triggers (Section 1.3)
- [ ] CrÃ©er les 4 RLS policies (Section 1.4)
- [ ] Activer RLS sur la table : `ALTER TABLE etapes_1to5 ENABLE ROW LEVEL SECURITY;`
- [ ] CrÃ©er les index de performance (`organisation_id`, `user_id`, `reseau_agence_id`, `agence_indep_id`)

---

**ðŸš€ Cette table constitue la fondation technique de toute la migration Phase 1.**


Je vais lire tous les documents demandÃ©s pour gÃ©nÃ©rer le markdown des 3 parties restantes de la SECTION 1 - FONDATIONS SQL.

**Note concernant les erreurs de build**: Je vois les erreurs TypeScript sur `FormAgenceIndependanteGestion.tsx` concernant les propriÃ©tÃ©s Stripe manquantes. Comme indiquÃ© dans vos directives (custom knowledge), ces erreurs sont **normales** car Stripe n'est pas encore activÃ© et **ne doivent PAS Ãªtre corrigÃ©es**. âœ…

CommenÃ§ons la lecture des documents...

Maintenant je vais continuer Ã  lire les documents des audits et prÃ©paration...

Maintenant, je vais continuer Ã  lire les autres documents demandÃ©s...

Parfait ! J'ai maintenant lu tous les documents demandÃ©s. Je vais maintenant gÃ©nÃ©rer le markdown pour les 3 parties restantes de la **SECTION 1 - FONDATIONS SQL** :

1. **Fonctions SQL Helper** (4 Ã©lÃ©ments)
2. **Triggers SQL** (4 Ã©lÃ©ments)  
3. **Politiques RLS** (2 Ã©lÃ©ments)

Voici le contenu markdown dÃ©taillÃ© :

---

# ðŸ“‹ SECTION 1 - FONDATIONS SQL (Suite)

## **1.2. Fonctions SQL Helper (4 Ã©lÃ©ments)**

### **ðŸ“Š Vue d'ensemble**

| # | Fonction | Statut | PrioritÃ© | ResponsabilitÃ© |
|---|----------|--------|----------|----------------|
| 1 | `get_user_type_compte()` | ðŸ†• Ã€ crÃ©er | Haute | RÃ©cupÃ¨re le type de compte utilisateur |
| 2 | `get_user_reseau_agence_id()` | ðŸ†• Ã€ crÃ©er | Haute | RÃ©cupÃ¨re l'ID de l'agence rÃ©seau de l'utilisateur |
| 3 | `user_belongs_to_reseau_agence()` | ðŸ†• Ã€ crÃ©er | Haute | VÃ©rifie appartenance Ã  une agence rÃ©seau |
| 4 | `user_belongs_to_agence_indep()` | ðŸ†• Ã€ crÃ©er | Haute | VÃ©rifie appartenance Ã  une agence indÃ©pendante |

---

### **1.2.1. Fonction `get_user_type_compte()`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom SQL** | `public.get_user_type_compte()` |
| **Emplacement** | Migration SQL Supabase |
| **Type** | `FUNCTION` |
| **Retour** | `TEXT` |
| **StabilitÃ©** | `STABLE` |
| **SÃ©curitÃ©** | `SECURITY DEFINER` |

#### **ðŸŽ¯ ResponsabilitÃ©**
RÃ©cupÃ¨re le type de compte utilisateur (`utilisateur_type_compte`) depuis la table `utilisateurs` en utilisant l'`auth.uid()`.

#### **ðŸ“¥ ParamÃ¨tres**
| ParamÃ¨tre | Type | Description |
|-----------|------|-------------|
| `user_uuid` | `UUID` | UUID de l'utilisateur depuis `auth.uid()` |

#### **ðŸ“¤ Retour**
| Type | Valeurs possibles |
|------|-------------------|
| `TEXT` | `'reseau'`, `'reseau_direction'`, `'reseau_agence'`, `'reseau_agence_responsable'`, `'reseau_agence_collaborateur'`, `'agence_independante'`, `'agence_independante_responsable'`, `'agence_independante_collaborateur'` |

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION public.get_user_type_compte(user_uuid UUID)
RETURNS TEXT
LANGUAGE SQL
STABLE
SECURITY DEFINER
SET search_path = 'public'
AS $$
  SELECT utilisateur_type_compte
  FROM utilisateurs
  WHERE utilisateur_auth_uid = user_uuid
  LIMIT 1;
$$;
```

#### **ðŸ“ Notes**
- âœ… Utilise `SECURITY DEFINER` pour bypass RLS (Ã©vite rÃ©cursion)
- âœ… Utilise `STABLE` (peut Ãªtre mise en cache dans une requÃªte)
- âœ… Limite Ã  1 rÃ©sultat (`LIMIT 1`)
- âš ï¸ Retourne `NULL` si utilisateur introuvable

---

### **1.2.2. Fonction `get_user_reseau_agence_id()`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom SQL** | `public.get_user_reseau_agence_id()` |
| **Type** | `FUNCTION` |
| **Retour** | `UUID` |
| **StabilitÃ©** | `STABLE` |
| **SÃ©curitÃ©** | `SECURITY DEFINER` |

#### **ðŸŽ¯ ResponsabilitÃ©**
RÃ©cupÃ¨re l'`reseau_agence_id` auquel appartient l'utilisateur (responsable ou collaborateur d'agence rÃ©seau).

#### **ðŸ“¥ ParamÃ¨tres**
| ParamÃ¨tre | Type | Description |
|-----------|------|-------------|
| `user_uuid` | `UUID` | UUID de l'utilisateur depuis `auth.uid()` |

#### **ðŸ“¤ Retour**
| Type | Description |
|------|-------------|
| `UUID` | ID de l'agence rÃ©seau OU `NULL` si non applicable |

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION public.get_user_reseau_agence_id(user_uuid UUID)
RETURNS UUID
LANGUAGE SQL
STABLE
SECURITY DEFINER
SET search_path = 'public'
AS $$
  -- Pour reseau_agence_responsable
  SELECT ra.reseau_agence_id
  FROM reseau_agence_responsable rar
  JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id
  JOIN reseau_agence ra ON ra.reseau_agence_id = rar.reseau_agence_id
  WHERE u.users_auth_id = user_uuid
  LIMIT 1;
$$;
```

#### **ðŸ“ Notes**
- âœ… Recherche dans `reseau_agence_responsable` ET `reseau_agence_collaborateur`
- âš ï¸ Retourne `NULL` si utilisateur n'appartient pas Ã  une agence rÃ©seau

---

### **1.2.3. Fonction `user_belongs_to_reseau_agence()`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom SQL** | `public.user_belongs_to_reseau_agence()` |
| **Type** | `FUNCTION` |
| **Retour** | `BOOLEAN` |
| **StabilitÃ©** | `STABLE` |
| **SÃ©curitÃ©** | `SECURITY DEFINER` |

#### **ðŸŽ¯ ResponsabilitÃ©**
VÃ©rifie si un `user_id` (internal `users.users_id`) appartient Ã  une agence rÃ©seau spÃ©cifique (responsable ou collaborateur).

#### **ðŸ“¥ ParamÃ¨tres**
| ParamÃ¨tre | Type | Description |
|-----------|------|-------------|
| `p_user_id` | `UUID` | ID utilisateur interne (`users.users_id`) |
| `p_reseau_agence_id` | `UUID` | ID de l'agence rÃ©seau Ã  vÃ©rifier |

#### **ðŸ“¤ Retour**
| Type | Description |
|------|-------------|
| `BOOLEAN` | `true` si appartient Ã  l'agence, `false` sinon |

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION public.user_belongs_to_reseau_agence(
  p_user_id UUID,
  p_reseau_agence_id UUID
)
RETURNS BOOLEAN
LANGUAGE SQL
STABLE
SECURITY DEFINER
SET search_path = 'public'
AS $$
  SELECT EXISTS (
    -- Responsable de cette agence
    SELECT 1 FROM reseau_agence_responsable
    WHERE reseau_agence_responsable_utilisateur_id = p_user_id
    AND reseau_agence_id = p_reseau_agence_id

    UNION

    -- Collaborateur de cette agence
    SELECT 1 FROM reseau_agence_collaborateur
    WHERE reseau_agence_collaborateur_utilisateur_id = p_user_id
    AND reseau_agence_id = p_reseau_agence_id
  );
$$;
```

#### **ðŸ“ Notes**
- âœ… Utilise `EXISTS` (optimisÃ© pour performance)
- âœ… VÃ©rifie Ã  la fois responsable ET collaborateur
- âœ… Retourne `false` si aucune correspondance

---

### **1.2.4. Fonction `user_belongs_to_agence_indep()`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom SQL** | `public.user_belongs_to_agence_indep()` |
| **Type** | `FUNCTION` |
| **Retour** | `BOOLEAN` |
| **StabilitÃ©** | `STABLE` |
| **SÃ©curitÃ©** | `SECURITY DEFINER` |

#### **ðŸŽ¯ ResponsabilitÃ©**
VÃ©rifie si un `user_id` appartient Ã  une agence indÃ©pendante spÃ©cifique (responsable ou collaborateur).

#### **ðŸ“¥ ParamÃ¨tres**
| ParamÃ¨tre | Type | Description |
|-----------|------|-------------|
| `p_user_id` | `UUID` | ID utilisateur interne (`users.users_id`) |
| `p_agence_indep_id` | `UUID` | ID de l'agence indÃ©pendante Ã  vÃ©rifier |

#### **ðŸ“¤ Retour**
| Type | Description |
|------|-------------|
| `BOOLEAN` | `true` si appartient Ã  l'agence, `false` sinon |

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION public.user_belongs_to_agence_indep(
  p_user_id UUID,
  p_agence_indep_id UUID
)
RETURNS BOOLEAN
LANGUAGE SQL
STABLE
SECURITY DEFINER
SET search_path = 'public'
AS $$
  SELECT EXISTS (
    -- Responsable de cette agence
    SELECT 1 FROM agence_independante_responsable
    WHERE agence_indep_responsable_utilisateur_id = p_user_id
    AND agence_indep_id = p_agence_indep_id

    UNION

    -- Collaborateur de cette agence
    SELECT 1 FROM agence_independante_collaborateur
    WHERE agence_indep_collaborateur_utilisateur_id = p_user_id
    AND agence_indep_id = p_agence_indep_id
  );
$$;
```

---

## **1.3. Triggers SQL (4 Ã©lÃ©ments)**

### **ðŸ“Š Vue d'ensemble**

| # | Trigger | Table | DÃ©clencheur | PrioritÃ© | ResponsabilitÃ© |
|---|---------|-------|-------------|----------|----------------|
| 1 | `set_updated_at_etapes1to5` | `etapes_1to5` | `BEFORE UPDATE` | Haute | Met Ã  jour automatiquement `updated_at` |
| 2 | `set_validated_at_etapes1to5` | `etapes_1to5` | `BEFORE UPDATE` | Moyenne | Renseigne `validated_at` lors validation |
| 3 | `statut_du_projet_etapes1to5` | `etapes_1to5` | `BEFORE UPDATE` | Moyenne | Passe `statut` Ã  `'archive'` si validÃ© |
| 4 | `populate_analytical_fields_etapes1to5` | `etapes_1to5` | `BEFORE INSERT/UPDATE` | Haute | Remplit champs analytiques optionnels |

---

### **1.3.1. Trigger `set_updated_at_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `set_updated_at_etapes1to5` |
| **Table** | `etapes_1to5` |
| **Ã‰vÃ©nement** | `BEFORE UPDATE` |
| **Fonction** | Fonction trigger gÃ©nÃ©rique ou dÃ©diÃ©e |

#### **ðŸŽ¯ ResponsabilitÃ©**
Met automatiquement Ã  jour le champ `updated_at` avec `NOW()` Ã  chaque modification d'un projet.

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION trigger_set_updated_at_etapes1to5()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_set_updated_at_etapes1to5();
```

#### **ðŸ“ Notes**
- âœ… ExÃ©cutÃ© avant (`BEFORE`) chaque `UPDATE`
- âœ… Garantit traÃ§abilitÃ© temporelle des modifications
- âš ï¸ Ne s'applique PAS sur `INSERT` (valeur par dÃ©faut `now()`)

---

### **1.3.2. Trigger `set_validated_at_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `set_validated_at_etapes1to5` |
| **Table** | `etapes_1to5` |
| **Ã‰vÃ©nement** | `BEFORE UPDATE` |

#### **ðŸŽ¯ ResponsabilitÃ©**
Renseigne automatiquement `validated_at` avec `NOW()` lors de la validation finale (Ã©tape 5).

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION trigger_set_validated_at_etapes1to5()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.validated_at IS NOT NULL AND OLD.validated_at IS NULL THEN
    NEW.validated_at := NOW();
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER set_validated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_set_validated_at_etapes1to5();
```

#### **ðŸ“ Notes**
- âœ… Condition : `NEW.validated_at IS NOT NULL` AND `OLD.validated_at IS NULL`
- âœ… S'exÃ©cute uniquement lors du **premier** passage Ã  `validated_at`
- âš ï¸ EmpÃªche modification ultÃ©rieure de `validated_at`

---

### **1.3.3. Trigger `statut_du_projet_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `statut_du_projet_etapes1to5` |
| **Table** | `etapes_1to5` |
| **Ã‰vÃ©nement** | `BEFORE UPDATE` |

#### **ðŸŽ¯ ResponsabilitÃ©**
Passe automatiquement le champ `statut` de `'en_cours'` Ã  `'archive'` lorsque le projet est validÃ© (Ã©tape 5 complÃ¨te + `validated_at` renseignÃ©).

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION trigger_statut_du_projet_etapes1to5()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.validated_at IS NOT NULL AND 5 = ANY(NEW.step_progress) THEN
    NEW.statut := 'archive';
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER statut_du_projet_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_statut_du_projet_etapes1to5();
```

#### **ðŸ“ Notes**
- âœ… Condition : `validated_at IS NOT NULL` AND `5 = ANY(step_progress)`
- âœ… Transition automatique `'en_cours'` â†’ `'archive'`
- âš ï¸ IrrÃ©versible (pas de retour possible Ã  `'en_cours'`)

---

### **1.3.4. Trigger `populate_analytical_fields_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `populate_analytical_fields_etapes1to5` |
| **Table** | `etapes_1to5` |
| **Ã‰vÃ©nement** | `BEFORE INSERT` ou `BEFORE UPDATE` |

#### **ðŸŽ¯ ResponsabilitÃ©**
Remplit automatiquement les champs analytiques optionnels (`reseau_id`, `reseau_agence_id`, `agence_indep_id`, etc.) en fonction du `utilisateur_type_compte`.

#### **âš™ï¸ Logique SQL**
```sql
CREATE OR REPLACE FUNCTION trigger_populate_analytical_fields_etapes1to5()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- RÃ©cupÃ©ration du type de compte
  CASE NEW.utilisateur_type_compte
    WHEN 'reseau', 'reseau_direction' THEN
      NEW.reseau_id := get_user_reseau_id(NEW.user_id);

    WHEN 'reseau_agence', 'reseau_agence_responsable', 'reseau_agence_collaborateur' THEN
      NEW.reseau_agence_id := get_user_reseau_agence_id(NEW.user_id);

    WHEN 'agence_independante', 'agence_independante_responsable', 'agence_independante_collaborateur' THEN
      NEW.agence_indep_id := get_user_agence_indep_id(NEW.user_id);
  END CASE;

  RETURN NEW;
END;
$$;

CREATE TRIGGER populate_analytical_fields_etapes1to5
BEFORE INSERT OR UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_populate_analytical_fields_etapes1to5();
```

---

## **1.4. Politiques RLS (2 Ã©lÃ©ments)**

### **ðŸ“Š Vue d'ensemble**

| # | Policy | OpÃ©rations | PrioritÃ© | ResponsabilitÃ© |
|---|--------|------------|----------|----------------|
| 1 | `admin_presenca_full_access_etapes1to5` | `ALL` | Haute | AccÃ¨s complet pour admins PRESENCA |
| 2 | `organisation_hierarchical_access_etapes1to5` | `SELECT`, `INSERT`, `UPDATE`, `DELETE` | Haute | VisibilitÃ© hiÃ©rarchique multi-tenant |

---

### **1.4.1. Policy `admin_presenca_full_access_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `admin_presenca_full_access_etapes1to5` |
| **Table** | `etapes_1to5` |
| **OpÃ©rations** | `ALL` (SELECT, INSERT, UPDATE, DELETE) |
| **Type** | `PERMISSIVE` |

#### **ðŸŽ¯ ResponsabilitÃ©**
Accorde un accÃ¨s total (lecture/Ã©criture/suppression) aux administrateurs PRESENCA sur tous les projets de toutes les organisations.

#### **âš™ï¸ Logique SQL**
```sql
CREATE POLICY "admin_presenca_full_access_etapes1to5"
ON public.etapes_1to5
FOR ALL
TO authenticated
USING (
  is_admin_presenca(auth.uid())
)
WITH CHECK (
  is_admin_presenca(auth.uid())
);
```

#### **ðŸ“ Notes**
- âœ… Utilise la fonction `is_admin_presenca()` existante
- âœ… S'applique Ã  toutes les opÃ©rations (`ALL`)
- âš ï¸ **AccÃ¨s transversal** Ã  toutes les organisations (pour impersonation et support)

---

### **1.4.2. Policy `organisation_hierarchical_access_etapes1to5`**

#### **ðŸ“Œ Informations gÃ©nÃ©rales**
| PropriÃ©tÃ© | Valeur |
|-----------|--------|
| **Nom** | `organisation_hierarchical_access_etapes1to5` |
| **Table** | `etapes_1to5` |
| **OpÃ©rations** | `SELECT`, `INSERT`, `UPDATE`, `DELETE` |

#### **ðŸŽ¯ ResponsabilitÃ©**
GÃ¨re la visibilitÃ© hiÃ©rarchique des projets selon le type de compte utilisateur :
- RÃ©seau/Direction : voient projets rÃ©seau
- Agence/Responsable : voient projets de leur agence
- Collaborateur : voit uniquement ses propres projets

#### **âš™ï¸ Logique SQL (SELECT)**
```sql
CREATE POLICY "organisation_hierarchical_access_etapes1to5_select"
ON public.etapes_1to5
FOR SELECT
TO authenticated
USING (
  organisation_id = get_user_organisation_id(auth.uid())
  AND
  CASE get_user_type_compte(auth.uid())
    WHEN 'reseau', 'reseau_direction' THEN
      utilisateur_type_compte IN ('reseau', 'reseau_direction')

    WHEN 'reseau_agence', 'reseau_agence_responsable' THEN
      reseau_agence_id = get_user_reseau_agence_id(auth.uid())

    WHEN 'reseau_agence_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    WHEN 'agence_independante', 'agence_independante_responsable' THEN
      agence_indep_id = get_user_agence_indep_id(auth.uid())

    WHEN 'agence_independante_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())

    ELSE false
  END
);
```

#### **ðŸ“ Notes**
- âœ… Isolation stricte par `organisation_id` (niveau 1)
- âœ… VisibilitÃ© hiÃ©rarchique par `utilisateur_type_compte` (niveau 2)
- âœ… Collaborateurs voient **uniquement** leurs propres projets
- âš ï¸ Requiert les 4 fonctions SQL helper crÃ©Ã©es (Section 1.2)

---

**ðŸŽ¯ Checklist Finale - Section 1**
- [ ] 4 fonctions SQL helper crÃ©Ã©es
- [ ] 4 triggers SQL crÃ©Ã©s
- [ ] 2 RLS policies crÃ©Ã©es
- [ ] RLS activÃ©e sur `etapes_1to5`
