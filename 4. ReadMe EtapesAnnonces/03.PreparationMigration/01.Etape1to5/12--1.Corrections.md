# üîê MIGRATION S√âCURIS√âE OPENAI - DOCUMENT COMPLET

**Date:** 19/11/2025  
**Version:** 3.0 - Structure fran√ßaise dissoci√©e  
**Architecture:** 7 Edge Functions + 7 Services Frontend

---

## üìã TABLE DES MATI√àRES

1. [Vue d'ensemble](#vue-densemble)
2. [Partie 1 : Frontend (10 fichiers)](#partie-1--frontend)
3. [Partie 2 : Backend (11 fichiers)](#partie-2--backend)
4. [D√©ploiement](#d√©ploiement)
5. [Utilisation](#utilisation)

---

## VUE D'ENSEMBLE

### üèóÔ∏è Architecture compl√®te

```
üì¶ LEADGENAI
‚îÇ
‚îú‚îÄ‚îÄ üìÅ src/services/openai/01.SupabaseEtape1to5/
‚îÇ   ‚îú‚îÄ‚îÄ 1.Services/                    ‚Üê 7 fichiers √† cr√©er
‚îÇ   ‚îú‚îÄ‚îÄ 2.Helpers/                     ‚Üê 3 fichiers √† cr√©er
‚îÇ   ‚îî‚îÄ‚îÄ 7.PromptsOpenAi/               ‚Üê src/services/openai/01.SupabaseEtape1to5/00.PromptsOpenAi
‚îÇ
‚îî‚îÄ‚îÄ üìÅ supabase/functions/
    ‚îú‚îÄ‚îÄ 1.AnnonceSiteInternet/         ‚Üê 7 Edge Functions
    ‚îú‚îÄ‚îÄ 2.AnnonceFichedeSynthese/
    ‚îú‚îÄ‚îÄ 3.AnnonceNewsletter/
    ‚îú‚îÄ‚îÄ 4.OutilsSEO/
    ‚îú‚îÄ‚îÄ 5.SMSAnnonce/
    ‚îú‚îÄ‚îÄ 6.GoogleBusinessProfileAnnonce/
    ‚îú‚îÄ‚îÄ 7.ReseauxSociauxAnnonce/
    ‚îî‚îÄ‚îÄ Shared/                         ‚Üê Code partag√©
```

### üîê Flux de donn√©es s√©curis√©

```
Frontend (Browser)
  ‚Üì Charge prompt depuis 7.PromptsOpenAi/
  ‚Üì Remplace placeholders avec fillPrompt()
  ‚Üì Appelle callSecureGenerate()
  ‚Üì
Edge Function (Serveur Supabase)
  ‚Üì V√©rifie authentification user
  ‚Üì V√©rifie project_id appartient au user
  ‚Üì R√©cup√®re cl√© OpenAI (RESTE SERVEUR) ‚úÖ
  ‚Üì Appelle OpenAI avec cl√© s√©curis√©e ‚úÖ
  ‚Üì Retourne UNIQUEMENT le r√©sultat
  ‚Üì
Frontend
  ‚îî‚îÄ Stocke r√©sultat dans localStorage
```

---

# PARTIE 1 : FRONTEND

## üìÇ Cr√©er : src/services/openai/01.SupabaseEtape1to5/2.Helpers/

### FICHIER 1 : 2.Helpers/types.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/2.Helpers/types.ts

/**
 * Interface des donn√©es projet
 */
export interface PropertyData {
  project_id: string;
  agencyName?: string;
  reference?: string;
  exclusivite?: string;
  location?: string;
  propertyType?: string;
  saleType?: string;
  price?: string;
  rentAmount?: string;
  rentPeriodicity?: string;
  keyElements?: string;
  propertyDescription?: string;
  financials?: string;
  details?: string;
  hasNoDetails?: boolean;
}

/**
 * Mapping service name ‚Üí Edge Function name
 */
export const SERVICE_TO_EDGE_FUNCTION: Record<string, string> = {
  "website_ad": "1.AnnonceSiteInternet",
  "summary_sheet": "2.AnnonceFichedeSynthese",
  "newsletter": "3.AnnonceNewsletter",
  "seo_tools": "4.OutilsSEO",
  "sms_ad": "5.SMSAnnonce",
  "google_business_profile": "6.GoogleBusinessProfileAnnonce",
  "reseaux_sociaux": "7.ReseauxSociauxAnnonce"
};
```

---

### FICHIER 2 : 2.Helpers/fillPrompt.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/2.Helpers/fillPrompt.ts

import type { PropertyData } from "./types";

/**
 * Remplace les placeholders du prompt avec les donn√©es du projet
 * 
 * Placeholders support√©s :
 * - [nom de l'agence immobili√®re]
 * - [type de bien commercial: restaurant, bar, boutique, etc.]
 * - [√† vendre ou √† louer]
 * - [localisation du bien]
 * - [points forts et arguments commerciaux]
 * - [montant]
 * - [mensuel, trimestriel, ou annuel]
 * - [Oui] / [Oui ou Non]
 * - [r√©f√©rence du bien]
 * - [description d√©taill√©e du bien]
 * - [d√©tails financiers du bien]
 * - [informations compl√©mentaires]
 */
export function fillPrompt(prompt: string, data: PropertyData): string {
  return prompt
    // √âtape 1 - √âl√©ments cl√©s
    .replace(/\[nom de l'agence immobili√®re\]/g, data.agencyName || "")
    .replace(/\[type de bien commercial.*?\]/g, data.propertyType || "")
    .replace(/\[√† vendre ou √† louer\]/g, data.saleType || "")
    .replace(/\[localisation du bien\]/g, data.location || "")
    .replace(/\[points forts et arguments commerciaux\]/g, data.keyElements || "")
    
    // Prix / Loyer
    .replace(/\[montant\]/g, data.price || data.rentAmount || "")
    .replace(/\[mensuel, trimestriel.*?\]/g, data.rentPeriodicity || "")
    
    // Exclusivit√© (g√®re [Oui] et [Oui ou Non])
    .replace(/\[Oui ou Non\]/g, data.exclusivite === "Oui" ? "Oui" : "Non")
    .replace(/\[Oui\]/g, data.exclusivite === "Oui" ? "Oui" : "Non")
    
    // R√©f√©rence
    .replace(/\[r√©f√©rence du bien\]/g, data.reference || "")
    
    // √âtape 2 - Description
    .replace(/\[description d√©taill√©e du bien\]/g, data.propertyDescription || "")
    
    // √âtape 3 - Financials
    .replace(/\[d√©tails financiers du bien\]/g, data.financials || "")
    
    // √âtape 4 - Autres d√©tails
    .replace(/\[informations compl√©mentaires\]/g, data.details || "");
}
```

---

### FICHIER 3 : 2.Helpers/callSecureGenerate.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/2.Helpers/callSecureGenerate.ts

import { supabase } from "@/integrations/supabase/client";
import { SERVICE_TO_EDGE_FUNCTION } from "./types";

/**
 * Appelle l'Edge Function s√©curis√©e correspondant au service
 * 
 * @param projectId - ID du projet (v√©rifi√© c√¥t√© serveur)
 * @param serviceName - Nom du service (ex: "website_ad")
 * @param promptFilled - Prompt avec placeholders d√©j√† remplac√©s
 * @returns R√©sultat de la g√©n√©ration OpenAI
 * @throws Error si authentification √©choue, projet non trouv√©, ou g√©n√©ration √©choue
 */
export async function callSecureGenerate(
  projectId: string,
  serviceName: string,
  promptFilled: string
): Promise<any> {
  // 1. V√©rifier session active
  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    throw new Error("No active session. Please log in.");
  }

  // 2. Mapper service ‚Üí Edge Function
  const edgeFunction = SERVICE_TO_EDGE_FUNCTION[serviceName];
  if (!edgeFunction) {
    throw new Error(`Unknown service: ${serviceName}`);
  }

  console.log(`[callSecureGenerate] Calling ${edgeFunction} for project ${projectId}`);

  // 3. Appeler Edge Function
  // ‚úÖ CORRECTION : Utiliser import.meta.env.VITE_SUPABASE_URL au lieu de supabase.supabaseUrl
  const response = await fetch(
    `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/${edgeFunction}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({
        project_id: projectId,
        prompt_filled: promptFilled
      })
    }
  );

  // 4. G√©rer erreurs
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ error: "Unknown error" }));
    console.error(`[callSecureGenerate] Error from ${edgeFunction}:`, errorData);
    throw new Error(errorData.error || `Generation failed (${response.status})`);
  }

  // 5. Retourner r√©sultat
  const data = await response.json();
  console.log(`[callSecureGenerate] Success - Tokens used: ${data.usage?.total_tokens || "N/A"}`);
  
  return data.result;
}
```

---

## üìÇ Cr√©er : src/services/openai/01.SupabaseEtape1to5/1.Services/

### FICHIER 4 : 1.Services/1.AnnonceSiteInternet.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/1.AnnonceSiteInternet.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptAnnonceSiteInternet } from "../00.PromptsOpenAi/1.PromptAnnonceSiteInternet";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une annonce pour site internet (VERSION S√âCURIS√âE)
 * 
 * La cl√© OpenAI reste c√¥t√© serveur et n'est jamais expos√©e au client.
 * 
 * @param data - Donn√©es du projet (doit contenir project_id)
 * @returns Objet JSON avec { titre, accroche, descriptif, cta }
 * @throws Error si g√©n√©ration √©choue
 */
export async function generateWebsiteAd(
  data: PropertyData
): Promise<{
  titre: string;
  accroche: string;
  descriptif: string;
  cta: string;
}> {
  // 1. Remplir le prompt avec les donn√©es
  const promptFilled = fillPrompt(promptAnnonceSiteInternet, data);

  // 2. Appeler Edge Function s√©curis√©e
  const result = await callSecureGenerate(data.project_id, "website_ad", promptFilled);

  // 3. Retourner r√©sultat typ√©
  return result;
}
```

---

### FICHIER 5 : 1.Services/2.AnnonceFichedeSynthese.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/2.AnnonceFichedeSynthese.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptAnnonceFichedeSynthese } from "../00.PromptsOpenAi/2.PromptAnnonceFichedeSynthese";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une fiche de synth√®se (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { titre, referenceEtPrix, detailsCles, donneesFinancieres, informationsComplementaires }
 */
export async function generateSummarySheet(
  data: PropertyData
): Promise<{
  titre: string;
  referenceEtPrix: string;
  detailsCles: string;
  donneesFinancieres: string;
  informationsComplementaires: string;
}> {
  const promptFilled = fillPrompt(promptAnnonceFichedeSynthese, data);
  return await callSecureGenerate(data.project_id, "summary_sheet", promptFilled);
}
```

---

### FICHIER 6 : 1.Services/3.AnnonceNewsletter.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/3.AnnonceNewsletter.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptAnnonceNewsletter } from "../00.PromptsOpenAi/3.PromptAnnonceNewsletter";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une annonce newsletter (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { titre, accroche, pointsForts, callToAction, prixEtReference }
 */
export async function generateNewsletter(
  data: PropertyData
): Promise<{
  titre: string;
  accroche: string;
  pointsForts: string;
  callToAction: string;
  prixEtReference: string;
}> {
  const promptFilled = fillPrompt(promptAnnonceNewsletter, data);
  return await callSecureGenerate(data.project_id, "newsletter", promptFilled);
}
```

---

### FICHIER 7 : 1.Services/4.OutilsSEO.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/4.OutilsSEO.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptOutilsSEO } from "../00.PromptsOpenAi/4.PromptOutilsSEO";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re des outils SEO (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { baliseTitre, baliseMetaDescription, urlLongueTraine }
 */
export async function generateSEOTools(
  data: PropertyData
): Promise<{
  baliseTitre: string;
  baliseMetaDescription: string;
  urlLongueTraine: string;
}> {
  const promptFilled = fillPrompt(promptOutilsSEO, data);
  return await callSecureGenerate(data.project_id, "seo_tools", promptFilled);
}
```

---

### FICHIER 8 : 1.Services/5.SMSAnnonce.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/5.SMSAnnonce.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptSMSAnnonce } from "../00.PromptsOpenAi/5.PromptSMSAnnonce";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une annonce SMS (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { "restitution-annonce-sms" }
 */
export async function generateSMSAnnonce(
  data: PropertyData
): Promise<{
  "restitution-annonce-sms": string;
}> {
  const promptFilled = fillPrompt(promptSMSAnnonce, data);
  return await callSecureGenerate(data.project_id, "sms_ad", promptFilled);
}
```

---

### FICHIER 9 : 1.Services/6.GoogleBusinessProfileAnnonce.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/6.GoogleBusinessProfileAnnonce.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptGoogleBusinessProfileAnnonce } from "../00.PromptsOpenAi/6.PromptGoogleBusinessProfileAnnonce";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une annonce Google Business Profile (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { TitreAnnonceGoogle, AccrocheDescriptiveAnnonceGoogle, PointsFortsAnnonceGoogle, CtaAnnonceGoogle }
 */
export async function generateGoogleBusinessProfile(
  data: PropertyData
): Promise<{
  TitreAnnonceGoogle: string;
  AccrocheDescriptiveAnnonceGoogle: string;
  PointsFortsAnnonceGoogle: string;
  CtaAnnonceGoogle: string;
}> {
  const promptFilled = fillPrompt(promptGoogleBusinessProfileAnnonce, data);
  return await callSecureGenerate(data.project_id, "google_business_profile", promptFilled);
}
```

---

### FICHIER 10 : 1.Services/7.ReseauxSociauxAnnonce.ts

```typescript
// src/services/openai/01.SupabaseEtape1to5/1.Services/7.ReseauxSociauxAnnonce.ts

import { callSecureGenerate } from "../2.Helpers/callSecureGenerate";
import { fillPrompt } from "../2.Helpers/fillPrompt";
import { promptReseauxSociauxAnnonce } from "../00.PromptsOpenAi/7.PromptReseauxSociauxAnnonce";
import type { PropertyData } from "../2.Helpers/types";

/**
 * G√©n√®re une annonce R√©seaux Sociaux (VERSION S√âCURIS√âE)
 * 
 * @param data - Donn√©es du projet
 * @returns Objet JSON avec { TitreAnnonceReseaux, AccrocheImpactanteAnnonceReseaux, AtoutsAnnonceReseaux, CtaAnnonceReseaux }
 */
export async function generateReseauxSociaux(
  data: PropertyData
): Promise<{
  TitreAnnonceReseaux: string;
  AccrocheImpactanteAnnonceReseaux: string;
  AtoutsAnnonceReseaux: string;
  CtaAnnonceReseaux: string;
}> {
  const promptFilled = fillPrompt(promptReseauxSociauxAnnonce, data);
  return await callSecureGenerate(data.project_id, "reseaux_sociaux", promptFilled);
}
```

---

# PARTIE 2 : BACKEND (EDGE FUNCTIONS)

## üìÇ Cr√©er : supabase/functions/Shared/

### FICHIER 11 : Shared/types.ts

```typescript
// supabase/functions/Shared/types.ts

export interface GenerateRequest {
  project_id: string;
  prompt_filled: string;
}

export interface GenerateResponse {
  success: boolean;
  result: any;
  usage?: {
    total_tokens: number;
    prompt_tokens: number;
    completion_tokens: number;
  };
}
```

---

### FICHIER 12 : Shared/constants.ts

```typescript
// supabase/functions/Shared/constants.ts

export const MODEL_OPENAI = "gpt-5-mini-2025-08-07";
export const MAX_COMPLETION_TOKENS = 3000;
```

---

### FICHIER 13 : Shared/helpers.ts

```typescript
// supabase/functions/Shared/helpers.ts

import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

export function json(body: unknown, status = 200): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

export function ok(body: unknown): Response {
  return json(body, 200);
}

export function badRequest(body: unknown): Response {
  return json(body, 400);
}

export function unauthorized(body: unknown): Response {
  return json(body, 401);
}

export async function parseJson<T = unknown>(req: Request): Promise<T | null> {
  try {
    const txt = await req.text();
    if (!txt) return {} as T;
    return JSON.parse(txt) as T;
  } catch {
    return null;
  }
}

export function createSupabaseClient(req: Request) {
  const supabaseUrl = Deno.env.get("SUPABASE_URL");
  const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY");

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error("Missing SUPABASE_URL or SUPABASE_ANON_KEY");
  }

  return createClient(supabaseUrl, supabaseAnonKey, {
    global: {
      headers: {
        Authorization: req.headers.get("Authorization") ?? "",
      },
    },
  });
}
```

---

## üìÇ Cr√©er les 7 Edge Functions

### FICHIER 14 : 1.AnnonceSiteInternet/index.ts

```typescript
// supabase/functions/1.AnnonceSiteInternet/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  // V√©rifier authentification
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  // Parser body
  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    // V√©rifier que le projet appartient √† l'utilisateur
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found or not accessible" });
    }

    // R√©cup√©rer cl√© OpenAI (RESTE SERVEUR) ‚úÖ
    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key found" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[AnnonceSiteInternet] Generating for project ${project_id}`);

    // Appeler OpenAI
    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    // Parser JSON
    let parsedResult: any;
    try {
      let cleaned = resultText.trim();
      if (cleaned.startsWith("```json")) {
        cleaned = cleaned.replace(/^```json\s*/, "").replace(/\s*```$/, "");
      } else if (cleaned.startsWith("```")) {
        cleaned = cleaned.replace(/^```\s*/, "").replace(/\s*```$/, "");
      }
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    // Logger usage
    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[AnnonceSiteInternet] ${tokensUsed} tokens, ${responseTime}ms`);

    // Retourner r√©sultat
    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[AnnonceSiteInternet] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 15 : 2.AnnonceFichedeSynthese/index.ts

```typescript
// supabase/functions/2.AnnonceFichedeSynthese/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[FichedeSynthese] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[FichedeSynthese] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[FichedeSynthese] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 16 : 3.AnnonceNewsletter/index.ts

```typescript
// supabase/functions/3.AnnonceNewsletter/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[Newsletter] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[Newsletter] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[Newsletter] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 17 : 4.OutilsSEO/index.ts

```typescript
// supabase/functions/4.OutilsSEO/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[OutilsSEO] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[OutilsSEO] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[OutilsSEO] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 18 : 5.SMSAnnonce/index.ts

```typescript
// supabase/functions/5.SMSAnnonce/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[SMSAnnonce] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[SMSAnnonce] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[SMSAnnonce] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 19 : 6.GoogleBusinessProfileAnnonce/index.ts

```typescript
// supabase/functions/6.GoogleBusinessProfileAnnonce/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[GoogleBusiness] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[GoogleBusiness] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[GoogleBusiness] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

### FICHIER 20 : 7.ReseauxSociauxAnnonce/index.ts

```typescript
// supabase/functions/7.ReseauxSociauxAnnonce/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import {
  createSupabaseClient,
  ok,
  badRequest,
  unauthorized,
  parseJson,
} from "../Shared/helpers.ts";
import { MODEL_OPENAI, MAX_COMPLETION_TOKENS } from "../Shared/constants.ts";
import type { GenerateRequest, GenerateResponse } from "../Shared/types.ts";

serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  const supabase = createSupabaseClient(req);

  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    return unauthorized({ error: "Unauthorized" });
  }

  const body = await parseJson<GenerateRequest>(req);
  if (!body?.project_id || !body?.prompt_filled) {
    return badRequest({ error: "Missing project_id or prompt_filled" });
  }

  const { project_id, prompt_filled } = body;

  try {
    const { data: projectData, error: projectError } = await supabase
      .from("etapes_1to5")
      .select("project_id")
      .eq("project_id", project_id)
      .eq("user_id", user.id)
      .eq("statut", "en_cours")
      .maybeSingle();

    if (projectError || !projectData) {
      return badRequest({ error: "Project not found" });
    }

    const { data: keyData, error: keyError } = await supabase
      .from("openai_api_keys")
      .select("openai_api_key")
      .eq("is_active", true)
      .maybeSingle();

    if (keyError || !keyData?.openai_api_key) {
      return badRequest({ error: "No active OpenAI key" });
    }

    const apiKey = keyData.openai_api_key;

    console.log(`[ReseauxSociaux] Generating for project ${project_id}`);

    const startTime = Date.now();
    const openaiResponse = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: MODEL_OPENAI,
        max_completion_tokens: MAX_COMPLETION_TOKENS,
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          { role: "user", content: prompt_filled }
        ]
      })
    });

    const responseTime = Date.now() - startTime;

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json();
      return badRequest({ error: `OpenAI error: ${errorData.error?.message}` });
    }

    const openaiData = await openaiResponse.json();
    const resultText = openaiData.choices[0].message.content;

    let parsedResult: any;
    try {
      let cleaned = resultText.trim()
        .replace(/^```json\s*/, "")
        .replace(/^```\s*/, "")
        .replace(/\s*```$/, "");
      parsedResult = JSON.parse(cleaned);
    } catch {
      parsedResult = { raw_text: resultText };
    }

    const tokensUsed = openaiData.usage?.total_tokens || 0;
    console.log(`[ReseauxSociaux] ${tokensUsed} tokens, ${responseTime}ms`);

    const response: GenerateResponse = {
      success: true,
      result: parsedResult,
      usage: {
        total_tokens: tokensUsed,
        prompt_tokens: openaiData.usage?.prompt_tokens || 0,
        completion_tokens: openaiData.usage?.completion_tokens || 0
      }
    };

    return ok(response);

  } catch (error) {
    console.error("[ReseauxSociaux] Error:", error);
    return badRequest({ error: "Internal error" });
  }
});
```

---

# D√âPLOIEMENT

## üìã Commandes Supabase CLI

```bash
# 1. Installer Supabase CLI (si pas fait)
npm install -g supabase

# 2. Se connecter
supabase login

# 3. Lier ton projet
supabase link --project-ref TON_PROJECT_ID

# 4. Cr√©er les dossiers Edge Functions (d√©j√† fait si tu copies les fichiers)

# 5. D√©ployer les 7 Edge Functions
supabase functions deploy 1.AnnonceSiteInternet
supabase functions deploy 2.AnnonceFichedeSynthese
supabase functions deploy 3.AnnonceNewsletter
supabase functions deploy 4.OutilsSEO
supabase functions deploy 5.SMSAnnonce
supabase functions deploy 6.GoogleBusinessProfileAnnonce
supabase functions deploy 7.ReseauxSociauxAnnonce

# 6. V√©rifier le d√©ploiement
supabase functions list
```

---

# UTILISATION

## üìù Exemple d'appel depuis ton code

```typescript
import { generateWebsiteAd } from "@/services/openai/01.SupabaseEtape1to5/1.Services/1.AnnonceSiteInternet";
import type { PropertyData } from "@/services/openai/01.SupabaseEtape1to5/2.Helpers/types";

// R√©cup√©rer donn√©es projet
const projectData: PropertyData = {
  project_id: "uuid-du-projet",
  agencyName: "Presenca Immobilier",
  propertyType: "Restaurant",
  saleType: "√† vendre",
  location: "Paris 11√®me",
  price: "150 000 ‚Ç¨ FAI",
  // ... autres champs
};

// G√©n√©rer annonce (CL√â S√âCURIS√âE)
try {
  const result = await generateWebsiteAd(projectData);
  console.log("Titre:", result.titre);
  console.log("Accroche:", result.accroche);
  
  // Stocker dans localStorage
  localStorage.setItem("generation_website_ad", JSON.stringify(result));
} catch (error) {
  console.error("Erreur g√©n√©ration:", error);
}
```

---

# ‚úÖ CHECKLIST FINALE

- [ ] **Frontend** : 10 fichiers cr√©√©s dans `src/services/openai/01.SupabaseEtape1to5/`
- [ ] **Backend** : 11 fichiers cr√©√©s dans `supabase/functions/`
- [ ] **D√©ploiement** : 7 Edge Functions d√©ploy√©es sur Supabase
- [ ] **Test** : 1 g√©n√©ration test√©e avec succ√®s
- [ ] **Cl√© OpenAI** : JAMAIS expos√©e c√¥t√© client ‚úÖ
- [ ] **RLS** : V√©rifie que project_id appartient au user ‚úÖ
- [ ] **Logs** : Console logs actifs pour debug ‚úÖ

---

**Date de derni√®re mise √† jour :** 19/11/2025  
**Statut :** ‚úÖ **Document complet pr√™t √† d√©ployer**

