# üìã SECTION 1 - FONDATIONS SQL ‚Äî **nnn4.1.01-Section-1-MigrationValid√©e**

> **Statut :** Document final de r√©f√©rence pour codage Supabase (Phase 1).  
> **Sources fusionn√©es :** *Doc source Section 1* + *041.1.CritiqueSECTION1.md* + *CorrSection1.md*.  
> **R√®gle d‚Äôor :** Ne rien alt√©rer hors corrections valid√©es. Champs **m√©tier** en **camelCase** (avec guillemets). Champs **syst√®me** en **snake_case**.

---

## **1.1. Table `etapes_1to5` (1 √©l√©ment)**

### **üìå Nom de l'√©l√©ment**  
**Table `etapes_1to5`** ‚Äî table principale de stockage des donn√©es collect√©es lors des √âtapes 1 √† 5.

### **üìÅ Emplacement pr√©vu**  
Migration SQL Supabase via outil de migration.

### **üéØ Responsabilit√© principale**  
Stocker les **14 champs m√©tier `propertyData`** des √©tapes 1‚Äì5 du parcours de cr√©ation d‚Äôannonce, avec **multi-tenant** s√©curis√© et **visibilit√© hi√©rarchique**.

---

### **üìä Structure compl√®te de la table (30 champs)**

| Cat√©gorie | # | Convention | Description |
|---|---:|---|---|
| **Champs syst√®me** | 9 | `snake_case` | Identifiants, dates, statuts |
| **Champs analytiques** | 7 | `snake_case` | R√©f√©rences optionnelles pour analytics/tra√ßabilit√© |
| **Champs m√©tier** | 14 | **`camelCase`** | Donn√©es collect√©es (‚ö†Ô∏è **PAS** de transformation en snake_case) |

---

### **üìã TABLEAU D√âTAILL√â DES CHAMPS**

#### **1Ô∏è‚É£ CHAMPS SYST√àME (9 ‚Äî `snake_case`)**

| Champ SQL | Type | Contraintes | D√©faut | Description | Auto |
|---|---|---|---|---|---|
| `id` | UUID | `PRIMARY KEY`, `NOT NULL` | `gen_random_uuid()` | Identifiant unique | ‚úÖ |
| `organisation_id` | UUID | `NOT NULL`, **FK** ‚Üí `organisations(organisation_id)` **ON DELETE CASCADE** | ‚Äî | Tenant racine | ‚úÖ |
| `user_id` | UUID | **FK** ‚Üí `users(users_id)` **ON DELETE SET NULL** | ‚Äî | Cr√©ateur du projet (peut devenir `NULL` si suppression compte) | ‚úÖ |
| `utilisateur_type_compte` | TEXT | `NOT NULL`, `CHECK (IN ‚Ä¶)` | ‚Äî | Type de compte actif | ‚úÖ |
| `step_progress` | INTEGER[] | `NOT NULL`, `CHECK` non-r√©gressif | `'{1}'` | √âtapes d√©verrouill√©es cumulatives | Hook |
| `statut` | TEXT | `CHECK ('en_cours','archive')` | `'en_cours'` | Statut du projet | Trigger |
| `validated_at` | TIMESTAMPTZ | `NULL` | `NULL` | Date de validation finale | Trigger |
| `created_at` | TIMESTAMPTZ | `NOT NULL` | `now()` | Cr√©ation | ‚úÖ |
| `updated_at` | TIMESTAMPTZ | `NOT NULL` | `now()` | Derni√®re modif | Trigger |

> ‚úÖ **Correction valid√©e :** `user_id` passe en **ON DELETE SET NULL** (conservation des projets lors du d√©part d‚Äôun collaborateur).  
> ‚úÖ **Correction valid√©e :** `organisation_id` **ON DELETE CASCADE** (isolation tenant).

---

#### **2Ô∏è‚É£ CHAMPS ANALYTIQUES OPTIONNELS (7 ‚Äî `snake_case`)**

| Champ SQL | Type | Contraintes | D√©faut | Description | Auto |
|---|---|---|---|---|---|
| `reseau_id` | UUID | `NULL`, FK ‚Üí `reseau` | ‚Äî | R√©seau (si applicable) | Cond. |
| `reseau_agence_id` | UUID | `NULL`, FK ‚Üí `reseau_agence` | ‚Äî | Agence r√©seau (si applicable) | Cond. |
| `agence_indep_id` | UUID | `NULL`, FK ‚Üí `agence_independante` | ‚Äî | Agence ind√©pendante | Cond. |
| `reseau_direction_id` | UUID | `NULL` | ‚Äî | Direction r√©seau | Cond. |
| `reseau_agence_responsable_id` | UUID | `NULL` | ‚Äî | Responsable d‚Äôagence r√©seau | Cond. |
| `agence_indep_responsable_id` | UUID | `NULL` | ‚Äî | Responsable d‚Äôagence ind√©pendante | Cond. |
| `logs` | JSONB | `NULL` | `'{}'::jsonb` | Journalisation locale optionnelle | ‚Äî |

---

#### **3Ô∏è‚É£ CHAMPS M√âTIER (14 ‚Äî ‚ö†Ô∏è **`camelCase`**)**
> ‚ö†Ô∏è **IMP√âRATIF** : champs entre **guillemets doubles** dans SQL, **jamais** convertis.

| Champ SQL | Type | Contraintes | D√©faut | √âtape | Obligatoire | Conditionnel |
|---|---|---|---|---:|---|---|
| `"agencyName"` | TEXT | `NOT NULL` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"reference"` | TEXT | `NOT NULL` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"exclusivite"` | TEXT | `NOT NULL`, `CHECK (IN 'Oui','Non')` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"location"` | TEXT | `NOT NULL` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"propertyType"` | TEXT | `NOT NULL` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"saleType"` | TEXT | `NOT NULL`, `CHECK (IN '√† vendre','√† louer')` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"price"` | TEXT | `CHECK (length(trim("price")) > 0)` | `NULL` | 1 | ‚ö†Ô∏è | Si `"saleType"='√† vendre'` |
| `"rentAmount"` | TEXT | `CHECK (length(trim("rentAmount")) > 0)` | `NULL` | 1 | ‚ö†Ô∏è | Si `"saleType"='√† louer'` |
| `"rentPeriodicity"` | TEXT | `CHECK (IN 'Mensuel','Trimestriel','Annuel')` | `NULL` | 1 | ‚ö†Ô∏è | Si `"saleType"='√† louer'` |
| `"keyElements"` | TEXT | `NOT NULL`, `CHECK (length("keyElements")>0)` | ‚Äî | 1 | ‚úÖ | ‚Äî |
| `"propertyDescription"` | TEXT | `NOT NULL`, `CHECK (length("propertyDescription")>0)` | ‚Äî | 2 | ‚úÖ | ‚Äî |
| `"financials"` | TEXT | `NOT NULL`, `CHECK (length("financials")>0)` | ‚Äî | 3 | ‚úÖ | ‚Äî |
| `"details"` | TEXT | `NULL` | `NULL` | 4 | ‚ö†Ô∏è | Si `"hasNoDetails"=false` |
| `"hasNoDetails"` | BOOLEAN | `NOT NULL` | `false` | 4 | ‚úÖ | ‚Äî |

---

### **üîê CONTRAINTES M√âTIER CRITIQUES**

**Contrainte 1 ‚Äî `saleType`**  
```sql
CHECK (
  (
    "saleType" = '√† vendre'
    AND "price" IS NOT NULL
    AND length(trim("price")) > 0
    AND "rentAmount" IS NULL
    AND "rentPeriodicity" IS NULL
  ) OR (
    "saleType" = '√† louer'
    AND "price" IS NULL
    AND "rentAmount" IS NOT NULL
    AND length(trim("rentAmount")) > 0
    AND "rentPeriodicity" IS NOT NULL
  )
)

```

**Contrainte 2 ‚Äî `hasNoDetails` ‚Üî `details`**  
```sql
CHECK (
  (
    "hasNoDetails" = false AND length("details") > 0
  ) OR (
    "hasNoDetails" = true AND ("details" IS NULL OR "details" = '')
  )
)
```

**Contrainte 3 ‚Äî `step_progress` non r√©gressif**  
```sql
CHECK (
  array_length(step_progress, 1) >= 1
  AND 1 = ANY(step_progress)
  AND step_progress <@ ARRAY[1,2,3,4,5]
)
```

---

### **üîë CL√âS √âTRANG√àRES (FK)**

| Colonne | R√©f√©rence | Action |
|---|---|---|
| `organisation_id` | `organisations(organisation_id)` | **ON DELETE CASCADE** |
| `user_id` | `users(users_id)` | **ON DELETE SET NULL** |
| `reseau_id` | `reseau(reseau_id)` | `ON DELETE SET NULL` |
| `reseau_agence_id` | `reseau_agence(reseau_agence_id)` | `ON DELETE SET NULL` |
| `agence_indep_id` | `agence_independante(agence_indep_id)` | `ON DELETE SET NULL` |

> ‚úÖ **Correction valid√©e** : `user_id` devient nullable (`ON DELETE SET NULL`).

---

### **üìù NOTES STRAT√âGIQUES**

- **Convention `camelCase` (critique) :** aucune transformation vers `snake_case` pour les 14 champs m√©tier.  
- **`step_progress`** : initialis√© √† `{1}`, progression additive, non r√©gressive.  
- **`statut`** : `'en_cours'` ‚Üí `'archive'` via trigger quand √©tape 5 valid√©e + `validated_at` non nul.  
- **Timer** : **d√©sactiv√©**, non migr√© (aucune r√©f√©rence en base).

---

## **1.2. Fonctions SQL Helper (4 √©l√©ments)**

### **1.2.1. `get_user_type_compte(user_uuid UUID)`**
Retourne le type de compte (`TEXT`).  
```sql
CREATE OR REPLACE FUNCTION public.get_user_type_compte(user_uuid UUID)
RETURNS TEXT
LANGUAGE SQL STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT utilisateur_type_compte
  FROM utilisateurs
  WHERE utilisateur_auth_uid = user_uuid
  LIMIT 1;
$$;
```

---

### **1.2.2. `get_user_reseau_agence_id(user_uuid UUID)` ‚Äî ‚úÖ *Corrig√©e***
Inclut **3 tables** + **`LIMIT 1`** (d√©fensif).  
```sql
CREATE OR REPLACE FUNCTION public.get_user_reseau_agence_id(user_uuid UUID)
RETURNS UUID
LANGUAGE SQL STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT reseau_agence_id FROM (
    SELECT ra.reseau_agence_id
    FROM reseau_agence ra
    JOIN users u ON u.users_id = ra.reseau_agence_utilisateur_id
    WHERE u.users_auth_id = user_uuid
    UNION ALL
    SELECT rar.reseau_agence_id
    FROM reseau_agence_responsable rar
    JOIN users u ON u.users_id = rar.reseau_agence_responsable_utilisateur_id
    WHERE u.users_auth_id = user_uuid
    UNION ALL
    SELECT rac.reseau_agence_id
    FROM reseau_agence_collaborateur rac
    JOIN users u ON u.users_id = rac.reseau_agence_collaborateur_utilisateur_id
    WHERE u.users_auth_id = user_uuid
  ) AS combined
  LIMIT 1;
$$;
```

---

### **1.2.3. `user_belongs_to_reseau_agence(p_user_id UUID, p_reseau_agence_id UUID)`**
```sql
CREATE OR REPLACE FUNCTION public.user_belongs_to_reseau_agence(
  p_user_id UUID,
  p_reseau_agence_id UUID
) RETURNS BOOLEAN
LANGUAGE SQL STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM reseau_agence_responsable
    WHERE reseau_agence_responsable_utilisateur_id = p_user_id
      AND reseau_agence_id = p_reseau_agence_id
    UNION
    SELECT 1 FROM reseau_agence_collaborateur
    WHERE reseau_agence_collaborateur_utilisateur_id = p_user_id
      AND reseau_agence_id = p_reseau_agence_id
  );
$$;
```

---

### **1.2.4. `user_belongs_to_agence_indep(p_user_id UUID, p_agence_indep_id UUID)`**
```sql
CREATE OR REPLACE FUNCTION public.user_belongs_to_agence_indep(
  p_user_id UUID,
  p_agence_indep_id UUID
) RETURNS BOOLEAN
LANGUAGE SQL STABLE SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM agence_independante_responsable
    WHERE agence_indep_responsable_utilisateur_id = p_user_id
      AND agence_indep_id = p_agence_indep_id
    UNION
    SELECT 1 FROM agence_independante_collaborateur
    WHERE agence_indep_collaborateur_utilisateur_id = p_user_id
      AND agence_indep_id = p_agence_indep_id
  );
$$;
```

---

## **1.3. Triggers SQL (4 √©l√©ments)**

> ‚úÖ **Correction valid√©e :** `updated_at` en **BEFORE UPDATE**.

### **1.3.1. `set_updated_at_etapes1to5`**
```sql
CREATE OR REPLACE FUNCTION trigger_set_updated_at_etapes1to5()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

CREATE TRIGGER set_updated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_set_updated_at_etapes1to5();
```

### **1.3.2. `set_validated_at_etapes1to5`**
```sql
CREATE OR REPLACE FUNCTION trigger_set_validated_at_etapes1to5()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.validated_at IS NOT NULL AND OLD.validated_at IS NULL THEN
    NEW.validated_at := NOW();
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER set_validated_at_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_set_validated_at_etapes1to5();
```

### **1.3.3. `statut_du_projet_etapes1to5`**
```sql
CREATE OR REPLACE FUNCTION trigger_statut_du_projet_etapes1to5()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.validated_at IS NOT NULL AND 5 = ANY(NEW.step_progress) THEN
    NEW.statut := 'archive';
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER statut_du_projet_etapes1to5
BEFORE UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_statut_du_projet_etapes1to5();
```

### **1.3.4. `populate_analytical_fields_etapes1to5`**
> ‚úÖ **Correction de syntaxe** (`CASE WHEN NEW.utilisateur_type_compte IN (‚Ä¶) THEN ‚Ä¶`).  
```sql
CREATE OR REPLACE FUNCTION trigger_populate_analytical_fields_etapes1to5()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  CASE
    WHEN NEW.utilisateur_type_compte IN ('reseau','reseau_direction') THEN
      NEW.reseau_id := get_user_reseau_id(NEW.user_id);

    WHEN NEW.utilisateur_type_compte IN ('reseau_agence','reseau_agence_responsable','reseau_agence_collaborateur') THEN
      NEW.reseau_agence_id := get_user_reseau_agence_id(NEW.user_id);

    WHEN NEW.utilisateur_type_compte IN ('agence_independante','agence_independante_responsable','agence_independante_collaborateur') THEN
      NEW.agence_indep_id := get_user_agence_indep_id(NEW.user_id);
  END CASE;

  RETURN NEW;
END;
$$;

CREATE TRIGGER populate_analytical_fields_etapes1to5
BEFORE INSERT OR UPDATE ON etapes_1to5
FOR EACH ROW
EXECUTE FUNCTION trigger_populate_analytical_fields_etapes1to5();
```

---

## **1.4. Politiques RLS (2 √©l√©ments)**

### **1.4.1. `admin_presenca_full_access_etapes1to5`**
```sql
CREATE POLICY admin_presenca_full_access_etapes1to5
ON public.etapes_1to5
FOR ALL TO authenticated
USING (is_admin_presenca(auth.uid()))
WITH CHECK (is_admin_presenca(auth.uid()));
```

### **1.4.2. `etapes_1to5_select_hierarchical` (SELECT) ‚Äî ‚úÖ *Corrig√©e***
> Visibilit√© strictement limit√©e √† *l‚Äôagence* pour les responsables ; le **r√©seau** ne voit **que ses projets internes**.
```sql
CREATE POLICY etapes_1to5_select_hierarchical
ON public.etapes_1to5
FOR SELECT TO authenticated
USING (
  CASE get_user_type_compte(auth.uid())
    WHEN 'reseau','reseau_direction' THEN
      utilisateur_type_compte IN ('reseau','reseau_direction')
    WHEN 'reseau_agence','reseau_agence_responsable' THEN
      reseau_agence_id = get_user_reseau_agence_id(auth.uid())
      AND utilisateur_type_compte IN ('reseau_agence','reseau_agence_responsable','reseau_agence_collaborateur')
    WHEN 'reseau_agence_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())
    WHEN 'agence_independante','agence_independante_responsable' THEN
      agence_indep_id = get_user_agence_indep_id(auth.uid())
      AND utilisateur_type_compte IN ('agence_independante','agence_independante_responsable','agence_independante_collaborateur')
    WHEN 'agence_independante_collaborateur' THEN
      user_id = (SELECT users_id FROM users WHERE users_auth_id = auth.uid())
    ELSE false
  END
);
```

#### **INSERT / UPDATE / DELETE (hi√©rarchie inchang√©e)**
```sql
CREATE POLICY etapes_1to5_insert_own
ON public.etapes_1to5
FOR INSERT TO authenticated
WITH CHECK (
  organisation_id = get_user_organisation_id(auth.uid())
  AND user_id IN (SELECT users_id FROM users WHERE users_auth_id = auth.uid())
  AND utilisateur_type_compte = get_user_type_compte(auth.uid())
);
-- UPDATE : m√™me hi√©rarchie que SELECT (adapter USING / WITH CHECK)
-- DELETE : r√©serv√© √† admin_presenca ou cr√©ateur
```

---

## **1.5. Checklist de migration**

- [ ] Cr√©er `etapes_1to5` (30 champs) ‚Äî ‚ö†Ô∏è **guillemets** pour 14 champs **camelCase**.  
- [ ] Ajouter contraintes `CHECK` (coh√©rence `saleType`, `hasNoDetails`, `step_progress`).  
- [ ] FK (`organisations`, `users`, `reseau`, `reseau_agence`, `agence_independante`).  
- [ ] Fonctions helper (1.2.1 ‚Üí 1.2.4).  
- [ ] Triggers (1.3.1 ‚Üí 1.3.4).  
- [ ] Policies RLS (1.4.1 ‚Üí 1.4.2).  
- [ ] `ALTER TABLE etapes_1to5 ENABLE ROW LEVEL SECURITY;`  
- [ ] Index perf : `organisation_id`, `user_id`, `reseau_agence_id`, `agence_indep_id`.

---

## **1.6. Synth√®se des corrections int√©gr√©es**

| √âl√©ment | Avant | Apr√®s |
|---|---|---|
| Trigger `updated_at` | `AFTER UPDATE` | **`BEFORE UPDATE`** ‚úÖ |
| FK `organisation_id` | ‚Äî | **`ON DELETE CASCADE`** ‚úÖ |
| FK `user_id` | CASCADE | **`ON DELETE SET NULL`** ‚úÖ |
| `get_user_reseau_agence_id()` | 2 tables | **3 tables + LIMIT 1** ‚úÖ |
| RLS (responsables) | visibilit√© organisation | **visibilit√© agence uniquement** ‚úÖ |
| camelCase | risque de conversion | **guillemets obligatoires** ‚úÖ |

---

### **Pied de document ‚Äî Validation**  
Document valid√© par **Admin Presenca** ‚Ä¢ Corrections Lovable appliqu√©es ‚Ä¢ Relecture OpenAI ‚Ä¢ *Octobre 2025*.
